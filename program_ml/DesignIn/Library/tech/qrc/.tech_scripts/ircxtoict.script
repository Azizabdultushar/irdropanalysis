
eval 'exec perl -S $0 ${1+"$@"}'
if 0;
###!/grid/common/bin/perl
# NOTE!  The "exec perl" invocation above has known problems when run
# #        under the Bourne shell!  If you ever expect your script to be
# #        run from cron, use the #!/path/to/perl option instead!
# #######################################################################
# #
# #  SmplxLglNtc  [ Copyright (c) 2002-2003
# #               | Cadence Design Systems, Inc. All rights reserved.
# #               |
# #               | THIS PROGRAM IS CONFIDENTIAL AND PROPRIETARY
# #               | TO CADENCE DESIGN SYSTEMS, INC. AND CONSTITUTES
# #               | A VALUABLE TRADE SECRET.
# #               |
# #               | This work may not be copied, modified, re-published,
# #               | uploaded, executed, or distributed in any way, in any
# #               | medium, whether in whole or in part, without prior
# #               | written permission from Cadence Design Systems, Inc.
# #               ]
# #  Synopsis     [ This is developed and maintained by Santosh Shah from the
# #                 Extraction PE team in Cadence Design Systems. For questions
# #                 please contact sanshah@cadence.com  ]
# #  Description  [ This is a script to translate proprietary TSMC IRCX format # #                 to proprietary Cadence ICT format ]
# #  History :
##### 06/27/2008 - Added topThickness to the damage metal dielectric  and ILD dielectric splitting
##### 07/10/2008 - Added temperature and scale factor handling after change in ircx format
##### 07/21/2008 - Added EM constructs handling for IRCX file and modified the usage of script to optionally write-out ICT EM  constructs
##### v1.06 08/06/2008  - Added Cf-Cco table support and extended support for EM constructs
##### v1.07 09/11/2008  - Fixed Cco table minor bug - Table values negative to ircx values
##### v1.08 09/16/2008  - Put area scaling in via for EM constructs
##### v1.09 09/16/2008  - Script updated to standard perl gift template
##### v1.10 09/23/2008  - In case of 1D width_depedent_tc table in IRCX file, ICT file will output simple tc1 tc2 syntax and not table syntax
##### v1.11 10/29/2008  - EM values for AC PEAK also copied to DC PEAK 
##### v1.12 02/05/2009  - EM constructs changed from em_model_wlt to em_output_wlt
##### v1.13 02/27/2009  - -v option  now outputs the Extraction release version and the internal script version now becomes control ID 
##### v1.14 03/05/2009  - Change the version output printing from Extraction to ircxtoict
##### v1.15 04/06/2009  - Added the multi Cf Cco support
##### v1.155 10/29/2009 - Added better process node identification
##### v2.000 11/22/2009 - 28nm support includes changes as below :
#####                   - Support diffusion as metal
#####                   - sub_conductor in active
#####                   - STEP layer support
#####                   - sub_conductor has resistivity & temperature co-efficients
#####                   - OPC table support
#####                   - Slot via support
#####                   - via_top_bottom enlargement in via section and many other changes for 28nm support. 
#####                   - EM use-model change. EM rules written out by default - CCR 701232
#####                   - Remove layout scaling in EM rules - CCR 701232
##### v2.010 12/10/2009 - Added fix for double rho table print out
##### v2.100 02/19/2010 - Slot via syntax support
#####                   - Change "metal" to "M" for 28nm and below process nodes
#####                   - Support area_dependent_tc tables for the via layers
#####                   - CCR's 736688, 736665 from Tom Taylor
##### v2.200 06/01/2010 - Rho table support for poly
#####                   - Enhanced slot via table support for multiple vias
#####                   - Height/Thickness for sub conductor
#####                   - Temp tc1/tc2, area resistance for sub via
#####                   - CCR 788775 
#####                   - CCR 809382
##### v2.210 12/20/2010 - TSV model change .
#####  	     01/16/2011 - Line number issue fixed .
##### v2.220 01/20/2011 - Merged in new EM output processing using subroutines
#####                   - Changed core removing built-in processing to subroutine calls
#####                   - Tidied up a few format lines throughout removing extra spaces after new line character
#####                   - Commented out layer stack print out left for debug
#####                   - em output subroutines handle new 40nm EM constructs
#####                   - Added both DC and AC peak limits
#####                   - Handles 28nm metal em rules but not via rules yet
##### v2.230 01/20/2011 - Minor formating improvements
##### v2.240 01/31/2011 - Minor formating improvements for vias
#####                   - Added handling for 28nm Via EM rules with additional l/w constructs
##### v2.250 02/03/2011 - Initialise conductor em variables to eliminate extra lines being printed out
##### v2.260 02/22/2011 - Re-order VIA pwl to ascending via area when multiple area statements
##### v2.270 03/01/2011 - Error in ordering of metal jmax numbers using newer versions of perl (5.8) 
##### v2.280 03/03/2011 - Error in ordering of via PWL area jmax numbers
#####                   - And corrected ordering of EQU in vias
#####                   - Correct ordering when L present in equations
##### v2.290 03/08/2011 - Fix Bugs in older technologies
##### v2.300 03/10/2011 - Modified L/W Via syntax for multiple entries per R&D agreement on format
##### V2.310 04/15/2011 - Correct L== and Lv== Wv== to area and not via_range
##### V2.320 06/30/2011 - For N28 above process , add following syntax at poly Cont :
##### 			  min_top_encl , min_bot_encl , min_width and min_spacing  
##### 			- For N28 process,add following syntax at poly conductor and sub_conductor: 
#####                     wire_edge_enlargement , wire_thickness_ratio 
#####                   - For N65 process and N55 process , add following syntax at onCont and via Info.  :
#####                   - min_top_encl , min_bot_encl , min_width and min_spacing 
##### V2.321 08/23/2011 - For N65 above process , modified the calculation method at wtr_width_ranges .
#####                   - When min_width == condition_width , change the X_range == 0 
#####                   - When max_width == condition_width , change the Y_range == min_width 10 * min_width
##### V2.322 09/02/2011 - Fixed the issue when poly no have INDIE_TABLE .
##### V2.330 09/15/2011 - Add new function syntax at N20  .
#####                   - Here is N28 part : 
#####			  Update the n_poly height and p_poly height as fpoly height . 
##### 			- Here is N20 part : 
#####			  1. add new syntax "raised_diffusion" at active conductor and sub conductor . 
#####			  2. Add new syntax "gate_diffusion_fringing_inverse_cap" "cfi_width" "cfi_lengths" "cfi_values" at poly sub conductor . 
#####			  3. Add following new dielectric , and add new syntax "expandedFromSubConductor" : 
#####		             under_the_poly 
#####		 	     under_gate 
#####                        under_OD 
#####			  4. Add following new conductor : 
#####		 	     M0_PO_N 
#####			     M0_PO_P 
##### 			     M0_STI1 
#####			     M0_STI2 
#####			     M0_OD1 
#####		  	     M0_OD2 
#####			  5. Add syntax "via_edge_enlargement" at M0_OD1 sub conductor . 
#####			  6. Add new via as following : 
#####			     VIA0_M0_PO_N 
#####			     VIA0_M0_PO_P 
#####                        VIA0_M0_OD 
#####			     VIA0_M0_STI 
#####			     mdtap 
#####			     mstap 
#####			     n_fptap 
#####			     p_fptap 
#####			     odtap 
#####			  7. Add new syntax "fracture_vias" at following via : 
#####			     mdtap 
#####			     mstap 
#####			     n_fptap 
#####			     p_fptap 
#####			     odtap 
#####			  8. add "gate_facing_via_resistance" at odtap and sub_via . 
##### V2.340 11/29/2011 - Correct min_contact_poly_spacing at N20  .
#####			- Correct cfi_values at poly sub conductor . 
#####			- Correct slot_via_long_edge_enlargement at contact and via .
#####                   - CCR 952694
##### V2.350 02/23/2012 - Add new EM syntax "em_segment_length" at process header
#####                   - Add new EM syntax "current_direction up", "current_direction down" and "single" for N20 at via layer
#####                   - Modify max_metal_layer_number parsing
#####                   - Enhance EM coverage to support the condition ex. 4 >= Lu for via
#####                   - Enhance EM coverage to support the condition ex. 4 >= L and 2 < L <= 4 for metal
#####                   - CCR 969768
##### v2.360 03/30/2012 - 20nm support includes changes as below :
#####                   - Add following new conductor
#####                     poly_srm
#####                     M0_PO_N_SRM
#####                     M0_PO_P_SRM
#####                     M0_STI1_SRM
#####                     M0_STI2_SRM
#####                     M0_OD2_SRM
#####                   - Add following new dielectric
#####                     SPACER_SRM
#####                     LINER_SRM
#####                     upder_the_poly_srm
#####			- Add following new via
#####                     mdtap_srm
#####                     mstap_srm
#####                     n_fptap_srm
#####                     p_fptap_srm
#####                   - CCR 983943
##### v2.370 04/25/2012 - CCR 1002930
#####                     1. Fix value/width pair order "poly"
#####                     2. Add in dielectric section for "ILD"
#####                   - CCR 1003104
#####                     1. Comment out "em_segment_length" command at beginning of "process" section
#####                   - Avoid printing empty em_model
##### v2.380 09/17/2012 - CCR 998294
#####                     1. Enhance M0/V0 EM rule for N20
#####                   - CCR 1018634
#####                     1. Support Power_Grid EM rule
#####                   - Support N20 V0.5
#####                   - Add following new conductor
#####                     RH_TN
#####                     M0_PO_TiN
#####                   - Add following new dielectric
#####                     under_gate_srm
#####			- Add following new via
#####                     VIA0_M0_PO_TiN
#####                     tintap
##### v2.390 10/25/2012 - CCR 1063344
#####                     1. Fix EM syntax error for mA/um
#####                   - CCR 1071241
#####                     1. Support V1.0 iRCX
##### v2.400 03/25/2013 - CCR 1115615
#####                     1. Add em_update option to support N16 iRCX
#####                   - Add em_jmax_dc_rms EM rule
#####                   - Support ARRAY EM rule for N40 iRCX above
##### v2.410 04/18/2013  Grant Liu
#####                   - Add device table support for ircx to mapp the EM model
#####                   - Add Active layer and RH_TN layer support for EM model
##### v2.420 05/22/2013 - CCR 1131198 ircx2ict must translate conductor_unit correctly
#####                     replace em_conductor_unit mA/um with em_conductor_unit mA
##### v2.430 06/22/2013 - CCR 1143863 ircxtoict to support Ipeak criteria for the update EM rule
#####                     Rhim
#####                     em_jmax_ac_peak EQU 2*w apply r = 1  (COMMENT: Because of high r resistor device)
#####                     check pattern "Td shorter than <value>", as in the comment in PEAK 
#####                     # Ipeak := Ipeak_DC / sqrt( r ) when Td shorter than 0.5
#####                     then translate CONDITION
#####                     CONDITION := w >= 0.1 AND Td >= 0.5
#####                     -->
#####                     em_jmax_ac_peak EQU 58.10 * (w-0.02) w >= 0.1 Td >= 0.5 apply r = 1 
#####                     (COMMENT: Because of Td>=0.5)
#####                     em_jmax_ac_peak EQU 12.54 * (w-0.02) w >= 0.1 Td < 0.0001	r < 0.05 apply r = 0.05 (COMMENT: Because of r<0.05)
##### v2.440 06/22/2013 - CCR 1171111 Latest ircxtoict script (v2.43) can't translate Td/r EM rule for middle-end layers correctly
#####                     
##### v2.450 10/10/2013 - CCR 1199834 Need ircxtoict to get the right sequence to Td and get the 
#####                     right criteria for pg em rule
#####                     Set pwr grid condition as global setting and filter Itolerance in advance process
#####        10/31/2013 - CCR 1207336 Missing apply r=1.0 or r=0.05 for PEAK EM rule for 
#####                     fracture via layers such as odtap,fptap,fntp
#####                     
#####                     
#########################################################################

BEGIN {
  use Getopt::Long;
  Getopt::Long::Configure("no_ignore_case", "gnu_compat");
  #use List::Util qw[min max];
  use strict;
  #  use Math::Round;

  # The following is highly recommended.  However, customers may have
  # lower perl version number installed.
  #
  # require 5.6.0;

  # The following will allow you to reference the location of the perl
  # script.  An example "require" is provided to pull in a libscript.pm
  # located one level up and over in a libs directory from this script
  #
  use FindBin qw($Bin);
  use FindBin qw($Script);
  # require $Bin/../libs/libscript.pm
}

# Global options hash.  The template uses this hash to store the command
# line parameters
my %options = (); 

# Global Revision variable.  Don't change this by hand, CVS will update it.
#my $Revision = '$Revision: 1.1 $';
my $Revision = 2.450;

MAIN:
$| = 1;  # Don't buffer standard output.
$Revision =~ s/.*: (.*?) \$/$1/;  # Only keep the revision number

# @params captures any non-flag command line arguments
my @params = getOptions();

$ircx_file = shift (@params);
$script_version = $Revision ;
$ext_release_version = $Revision ;

print "\nircxtoict Release  : $ext_release_version \n";
print "\nIRCX to ICT Conversion, Control ID : $script_version \n";
print "---------------------------------------\n";

printf "INFO: IRCX file specified as \"%s\"\n", $ircx_file;
# rest of main program goes here

open (IRCX,"$ircx_file") or die "Cannot open $ircx_file for read" ;

if($ict_file) {
  open (ICT,">$ict_file") or die "Cannot open $ict_file for write" ;
  printf "INFO: ICT file specified as \"%s\"\n", $ict_file;
} else {
  $ict_file = join ".", $ircx_file, "ict";
  open (ICT,">$ircx_file.ict") or die "Cannot open $ircx_file.ict for write" ;
}



while (<IRCX>) {
  push (@list_ircx, $_);
}

$ircx_file_length =scalar(@list_ircx);

%stack_hash =();
@array_stack = ();
$k = 0 ;
$c = 0;
$d = 0;
$v = 0;
$line_s = 0 ;
$line_c = 0 ;
$line_d = 0 ;
$line_v = 0 ;
$stack_row = -1;
$cond_row = -1;
$diel_row = -1;
$via_row = -1;
$scale_factor_count = 0 ;
$alrdl_present = 0 ; 
$N20_flag = '';
$ILD_flag = 0;
$La_flag = 0;
%em_value_flag;
%em_equivalent_layer;
$em_vcwidth_ict;
$em_poly_flag = 0;
#$em_parent_write_flag = 0 ;
$enable_device_table = 1;

for ($i=0;$i<=$ircx_file_length;$i++) {

### reading DEVICE table 2013/04/17 by Grant
if ($enable_device_table) {
$my_debug = 0;
 if (@list_ircx[$i] =~/DEVICE_TABLE/) {
    @device_table_head = split /\s+/,@list_ircx[$i];
    $dev_mapping_num = $device_table_head[2];
    for ($init = 0 ; $init < $dev_mapping_num ; $init++, $i++) {
      @dev_mapping_split = split /\s+/, @list_ircx[$i+3];
      $dev_mapping_array[$dev_mapping_split[1]] = $dev_mapping_split[0];
      if ($dev_mapping_split[1] =~ /poly/) { ####n_fpoly, p_fpoly are included in such group
          $dev_mapping_arrays{poly} = $dev_mapping_split[0];
          ##print " POLY $dev_mapping_split[1] : $dev_mapping_arrays{poly} \n"
      }
      if ($dev_mapping_split[1] =~ /OD/) { ####NOD, POD are included in this group
           $dev_mapping_arrays{od} = $dev_mapping_split[0];
          ##print "OD $dev_mapping_split[1] : $dev_mapping_arrays{od}\n";
      }
      if ($dev_mapping_split[1] =~ /rh_tn/) { 
           $dev_mapping_arrays{rh_tn} = $dev_mapping_split[0];
      }


      ##print "$dev_mapping_split[1] ==>  $dev_mapping_array[$dev_mapping_split[1]] == $dev_mapping_split[0]\n";
    }
 }

 ##add by echo for CCR1199834
 if (@list_ircx[$i] =~/POWER_RAIL_MIN_WIRE_WIDTH/) {
    @power_rail_min_head = split /=/,@list_ircx[$i];
    $power_rail_min = $power_rail_min_head[1];
   }
 if (@list_ircx[$i] =~/POWER_RAIL_MAX_WIRE_WIDTH/) {
    @power_rail_max_head = split /=/,@list_ircx[$i];
    $power_rail_max = $power_rail_max_head[1];
   }
 if (@list_ircx[$i] =~/POWER_RAIL_MAX_PITCH/) {
    @power_rail_pitch_head = split /=/,@list_ircx[$i];
    $power_rail_pitch = $power_rail_pitch_head[1];
   }
 if (@list_ircx[$i] =~/^DRM/) {
    @process_node_head = split  /\s+/,@list_ircx[$i];
    if ( $process_node_head[0] =~ /T/) {
     $process_node = $process_node_head[0];
     $process_version = $process_node_head[1];
      }
     elsif ($process_node_head[1] =~ /T/) {
     $process_node = $process_node_head[1];
     $process_version = $process_node_head[2];
      }
     else { $process_node = $process_node_head[2];
            $process_version = $process_node_head[3];
     }
        
    ($foundary, $process_node_number, $prce, $doc, $num) = split( "-", $process_node);
    $process_ver_number = substr( $process_version, 1 );
    $process_ver_number =~ s/_//; 
} 
 ##add end by echo for CCR1199834

 if (@list_ircx[$i] =~/COPY_EM_RULE/) {
    @em_table_head = split /\s+/,@list_ircx[$i];
    $em_table_num = $em_table_head[2];
    for ($init = 0; $init < $em_table_num ; $init++, $i++) {
      @em_table_split = split /\s+/, @list_ircx[$i+3];
     if (!(exists $em_table_array{$em_table_split[1]}) ) {
       $em_table_array{$em_table_split[1]} = $em_table_split[0];
     }
      #print "$em_table_split[1] ==> $em_table_array{$em_table_split[1]} \n";
     if ($my_debug) {
      if ($dev_mapping_arrays{poly} eq $em_table_split[1]) {
       print "Matched POLY EM model : $em_table_array{$em_table_split[1]} == $em_table_array{$dev_mapping_arrays{poly}}\n";
      }
      if ($dev_mapping_arrays{od} eq $em_table_split[1]) {
       print "Matched OD EM model : $em_table_array{$em_table_split[1]} ==  $em_table_array{$dev_mapping_arrays{od}}\n";
      }
      if ($dev_mapping_arrays{rh_tn} eq $em_table_split[1]) {
       print "Matched RH_TN EM model : $em_table_array{$em_table_split[1]} == $em_table_array{$dev_mapping_arrays{rh_tn}}\n";
      }
     print "$em_table_array{$dev_mapping_arrays{poly}}  $em_table_array{$dev_mapping_arrays{od}}  $em_table_array{$dev_mapping_arrays{rh_tn}}\n";
     }
    }
##print "$em_table_array[$dev_mapping_arrays{poly}]  $em_table_array[$dev_mapping_arrays{od}]  $em_table_array[$dev_mapping_arrays{rh_tn}]\n";
 }

##print "Index POLY : $em_table_array[$dev_mapping_arrays{poly}]\n";
##print "Index OD : $em_table_array[$dev_mapping_arrays{od}]\n";
}
 #######################################################

  if (@list_ircx[$i] =~/\s*TECH\s*:=/) {

    @process_name_info = split /\s+/,@list_ircx[$i]  ;
    $process_name = @process_name_info[-1] ;
    $process_name =~ s/RC_IRCX_//i ,$process_name ;
    $process_name = lc($process_name);


  }

  if (@list_ircx[$i] =~/\s*IRCX_VERSION\s*:=/) {
    @ircx_version_info = split /\s+/,@list_ircx[$i]  ;
    $ircx_file_version = @ircx_version_info[-1] ;
  }

  if (@list_ircx[$i] =~/\s*FILE\s*:=/) {
    @process_node_info = split /\s+/,@list_ircx[$i]  ;
    $ircx_process_node = @process_node_info[-1] ;
  }

  #if (@list_ircx[$i] =~/\s*\EM\s*Information\s*/i) {
  #$em_parent_write_flag = 1 ;
  #}

  if (@list_ircx[$i] =~/\s*SCALE\s*FACTOR/i && $scale_factor_count < 1) {

    #@scale_factor_info = split /\s+/,@list_ircx[$i]  ;
    #$scale_factor = @scale_factor_info[-1] ;
    @list_ircx[$i] =~ m/([+-]?[0-9]*\.?[0-9]+)/ ;
    $scale_factor = $1 ;
    $scale_factor_count = 1 ;
    #print " The scale factor is $scale_factor \n";
  }

  if (@list_ircx[$i] =~/\s*TEMPERATURE\s+:/ && (@list_ircx[$i]=~/C/i ||@list_ircx[$i]=~/F/i) ) {

    #@ref_temp_info = split /\s+/,@list_ircx[$i]  ;
    #$ref_temp = @ref_temp_info[-3] ;

    @list_ircx[$i] =~ m/([+-]?[0-9]*\.?[0-9]+)/ ;
    $ref_temp = $1 ;
  }

  if (@list_ircx[$i] =~/\*\s+STACK\s+/) {


    $stack_line = @list_ircx[$i] ;
    $stack_line =~s/\(// ;
    $stack_line =~s/\)// ;
    $stack_line =~s/:V//g ;
    $stack_line =~s/\,//g ;
    @stack_info =split /\s+/, $stack_line ;
    #ex @stack_info = qw (* STACK 63 4 NAME MEASURED_FROM HEIGHT THICKNESS)

    $stack_row = @stack_info[2] ;
    $stack_column = @stack_info[3] ;
    $line_s = $i ;


  }


  if ($i > $line_s && $k <= ($stack_row-1) ) {

    if ( @list_ircx[$i] =~/\s+\d+\.\d+\s/) {

      @layer_info =();
      @layer_info =split /\s+/, @list_ircx[$i]  ;

      unshift @array_stack, $layer_info[0] ;
      if ($layer_info[0] =~ /LINER/i){
        $ILD_flag = 1;
      }
      #ex @array_stack = qw (FOX OD GOX STEP ILD gpoly fpoly SPACER LINER metal1 ... metal11 PASS3a PASS3b PASS4)

      for ($sli=1;$sli<=scalar(@layer_info);$sli++) {
        #add 4 is for iRCX to locat "NAME , MEASURED_FROM , HEIGHT, THICKNESS " 
        #print "1.@layer_info[0]\n $stack_info[$sli+4] \n @layer_info[$sli]\n";
        $stack_hash{ @layer_info[0]}{$stack_info[$sli+4]} = @layer_info[$sli] ;
        #ex $stack_hash{PASS4}{MEASURED_RFOM} = PASS3b
        #ex $stack_hash{PASS4}{HEIGHT} = 7.925000
        #ex $stack_hash{PASS4}{THICKNESS} = 0.600000
      }
      $k=$k+1;
    }
  }



  if (@list_ircx[$i] =~/\*\s+CONDUCTOR\s+/) {
    # Line issue fixed
    $k++;


    $cond_line = @list_ircx[$i] ;
    $cond_line =~s/\(// ;
    $cond_line =~s/\)// ;
    #$cond_line =~s/:V//g ;
    #$cond_line =~s/:P//g ;
    $cond_line =~s/\,//g ;
    @cond_info =split /\s+/, $cond_line ;
    #ex @cond_info = qw (* CONDUCTOR 17 15 NAME:V TYPE:V HEIGHT:V THICKNESS:V WIDTH:V SPACE:V B_BIAS:V T_BIAS:V BIAS:V RESIST:V ABOVE_IMD:V ABOVE_IMD_DIFF:V TC1:V TC2:V INDIE_TABLE:P)

    $cond_row = @cond_info[2] ;
    $cond_column = @cond_info[3] ;
    $line_c = $i ;

  }
  if ($i > $line_c && $c <= ($cond_row-1) ) {

    if ( @list_ircx[$i] =~/\s+\d+\.\d+\s/) {

      @cond_layer_info =();
      @cond_layer_info =split /\s+/, @list_ircx[$i]  ;
      #ex @cond_layer_info = qw (metal11 C 6.075000 1.450000 1.80000 1.80000 0.4000 -0.6000 -0.1000 0.0210 PASS2 0.0000 3.89000e-03 -1.50000e-07 INDIE_TABLE[metal11])


      for ($cli=1;$cli<=scalar(@cond_layer_info);$cli++) {

        @cond_val_point =() ;
        @cond_val_point =split /:/,$cond_info[$cli+4]  ;
        #ex $cond_val_point[-1] = V, $cond_val_point[-2] = TYPE
        #ex $cond_val_point[-1] = P, $cond_val_point[-2] = INDIE_TABLE

        if (@cond_val_point[-1] =~/V/){
          $stack_hash{ @cond_layer_info[0]}{$cond_val_point[-2]} = @cond_layer_info[$cli] ;
          #ex $stack_hash{metal11}{TYPE} = C
          #ex $stack_hash{metal11}{HEIGHT} = 6.075000
          #ex $stack_hash{metal11}{THICKNESS} = 1.450000
          #ex $stack_hash{metal11}{WIDTH} = 1.800000
        }
        if (@cond_val_point[-1] =~/P/){
          $stack_hash{ @cond_layer_info[0]}{$cond_val_point[-2]} = @cond_layer_info[$cli] ;
          #ex $stack_hash{metal11}{INDIE_TABLE} = INDIE_TABLE[metal11]
          if (@cond_layer_info[$cli] =~/N\/A/) {
          } else { 
            conductor_manuf(@cond_layer_info[$cli],\@list_ircx) ;
            #ex conductor_manuf(INDIE_TABLE[metal11],\@list_ircx)
          }
        }
      }

      $c=$c+1;
    }
  }

  if (@list_ircx[$i] =~/\*\s+DIELECTRIC\s+/) {

    $diel_line = @list_ircx[$i] ;
    $diel_line =~s/\(// ;
    $diel_line =~s/\)// ;
    $diel_line =~s/\,//g ;
    @diel_info =split /\s+/, $diel_line ;
    #ex @diel_info = qw (* DIELECTRIC 50 11 NAME:V TYPE:V HEIGHT:V THICKNESS:V CONSTANT:V LAYER:V SIDE_THICKNESS:V TOP_THICKNESS:V BOTTOM_THICKNESS:V DAMAGE_K:V LOADING_EFFECT_TABLE:P)

    $diel_row = @diel_info[2] ;
    $diel_column = @diel_info[3] ;
    $line_d = $i ;

  }

  if ($i > $line_d && $d <= ($diel_row-1) ) {

    if ( @list_ircx[$i] =~/\s+\d+\.\d+\s/) {

      @diel_layer_info =();
      @diel_layer_info =split /\s+/, @list_ircx[$i]  ;
      #ex @diel_layer_info = qw (IMD8a D 2.202500 0.057500 2.55 N/A 0.0100 N/A 0.0100 3.10 LOADING_EFFECT_TABLE[IMD8a_THK])

      for ($dli=1;$dli<=scalar(@diel_layer_info);$dli++) {

        @diel_val_point = () ;
        @diel_val_point = split /:/,$diel_info[$dli+4] ;
        #ex $diel_val_point[-1] = V, $diel_val_point[-2] = TYPE
        #ex $diel_val_point[-1] = P, $diel_val_point[-2] = LOADING_EFFECT_TABLE

        if (@diel_val_point[-1] =~/V/){
          $stack_hash{ @diel_layer_info[0]}{$diel_val_point[-2]} = @diel_layer_info[$dli] ;
          #ex $stack_hash{IMD8a}{TYPE} = D
          #ex $stack_hash{IMD8a}{HEIGHT} = 2.202500
          #ex $stack_hash{IMD8a}{THICKNESS} = 0.057500
        }
        if (@diel_val_point[-1] =~/P/){
          if (@diel_layer_info[$dli] =~/N\/A/) {
          } else { 
            conductor_manuf(@diel_layer_info[$dli],\@list_ircx) ;
            #ex conductor_manuf(LOADING_EFFECT_TABLE[IMD8a_THK],\@list_ircx)
          }
        }


      }

      $d=$d+1;
    }
  }

  if (@list_ircx[$i] =~/\*\s+VIA\s+/) {

    $via_line = @list_ircx[$i] ;
    $via_line =~s/\(// ;
    $via_line =~s/\)// ;
    #$via_line =~s/:V//g ;
    #$via_line =~s/:P//g ;
    $via_line =~s/\,//g ;
    @via_info =split /\s+/, $via_line ;
    #ex @via_info = qw (* VIA 17 13 NAME:V RESIST:V WIDTH:V LENGTH:V LOWER:V UPPER:V VARIATION:V TC1:V TC2:V SPACE:V EFFECTIVE_WIDTH:V EFFECTIVE_LENGTH:V CONTACT_TABLE:P)

    $via_row = @via_info[2] ;
    $via_column = @via_info[3] ;
    $line_v = $i ;


  }

  if ($i > $line_v && $v <= ($via_row-1) ) {

    if ( @list_ircx[$i] =~/\s+\d+\.\d+\s+/) {
      @via_layer_info =();
      @via_layer_info =split /\s+/, @list_ircx[$i]  ;
      #ex @via_layer_info = qw (odCont 76.0000 0.05400 0.05400 OD metal1 +30.4/-30.4 1.12800e-03 -3.87000e-07 0.07200 N/A N/A	CONTACT_TABLE[odCont])
      #ex @via_layer_info = qw (via10 0.0460 2.70000 2.70000 metal10 metal11 +0.032/-0.032 3.37000e-03 -7.91000e-08 1.80000 N/A N/A N/A)
      $via_name_check_true = 0 ; 

      #print "The via layer info before foreach is  $via_layer_info[0] \n" ; 
      foreach $via_name_check (@array_stack_via) {

        if ($via_name_check eq  $via_layer_info[0] ) {

          if ( $via_layer_info[0] =~ /dup/) {
            $tempvia_layer_info =  $via_layer_info[0] ; 
            @via_dup_info = split /dup/, $tempvia_layer_info  ;
            $via_dup_number =  @via_dup_info[-1] + 1 ;
            #print "The via dup number is  $via_dup_number \n" ; 
            $via_layer_info[0] =  @via_dup_info[0]."dup".$via_dup_number ;
            $via_name_check_true = 1  ;
            #print "The via layer info after foreach is  $via_layer_info[0] \n" ;
          } else {
            $via_layer_info[0] = $via_layer_info[0]."_dup0" ;
            $via_name_check_true = 1  ;
            #print "The via layer info after foreach is  $via_layer_info[0] \n" ;
          }

          #print "The via layer info is  $via_layer_info[0] and $via_name_check  \n" ; 
          #    $via_layer_info[0]  =    $via_layer_info[0] ;
          #       $count_via_name_check =  $count_via_name_check + 1 ; 
          # print "The via layer info afte foreach is  $via_layer_info[0] and count name check is $count_via_name_check  \n\n" ;  
        }
      }

      push @array_stack_via,  $via_layer_info[0]  ;

      if ($via_name_check_true == 1 ) {
        push @array_stack_duplicate_via,  $via_layer_info[0]  ;
      }

      for ($vli=1;$vli<=scalar(@via_layer_info);$vli++) {

        @via_val_point = () ;
        @via_val_point = split /:/,$via_info[$vli+4] ;
        #ex $via_val_point[-1] = V, $via_val_point[-2] = RESIST
        #ex $via_val_point[-1] = P, $via_val_point[-2] = CONTACT_TABLE

        if (@via_val_point[-1] =~/V/){
          #  foreach $check_via_duplicates (keys(%{$stack_hash{ @via_layer_info[0]}})){

          #@viadupicateskeys =  (keys(%{$stack_hash{ @via_layer_info[0]}})) ; 
          #print " The keys for  $via_layer_info[0] via duplicates are @viadupicateskeys  \n" ;
          #   if ($check_via_duplicates eq $via_val_point[-2]  ) {

          #    if ( $via_val_point[-2] =~ /dup/) {
          # $tempvia_val_point =  $via_val_point[-2] ; 
          #      @via_dup_info = split /dup/, $tempvia_val_point ;
          # $via_dup_number =  @via_dup_info[-1] + 1 ;
          #print "The via dup number is  $via_dup_number \n" ; 
          #     $via_val_point[-2] =  @via_dup_info[0]."dup".$via_dup_number ;
          #
          #   } else {
          #     $via_val_point[-2] = $via_val_point[-2]."_dup0" ;
          #}

          #   }
          #}
          $stack_hash{ @via_layer_info[0]}{$via_val_point[-2]} = @via_layer_info[$vli] ;
          #ex $stack_hash{via10}{RESIST} = 0.0460

        }
        if (@via_val_point[-1] =~/P/){
          if (@via_layer_info[$vli] =~/N\/A/) {
          } else { 
            conductor_manuf(@via_layer_info[$vli],\@list_ircx) ;
            #ex conductor_manuf(CONTACT_TABLE[odCont],\@list_ircx)
            #print " the via pointer is @via_layer_info[$vli] \n" ;
          }
        }


      }

      $v=$v+1;
    }
  }
}

$damage_metal_number_prev = 0 ;
%damage_k_hash = ();

for (my $i=0;$i<=(scalar(@array_stack)-1);$i++) {

  if ($stack_hash{@array_stack[$i]}{TYPE}=~/D/){

    if ($stack_hash{@array_stack[$i]}{DAMAGE_K} !~/N\/A/) {

      $damage_metal_number = @array_stack[$i] ;
      #ex $damage_metal_number = IMD1b
      $damage_metal_number =~ s/\D+//g ;
      #ex $damage_metal_number = 1
      $damage_metal = "DAM_metal".$damage_metal_number ;


      if ($damage_metal_number != $damage_metal_number_prev) {

        $damage_metal_number_prev = $damage_metal_number ; 

        $stack_hash{$damage_metal}{TYPE} = "D" ;

        $stack_hash{$damage_metal}{HEIGHT} = $stack_hash{@array_stack[$i]}{HEIGHT} ;
        $stack_hash{$damage_metal}{THICKNESS} = "0" ;
        $stack_hash{$damage_metal}{CONSTANT} = $stack_hash{@array_stack[$i]}{DAMAGE_K} ;
        $stack_hash{$damage_metal}{LAYER} = "N/A" ;
        $stack_hash{$damage_metal}{SIDE_THICKNESS} = $stack_hash{@array_stack[$i]}{SIDE_THICKNESS} ;
        $stack_hash{$damage_metal}{TOP_THICKNESS} = $stack_hash{@array_stack[$i]}{TOP_THICKNESS} ;
        $stack_hash{$damage_metal}{BOTTOM_THICKNESS} = $stack_hash{@array_stack[$i]}{BOTTOM_THICKNESS} ;
        $stack_hash{$damage_metal}{DAMAGE_K} = "N/A" ;
        $stack_hash{$damage_metal}{LOADING_EFFECT_TABLE} = "N/A" ;
        $damage_k_hash{$damage_metal} = @array_stack[$i] ;

      } else {

        $stack_hash{$damage_metal}{HEIGHT} = $stack_hash{@array_stack[$i]}{HEIGHT} ;
        $stack_hash{$damage_metal}{SIDE_THICKNESS} = $stack_hash{@array_stack[$i]}{SIDE_THICKNESS} ;
        $damage_k_hash{$damage_metal} = @array_stack[$i] ;

      }

    }
  }
}


for (my $i=0;$i<=(scalar(@array_stack)-1);$i++) {

  if ($stack_hash{@array_stack[$i]}{TYPE}=~/C/ && $array_stack[$i] !~ /metal0/ && $array_stack[$i] !~ /srm/){

    if ($stack_hash{@array_stack[$i]}{ABOVE_IMD_DIFF}!= 0 && $stack_hash{@array_stack[$i]}{ABOVE_IMD_DIFF} !~/N\/A/i) {
      $above_imd = $stack_hash{@array_stack[$i]}{ABOVE_IMD} ;

      $stack_hash{$above_imd}{THICKNESS} = $stack_hash{$above_imd}{THICKNESS}+$stack_hash{@array_stack[$i]}{ABOVE_IMD_DIFF} ;

    } 
  }
}

$em_temp_ref = 0 ;
@em_parent_variable_array = () ;
@em_effect_hash_array = () ;
for ($i=0;$i<=$ircx_file_length;$i++) {

  if (@list_ircx[$i] =~/\[EM Information\]/) {
    $em_start_line = $i ;
    #print " The em start line is $em_start_line \n";
  }

}

$obc = 0 ;
$cbc = 0 ;
%em_hash = () ;
for ($i= $em_start_line+1;$i<=$ircx_file_length;$i++) {
  if ($list_ircx[$i] =~ /#\s+([mv]\S+)\s+:=\s+(\S+)/){
    $em_equivalent_layer{$1} = $2;
  }
  if ($list_ircx[$i] =~ /([mv]\S+)\s+(\S+)\s+(ALL)/){
    $em_equivalent_layer{$2} = $1;
  }
  if (@list_ircx[$i] =~ /\{/ ) {
    $obc = $obc + 1 ;
    if ($obc == 1) {

      $em_effect_start_line = $i ;
      @list_ircx[$i] =~ m/(\w+)/ ;
      $em_effect =  $1 ; 
      #print " The em effect $em_effect starts at line $em_effect_start_line\n";
      push @em_effect_hash_array , $em_effect ;
      $em_hash{$em_effect}{start_line} = $em_effect_start_line ;
    }

  }

  if (@list_ircx[$i] =~ /\}/ ) {
    $cbc = $cbc + 1 ;  
  }

  if (($cbc == $obc)&& $cbc !=0 && $obc != 0) {
    $em_effect_end_line = $i ;
    #print " The em effect $em_effect ends at line $em_effect_end_line \n";
    $em_hash{$em_effect}{end_line} = $em_effect_end_line ;
    $obc = 0 ;
    $cbc = 0 ;
  }
}

$obc = 0 ;
$cbc = 0 ;
foreach $em_effect (keys(%em_hash)) {

  #print " The foreach em effects is $em_effect \n" ;

  for ($i=$em_hash{$em_effect}{start_line}+1;$i<=$em_hash{$em_effect}{end_line}-1;$i++){

    if ( $em_effect eq qw(PEAK) ) {
        if ( @list_ircx[$i] =~ m/# Ipeak :=.*\s+Td shorter than\s+(\S+)/ ) {
            $em_hash{$em_effect}{PARAMS}{Ipeak_Td_threshold} = 1.0 * $1;
            $em_hash{$em_effect}{PARAMS}{HI_RESISTANCE}{rhim} = "apply r = 1.0";
        }
    }

    if (@list_ircx[$i] =~ /\{/ ) {
      $obc = $obc + 1 ;
      if ($obc == 1) {

        $em_effect_start_line = $i ;
        @list_ircx[$i] =~ m/(\w+)/ ;
        $em_effect_metal =  $1 ; 
        #print " The em effect metal for $em_effect  is $em_effect_metal \n";
        $em_hash{$em_effect}{$em_effect_metal}{start_line} = $em_effect_start_line ;
        if ($em_effect_metal eq 'poly'){
          $em_poly_flag = 1;
        }
      }

    }

    if (@list_ircx[$i] =~ /\}/ ) {
      $cbc = $cbc + 1 ;  
    }

    if (($cbc == $obc)&& $cbc !=0 && $obc != 0) {
      $em_effect_end_line = $i ;
      #print " The em effect end line for $em_effect_metal is $em_effect_end_line \n";
      $em_hash{$em_effect}{$em_effect_metal}{end_line} = $em_effect_end_line ;
      $obc = 0 ;
      $cbc = 0 ;
    }

  }

}




#print ICT "## converted by ircx2ict -em_update of rev $script_version ##\n";
foreach $em_effect (keys(%em_hash)) {

  foreach $em_effect_metal (keys(%{$em_hash{$em_effect}})) {

    if ($em_effect !~ /line/ || $em_effect_metal !~ /line/)  {

      $em_gate = 0 ;
      @em_line_info = () ;
      $em_line_number = 0;
      @em_first_line =();
      $em_type_prev = aaaa ;
      @em_second_line =();     

      $em_effect_metal_start_line = $em_hash{$em_effect}{$em_effect_metal}{start_line}+1 ;
      $em_effect_metal_end_line =  $em_hash{$em_effect}{$em_effect_metal}{end_line}-1 ;
      $obc = 0 ;
#In order to ignore RATING_FACTOR_VIA_VIA_SPACING
      my $rfvvs = -1;
      my $p_num = '';
      #print " The start line for \'$em_effect\' and \'$em_effect_metal\' is $em_hash{$em_effect}{$em_effect_metal}{start_line} \n" ;
      #print " The end line for \'$em_effect\' and \'$em_effect_metal\' is $em_hash{$em_effect}{$em_effect_metal}{end_line} \n" ;

      for ($i=$em_effect_metal_start_line;$i<=$em_effect_metal_end_line;$i++){
        if ($list_ircx[$i] =~ /RATING_FACTOR_VIA_VIA_SPACING/){
          $rfvvs = 0;
        }
        if ($rfvvs >= 0){
          if ($list_ircx[$i] =~ /\{/){
            $rfvvs++;
          }
          if ($list_ircx[$i] =~ /\}/){
            $rfvvs--;
            if ($rfvvs == 0){
              $rfvvs = -1;
            }
          }
        }
        if ($rfvvs > 0){
          next;
        }
        if ($list_ircx[$i] =~ /POLYNOMIAL\[(\d+)\]\s+{/){
          $p_num = $1;
        }
        #print " The value of i is $i \n";
        #print " The line for $em_effect and $em_effect_metal  is @list_ircx[$i] \n";
        if (@list_ircx[$i] =~/\*\s*\w*\s*/ && @list_ircx[$i]=~/:V/ ) {

          $em_gate = 1 ;
          $em_line = @list_ircx[$i] ;
          $em_line_number = $i ;
          @em_line_info =split /\s+/, $em_line ;
          $em_type = @em_line_info[1] ;
          $em_type =$em_type.$p_num ;
          $em_row = @em_line_info[2] ;
          $em_column = @em_line_info[3] ;

        }

        if ($i ==  $em_line_number+1 && $em_gate == 1 ) {
          @em_first_line = split /\s+/, @list_ircx[$i] ;
          #print " For $em_type the array is @em_first_line \n";
          $em_hash{$em_effect}{$em_effect_metal}{$em_type}{first_line} = [@em_first_line] ;
        }

        @em_effect_line =();

        if ($i <=  $em_line_number+$em_row+2 && $em_gate == 1 && $i >  $em_line_number+2 ) {
          @em_effect_line = split /\s+/, @list_ircx[$i] ;

          if ($em_type_prev eq $em_type){
            push @em_second_line,@em_effect_line[0] ; 
          } else {
            $em_type_prev = $em_type ; 
            @em_second_line =();
            push @em_second_line,@em_effect_line[0] ; 

          }
          #print " The em effect line 0 is @em_effect_line[0] \n";

          for ($mel =1;$mel<=scalar(@em_effect_line)-1;$mel++){
            $em_hash{$em_effect}{$em_effect_metal}{$em_type}{@em_effect_line[0]}{@em_first_line[$mel]} = @em_effect_line[$mel] ;

          }
          $em_hash{$em_effect}{$em_effect_metal}{$em_type}{second_line} = [@em_second_line] ;
        }

        if (@list_ircx[$i] =~ /\{/ ) {
          $obc = $obc + 1 ;

        }


        if (@list_ircx[$i] =~ /\:=/) {

          @equation_line = split /\:=/, @list_ircx[$i] ;
          $em_type = @equation_line[0] ;
          $em_type =~ s/\s+// ;
          $em_type_value = @equation_line[1] ;
          $em_type_value  =~ s/\n+// ;
          $em_type_value  =~ s/\s*// ;
          $em_type =$em_type.$p_num ;
          $em_hash{$em_effect}{$em_effect_metal}{$em_type} = $em_type_value ;
          #support ARRAY syntax for N40 process above
          if ($em_type =~ /CONDITION/ && $em_type_value !~ /Wv|Lv/i && $em_type_value =~ /ARRAY/i){
            $em_hash{$em_effect}{$em_effect_metal}{ARRAY} = 1;
          }

        }
      }

    }



  }
}


foreach $em_effect (keys(%em_hash)) {

  foreach $em_effect_metal (keys(%{$em_hash{$em_effect}})) {

    if (exists $em_hash{$em_effect}{$em_effect_metal}{RATING_FACTOR}) {

      @rating_first_array =  @{$em_hash{$em_effect}{$em_effect_metal}{RATING_FACTOR}{first_line}} ;
      @rating_second_array =  @{$em_hash{$em_effect}{$em_effect_metal}{RATING_FACTOR}{second_line}} ;


      for ($esa=0;$esa<=scalar(@rating_second_array)-1;$esa++){
        for ($efa=1;$efa<=scalar(@rating_first_array)-1;$efa++){


          $first_pointer =  $em_hash{$em_effect}{$em_effect_metal}{RATING_FACTOR}{first_line}[$efa];
          $second_pointer = $em_hash{$em_effect}{$em_effect_metal}{RATING_FACTOR}{second_line}[$esa];

          #print " The first pointer is $first_pointer \n";
          if ( $em_hash{$em_effect}{$em_effect_metal}{RATING_FACTOR}{$second_pointer}{$first_pointer} == 1.00 ){

            $em_temp_ref = $first_pointer ;

            #print " The em temp ref is $em_temp_ref \n";
          }
        }
      }

    }
  }
}


foreach $em_effect (keys(%em_hash)) {

  foreach $em_effect_metal (keys(%{$em_hash{$em_effect}})) {
    for ($iem=1;$iem<=  $em_hash{$em_effect}{$em_effect_metal}{NO_OF_POLYNOMIAL_TABLE};$iem++){
      $variable_word = "VARIABLE".$iem ;

      $em_variable = $em_hash{$em_effect}{$em_effect_metal}{$variable_word} ;
      $em_variable =~ s/\n+// ;
      $em_variable =~ s/\s+// ;

      @em_variable_array = split /\,/ ,$em_variable ;

      #print " The em variable array is @em_variable_array \n";

      foreach $array_element (@em_variable_array){
        $element_presence_flag = 0; 

        foreach $pa_array_element (@em_parent_variable_array) {


          if ($array_element eq  $pa_array_element){
            $element_presence_flag = 1; 
          }
        }


        if ($element_presence_flag == 0) {
          push @em_parent_variable_array,$array_element ; 
          $em_value_flag{$array_element} = 1;
        }
      }




    }
  }
}






#push  (@em_effect_hash_array , PEAK) ;
#push  (@em_effect_hash_array , RMS) ;

#$array = scalar keys(%stack_hash) ;
#@array =  keys(%em_hash) ;
#print " The stack hash array is $array \n" ;
#print " The array data is @array \n" ;
#@value2 = @{$em_hash{DC}{metal7}{RATING_FACTOR}{second_line}} ;

#$value1 = $manuf_table{"INDIE_TABLE[metal2]"}{"ADI_BIAS"}{"0.04000"}{"0.04000"} ;
#print " The ADI_BIAS values is $value1 \n";
#@value2 = keys(%{$manuf_table{"INDIE_TABLE[metal2]"}}) ;
#print " The metal2 keys are @value2 \n" ;
#@value5 = keys(%imd_diff_hash) ; 
#@value6 = keys(%{$em_hash{DC}{metal7}{RATING_FACTOR}}) ;
#$value7 = $em_hash{DC}{metal7}{end_line} ;
#@value7 = keys(%{$manuf_table{"CONTACT_TABLE[odCont]"}}) ;
#@value7 = keys(%{$manuf_table{"tsv_circuit[tsv]"}}) ;
#print " The metal4 TC2 is $value1 \n" ;
#print " The value2 is @value2 \n" ;
#print " The first element first line is $value3  \n" ;
#print " The second element first line is $value4  \n" ;
#print " The stack array is @array_stack \n" ;
#print " The keys of manuf table is @value5 \n" ;
#print " The value 6 is  @value6 \n" ;
#print " The value 7 is  @value7 \n" ; 

#$stack_length =  scalar(@array_stack) ;
#$stack_via_length =  scalar(@array_stack_via) ;
#print " The stack array via is @array_stack_via  \n";
#print " The stack array duplicate via is @array_stack_duplicate_via  \n";

#@resist_array = () ;
@array_stack_duplicate_via = sort @array_stack_duplicate_via;
foreach $duplicate_via (@array_stack_duplicate_via) {
  @original_via_array = split /_dup/, $duplicate_via ;
  $original_via = @original_via_array[0] ; 
  $via_duplicate_number =  @original_via_array[-1] ;

  if ($original_via ne $previous_via) {
    @resist_array = $stack_hash{$original_via}{RESIST}  ;
    @width_array = $stack_hash{$original_via}{WIDTH}  ;
    @length_array = $stack_hash{$original_via}{LENGTH}  ;
    @variation_array = $stack_hash{$original_via}{VARIATION}  ;
    @temp_variation_array_value = split /\//, $stack_hash{$original_via}{VARIATION} ;
    @variation_array_cbest = @temp_variation_array_value[-1] ;
    @variation_array_cworst =  @temp_variation_array_value[-2] ;
    @tc1_array = $stack_hash{$original_via}{TC1}  ;
    @tc2_array = $stack_hash{$original_via}{TC2}  ;
    @effwidth_array = $stack_hash{$original_via}{EFFECTIVE_WIDTH}  ;
    @efflength_array = $stack_hash{$original_via}{EFFECTIVE_LENGTH}  ;
    @space_array = $stack_hash{$original_via}{SPACE}  ;


  }
  $previous_via = $original_via ;

  #print " the duplicate via number is $via_duplicate_number \n" ; 
  #print " the original via is $original_via \n" ; 


  foreach $original_via_values (keys(%{$stack_hash{$original_via}})) {

    # if (  $original_via_values !~ /dup/ ){
    # if ($stack_hash{$original_via}{$original_via_values} != $stack_hash{$duplicate_via}{$original_via_values}) {

    #$original_via_values_duplicate = $original_via_values."_dup".$via_duplicate_number ; 



    if ( $original_via_values eq RESIST ) { 

      $original_via_values_array = $original_via_values."_ARRAY" ;

      push @resist_array,$stack_hash{$duplicate_via}{$original_via_values} ; 
      $stack_hash{$original_via}{$original_via_values_array} =[@resist_array] ; 

      #print " The  resist dup array for $original_via is @{$stack_hash{$original_via}{$original_via_values_array}} \n" ;

    }

    if ( $original_via_values eq WIDTH ) { 

      $original_via_values_array = $original_via_values."_ARRAY" ;
      push @width_array,$stack_hash{$duplicate_via}{$original_via_values} ; 
      $stack_hash{$original_via}{$original_via_values_array} =[@width_array] ; 
      #print " The  width dup array for $original_via is @{$stack_hash{$original_via}{$original_via_values_array}} \n" ;

    }
    if ( $original_via_values eq LENGTH ) { 

      $original_via_values_array = $original_via_values."_ARRAY" ;
      push @length_array,$stack_hash{$duplicate_via}{$original_via_values} ; 
      $stack_hash{$original_via}{$original_via_values_array} =[@length_array] ; 
      #print " The  length dup array for $original_via is @{$stack_hash{$original_via}{$original_via_values_array}} \n" ;

    }

    if ( $original_via_values eq EFFECTIVE_LENGTH ) { 

      $original_via_values_array = $original_via_values."_ARRAY" ;
      push @efflength_array,$stack_hash{$duplicate_via}{$original_via_values} ; 
      $stack_hash{$original_via}{$original_via_values_array} =[@efflength_array] ; 
      #print " The  effective length dup array for $original_via is @{$stack_hash{$original_via}{$original_via_values_array}} \n" ;

    }
    if ( $original_via_values eq EFFECTIVE_WIDTH ) { 

      $original_via_values_array = $original_via_values."_ARRAY" ;
      push @effwidth_array,$stack_hash{$duplicate_via}{$original_via_values} ; 
      $stack_hash{$original_via}{$original_via_values_array} =[@effwidth_array] ; 
      #print " The effective width dup array for $original_via is @{$stack_hash{$original_via}{$original_via_values_array}} \n" ;

    }

    if ( $original_via_values eq VARIATION ) { 

      $original_via_values_array = $original_via_values."_ARRAY" ;
      $original_via_values_array_cbest = $original_via_values."_ARRAY_CBEST" ;
      $original_via_values_array_cworst = $original_via_values."_ARRAY_CWORST" ;

      push @variation_array,$stack_hash{$duplicate_via}{$original_via_values} ; 
      $stack_hash{$original_via}{$original_via_values_array} =[@variation_array] ; 
      #print " The variation dup array for $original_via is @{$stack_hash{$original_via}{$original_via_values_array}} \n" ;

      @temp_variation_array_value = split /\//,$stack_hash{$duplicate_via}{$original_via_values} ; 

      push @variation_array_cbest,@temp_variation_array_value[-1] ; 
      $stack_hash{$original_via}{$original_via_values_array_cbest} =[@variation_array_cbest] ; 
      #print " The variation cbest dup array for $original_via is @{$stack_hash{$original_via}{$original_via_values_array_cbest}} \n" ;

      push @variation_array_cworst,@temp_variation_array_value[-2] ; 
      $stack_hash{$original_via}{$original_via_values_array_cworst} =[@variation_array_cworst] ; 
      #print " The variation cworst dup array for $original_via is @{$stack_hash{$original_via}{$original_via_values_array_cworst}} \n" ;

    }

    if ( $original_via_values eq TC1 ) { 

      $original_via_values_array = $original_via_values."_ARRAY" ;
      push @tc1_array,$stack_hash{$duplicate_via}{$original_via_values} ; 
      $stack_hash{$original_via}{$original_via_values_array} =[@tc1_array] ; 
      #print " The tc1 dup array for $original_via is @{$stack_hash{$original_via}{$original_via_values_array}} \n" ;

    }

    if ( $original_via_values eq TC2 ) { 

      $original_via_values_array = $original_via_values."_ARRAY" ;
      push @tc2_array,$stack_hash{$duplicate_via}{$original_via_values} ; 
      $stack_hash{$original_via}{$original_via_values_array} =[@tc2_array] ; 
      #print " The tc2 dup array for $original_via is @{$stack_hash{$original_via}{$original_via_values_array}} \n" ;

    }

    if ( $original_via_values eq SPACE ) { 

      $original_via_values_array = $original_via_values."_ARRAY" ;
      push @space_array,$stack_hash{$duplicate_via}{$original_via_values} ; 
      $stack_hash{$original_via}{$original_via_values_array} =[@space_array] ; 
      #print " The space dup array for $original_via is @{$stack_hash{$original_via}{$original_via_values_array}} \n" ;

    }



    #}
  }
}



for ($ivia=0;$ivia<=(scalar(@array_stack_via)-1);$ivia++) {
  if (@array_stack_via[$ivia] !~/Cont/i && @array_stack_via[$ivia] !~/dup/i ) {



    if (exists $stack_hash{@array_stack_via[$ivia]}{WIDTH_ARRAY} &&  exists $stack_hash{@array_stack_via[$ivia]}{LENGTH_ARRAY} ) {


      for ($iviaw=0;$iviaw<=(scalar(@{$stack_hash{@array_stack_via[$ivia]}{WIDTH_ARRAY}})-1);$iviaw++) {

        #for ($ivial=0;$ivial<=(scalar(@{$stack_hash{@array_stack_via[$ivia]}{LENGTH_ARRAY}})-1);$ivial++) {

        $area_value = $stack_hash{@array_stack_via[$ivia]}{WIDTH_ARRAY}[$iviaw]*$stack_hash{@array_stack_via[$ivia]}{LENGTH_ARRAY}[$iviaw] ;

        #print " The area value is $area_value \n"; 

        #$stack_hash{@array_stack_via[$ivia]}{AREA} = $area_value ;

        $stack_hash{@array_stack_via[$ivia]}{AREA}{$area_value}{WIDTH} = $stack_hash{@array_stack_via[$ivia]}{WIDTH_ARRAY}[$iviaw] ;
        $stack_hash{@array_stack_via[$ivia]}{AREA}{$area_value}{LENGTH} = $stack_hash{@array_stack_via[$ivia]}{LENGTH_ARRAY}[$iviaw] ; 
        $stack_hash{@array_stack_via[$ivia]}{AREA}{$area_value}{TC1} = $stack_hash{@array_stack_via[$ivia]}{TC1_ARRAY}[$iviaw] ;
        $stack_hash{@array_stack_via[$ivia]}{AREA}{$area_value}{TC2} = $stack_hash{@array_stack_via[$ivia]}{TC2_ARRAY}[$iviaw] ; 
        $stack_hash{@array_stack_via[$ivia]}{AREA}{$area_value}{RESIST} = $stack_hash{@array_stack_via[$ivia]}{RESIST_ARRAY}[$iviaw] ;
        $stack_hash{@array_stack_via[$ivia]}{AREA}{$area_value}{EFFECTIVE_WIDTH} = $stack_hash{@array_stack_via[$ivia]}{EFFECTIVE_WIDTH_ARRAY}[$iviaw] ; 
        $stack_hash{@array_stack_via[$ivia]}{AREA}{$area_value}{EFFECTIVE_LENGTH} = $stack_hash{@array_stack_via[$ivia]}{EFFECTIVE_LENGTH_ARRAY}[$iviaw] ; 
        $stack_hash{@array_stack_via[$ivia]}{AREA}{$area_value}{VARIATION_CBEST} = $stack_hash{@array_stack_via[$ivia]}{VARIATION_ARRAY_CBEST}[$iviaw] ;
        $stack_hash{@array_stack_via[$ivia]}{AREA}{$area_value}{VARIATION_CWORST} = $stack_hash{@array_stack_via[$ivia]}{VARIATION_ARRAY_CWORST}[$iviaw] ; 

        #}
      }
    }
  }
}
#}

#@value6 = keys(%{$stack_hash{via1}{AREA}{0.002025}}) ;
#$value7 = $stack_hash{via1}{AREA}{0.002025}{EFFECTIVE_WIDTH} ;

#print " The area keys value is @value6 \n" ; 
#print " The area keys value is $value7 \n" ; 


@split_ircx_name = split /_/,$ircx_process_node;
$find_process_node = @split_ircx_name[2];
$find_process_node =~ s/\D+//g ;
if ($find_process_node =~ /^0/){
  $find_process_node = $find_process_node*10;
}
if ($find_process_node == 180){
  push @em_parent_variable_array,"w" ; 
}
#@max_metal_layer =  split /P/i, @split_ircx_name[3];
#$max_metal_layer_number = @max_metal_layer[1] ;
$ircx_process_node =~ /\dP(\d+)M/;
$max_metal_layer_number = $1;
if ($ircx_process_node =~ /ALRDL/i) {
  $alrdl_present = 1 ;
}
if ($split_ircx_name[2] =~ /N20(\w+)/){
  $N20_flag = $1;
}

#print " the process node is $find_process_node \n" ;

#if ($em_parent_write_flag == 1) {
#$em_write_flag = "" ;
#}
if ($native_ict){
  open (NAT,"$native_ict") or die "Cannot open $native_ict for read" ;
  my @list_nat = <NAT>;
  my $count = -1;
  my $brack = 0;
  my $em_brack = 0;
  my $ind_layer;
  my $ind_type;
  my $top_metal = 0;
  my $via_top;
  my $via_bottom;
  foreach my $row(@list_nat){
    $count++;
    my $mark = $row;
    $mark =~ s/\#.*//;
    if ($mark =~ /{/){
      $brack++;
    }
    if ($mark =~ /}/){
      $brack--;
    }
    if ($mark =~ /^\s*(conductor|via|process)\s*"(\S+)"/){
      $ind_type = $1;
      $ind_layer = $2;
    }
    if ($mark =~ /^\s*top_layer\s+"(\S+)"/){
      $via_top = $1;
    }
    if ($mark =~ /^\s*bottom_layer\s+"(\S+)"/){
      $via_bottom = $1;
    }
    if ($mark =~ /^\s*min_width\s+(\S+)/){
      $em_vcwidth_ict = $1;
    }
    if ($brack == 0){
    ##print "Checking $ind_type  ==> $ind_layer\n";
      if ($ind_type eq 'process'){
        if (!$em_write_flag){
          print ICT "   em_tref $em_temp_ref        \n";
          print ICT "   em_output_wlt drawn \n";
          print ICT "   em_variables  @em_parent_variable_array    \n";
          print ICT "   em_conductor_unit mA\n" ;
          print ICT "   em_via_area_unit  mA \n" ;
          print ICT "   em_via_unit mA \n" ;
          if ($find_process_node == 20) {
            print ICT "   em_segment_length centerline\n";
          }elsif ($find_process_node == 28){
            print ICT "   em_segment_length perimeter\n";
          }
       }
     }elsif ($ind_type eq 'conductor'){
       if ($ind_layer =~ /^M(\d+)$/){
         $top_metal = $1;
         $ind_layer =~ s/M/metal/;
         &output_em_conductor($ind_layer);
       }elsif($ind_layer =~ /^metal(\d+)$/){
         $top_metal = $1;
         &output_em_conductor($ind_layer);
       }elsif ($ind_layer eq 'AP'){
         my $tnum = $top_metal + 1;
         $ind_layer = "metal$tnum";
         &output_em_conductor($ind_layer);
       }elsif ($ind_layer =~ /^poly/ && !($ind_layer =~ /_srm/) ){
         if ($em_poly_flag == 0){
           ##$ind_layer =~ s/poly/fpoly/;
           #$ind_layer = "rnmg";
           $ind_layer = $em_table_array{$dev_mapping_arrays{poly}};
           #print "POLY : $ind_layer\n";
         }
         &output_em_conductor($ind_layer);
#####Add for active layer by Grant 
       }elsif ($ind_layer =~ /active/){
         #$ind_layer = "rnodwo";
         $ind_layer = $em_table_array{$dev_mapping_arrays{od}}; 
         #print "Active : $ind_layer\n";
         &output_em_conductor($ind_layer);
       }elsif ($ind_layer =~ /RH_TN/){
         $ind_layer = $em_table_array{$dev_mapping_arrays{rh_tn}};
         ##$ind_layer = "rhim";
         #print "RH_TN : $ind_layer\n";
         &output_em_conductor($ind_layer);
###################
       }elsif ($ind_layer =~ /^M0/){
         my $tlayer = $ind_layer;
         $ind_layer = "metal0_po";
         if ($tlayer =~ /SRM/){
           $ind_layer = "metal0_po_srm";
           if ($tlayer =~ /M0_STI(\d*)_SRM_fox/){
             $ind_layer = "metal0_sti$1_fox_srm";
           }elsif ($tlayer =~ /M0_STI(\d*)_SRM/){
             $ind_layer = "metal0_sti$1_srm";
           }
           if ($tlayer =~ /M0_OD(\d*)_SRM/){
             $ind_layer = "metal0_od$1_srm";
           }
         }else{
           if ($tlayer =~ /M0_STI(\S*)_fox/){
             $ind_layer = "metal0_sti$1_fox";
           }elsif ($tlayer =~ /M0_STI(\S*)/){
             $ind_layer = "metal0_sti$1";
           }
           if ($tlayer =~ /M0_OD(\S*)/){
             $ind_layer = "metal0_od$1";
           }
           if ($tlayer =~ /RH_TN/){
             $ind_layer = "rh_tn";
           }
           if ($tlayer =~ /M0_PO_TiN/){
             $ind_layer = "metal0_po_tin";
           }
         }
         &output_em_conductor_m0($ind_layer) ;
       }
     }elsif ($ind_type eq 'via'){
       if ($ind_layer =~ /^VIA(\d+)$/){
         $ind_layer = lc($ind_layer);
         &output_em_via($ind_layer);
       }elsif ($ind_layer eq 'RV'){
         $ind_layer = "via$top_metal";
         &output_em_via($ind_layer);
       }elsif ($ind_layer =~ /polyCont|odCont/){
         &output_em_via($ind_layer);
       }elsif ($ind_layer =~ /^VIA0/){
         $via_bottom =~ s/M0/via0/;
         $ind_layer = lc($via_bottom);
         $ind_layer =~ s/srm_fox/fox_srm/;
         $ind_layer =~ s/via0_po_[np]/via0_po/;
         &output_em_via_m0($ind_layer);
       }elsif ($ind_layer =~ /tap/){
         $via_top =~ s/M0/metal0/;
         $ind_layer = lc($via_top);
         $ind_layer =~ s/metal0_po_[np]/metal0_po/;
         &output_em_conductor_m0_tap($ind_layer);
       }
     }
     $ind_type = '';
   }
    if ($mark =~ /em_model/){
      $em_brack = 1;
    }
    if ($mark =~ /em_/){
      next;
    }
    if ($em_brack == 1 && $mark =~ /}/){
      $em_brack = 0;
      next;
    }
    print ICT "$row";
  }
  exit;
}

print ICT "################################################## \n";
print ICT "#####  ircxtoict Release : $ext_release_version \n" ;
print ICT "#####  IRCXTOICT Control ID : $script_version \n" ;
print ICT "#####  Input IRCX File : $ircx_file \n" ;
print ICT "#####  Input IRCX File version : $ircx_file_version \n" ;
print ICT "#####  Output ICT File : $ict_file \n" ;

print ICT "#################################################### \n" ;




print ICT "process \"$process_name\" {\n" ;
print ICT "   background_dielectric_constant 1.000000 \n" ;
print ICT "   temp_reference $ref_temp \n" ;

if ($scale_factor == 1) {
} else {
  print ICT "   layout_scale $scale_factor \n" ;
}
if ($find_process_node <= 65) {
  print ICT "\#\!    use_silicon_density true \n";
}
if (!$em_write_flag){
  print ICT "   em_tref $em_temp_ref        \n";
  print ICT "   em_output_wlt drawn \n";
  print ICT "   em_variables  @em_parent_variable_array    \n";
  print ICT "   em_conductor_unit mA\n" ;
  print ICT "   em_via_area_unit  mA \n" ;
  print ICT "   em_via_unit mA \n" ;
  if ($find_process_node == 20) {
    print ICT "   em_segment_length centerline\n";
  }elsif ($find_process_node == 28){
    print ICT "   em_segment_length perimeter\n";
  }
}
print ICT "}\n" ; 


if ($find_process_node >= 40) {
  print ICT "diffusion \"N_SOURCE_DRAIN\" {\n" ;
  printf ICT "   thickness %.5f \n",$stack_hash{FOX}{THICKNESS} ;
  printf ICT "   resistivity %.4f \n",$stack_hash{NOD}{RESIST}  ;
  printf ICT "   temp_tc1 %.10f \n", $stack_hash{NOD}{TC1} ;
  printf ICT "   temp_tc2 %.20f \n", $stack_hash{NOD}{TC2}  ;
  print ICT "}\n" ; 

  print ICT "diffusion \"P_SOURCE_DRAIN\" {\n" ;
  printf ICT "   thickness %.5f \n",$stack_hash{FOX}{THICKNESS} ;
  printf ICT "   resistivity %.4f \n",$stack_hash{POD}{RESIST} ;
  printf ICT "   temp_tc1 %.10f \n", $stack_hash{POD}{TC1}  ;
  printf ICT "   temp_tc2 %.20f \n",$stack_hash{POD}{TC2}   ;
  print ICT "}\n" ;

  print ICT "diffusion \"active\" {\n" ;
  printf ICT "   thickness %.5f \n",$stack_hash{FOX}{THICKNESS} ;
  printf ICT "   resistivity %.4f \n",$stack_hash{OD}{RESIST}  ;
  printf ICT "   temp_tc1 %.10f \n",$stack_hash{OD}{TC1}  ;
  printf ICT "   temp_tc2 %.20f \n",$stack_hash{OD}{TC2}  ;
  print ICT "}\n" ;

}
$od_written_out = 0 ; 
if ($find_process_node == 20){
  my @array1;
  my @array2;
  my @array3;
  foreach (@array_stack){
    if ($_ =~ /fpoly|fpoly_srm/){
      push @array2, $_;
    }elsif($_ =~ /SPACER/){
      push @array3, $_;
    }else{
      push @array1, $_;
    }
  }
  @array_stack = ();
  @array2 = sort @array2;
  foreach (@array1){
    push @array_stack, $_;
    if ($_ eq "STEP"){
      push @array_stack, @array2;
      push @array_stack, @array3;
    }
  }
}
for ($i=0;$i<=(scalar(@array_stack)-1);$i++) {
  #print "$i stack : @array_stack[$i]\n";
  if ($find_process_node == 20 ){
    if (( @array_stack[$i] =~ /metal0_sti/) || (@array_stack[$i] =~ /FOX_A/) || (@array_stack[$i] =~ /STEP/) || (@array_stack[$i] =~ /metal0_po/) || (@array_stack[$i] =~ /metal0_od/) || (@array_stack[$i] =~ /gpoly_srm/) || (@array_stack[$i] =~ /rh_tn/) ){
      next;
    }
  }


#N28_1_01  if ($stack_hash{@array_stack[$i]}{TYPE}=~/C/  &&  @array_stack[$i]!~/OD/i &&  @array_stack[$i]!~/gpoly/i && @array_stack[$i]!~/metal_interface/i ){
  if ($stack_hash{@array_stack[$i]}{TYPE}=~/C/  &&  @array_stack[$i]!~/OD/i &&  @array_stack[$i]!~/gpoly/i ){
    if ($find_process_node < 40) {
      if ($od_written_out == 0 ) {
#N28_1_01        $OD_indie_name = "INDIE_TABLE[OD]";
        print ICT "conductor \"active\" {\n" ;
        printf ICT "   min_spacing %.4g \n",$stack_hash{OD}{SPACE} ;
        printf ICT "   min_width %.4g \n",$stack_hash{OD}{WIDTH} ;
        #printf ICT "   height %.5g \n",$stack_hash{OD}{HEIGHT} ;
        if ($find_process_node == 20 ) {
          if ($stack_hash{NOD}{THICKNESS} > $stack_hash{POD}{THICKNESS}){
            $od_thickness = $stack_hash{POD}{THICKNESS} ; 
            $od_res = $stack_hash{POD}{RESIST}
          }else{
            $od_thickness = $stack_hash{NOD}{THICKNESS} ; 
            $od_res = $stack_hash{NOD}{RESIST}
          }
          printf ICT "   height %.5f \n",$stack_hash{GOX}{HEIGHT}- $od_thickness ;
        }else{
          printf ICT "   height %.5f \n",$stack_hash{FOX}{THICKNESS}- $stack_hash{OD}{THICKNESS} ;
        }
        #printf ICT "   height %.5f \n",$stack_hash{FOX}{THICKNESS}- $stack_hash{OD}{THICKNESS}-0.001 ;
        if ($find_process_node == 20 ) {
          printf ICT "   thickness %.5f \n",$od_thickness ;
          printf ICT "   resistivity %.4g \n",$od_res  ;
        }else{
          printf ICT "   thickness %.5f \n",$stack_hash{OD}{THICKNESS} ;
          printf ICT "   resistivity %.4g \n",$stack_hash{OD}{RESIST}  ;
        }
        #printf ICT "   resistivity %.2f \n",$stack_hash{OD}{RESIST}  ;
#N28_1_01        &print_wee_info( $find_process_node , $OD_indie_name );
        $od_tc1_ict_out =  $stack_hash{OD}{TC1} ;
        if ( $stack_hash{OD}{TC1} >= $stack_hash{NOD}{TC1}) {
          $od_tc1_ict_out =  $stack_hash{OD}{TC1} ;
        } else {
          $od_tc1_ict_out =  $stack_hash{NOD}{TC1} ;
        }
        if ( $od_tc1_ict_out >=  $stack_hash{POD}{TC1}) {
        } else {
          $od_tc1_ict_out =  $stack_hash{POD}{TC1} ;
        }

        if ( $stack_hash{OD}{TC2} < 0) {
          $od_tc2_ict_out =  $stack_hash{OD}{TC2} ;
          if ( $stack_hash{OD}{TC2} <= $stack_hash{NOD}{TC2}) {
            $od_tc2_ict_out =  $stack_hash{OD}{TC2} ;
          } else {
            $od_tc2_ict_out =  $stack_hash{NOD}{TC2} ;
          }
          if ( $od_tc2_ict_out <=  $stack_hash{POD}{TC2}) {
          } else {
            $od_tc2_ict_out =  $stack_hash{POD}{TC2} ;
          }
        } else {
          $od_tc2_ict_out =  $stack_hash{OD}{TC2} ;
          if ( $stack_hash{OD}{TC2} >= $stack_hash{NOD}{TC2}) {
            $od_tc2_ict_out =  $stack_hash{OD}{TC2} ;
          } else {
            $od_tc2_ict_out =  $stack_hash{NOD}{TC2} ;
          }
          if ( $od_tc2_ict_out >=  $stack_hash{POD}{TC2}) {
          } else {
            $od_tc2_ict_out =  $stack_hash{POD}{TC2} ;
          }

        }
        printf ICT "   temp_tc1 %.10f \n",$od_tc1_ict_out  ;
        printf ICT "   temp_tc2 %.20f \n",$od_tc2_ict_out  ;
        print ICT  "   gate_forming_layer  true \n" ;
        print ICT  "   layer_type   diffusion \n" ;
        if ($find_process_node == 20 ){
          my $n20_indie_name = "INDIE_TABLE[NOD]" ;
          foreach $t_type (@{$manuf_table{$n20_indie_name}{manuf_type_arr}}){
            if ($t_type=~ /RAISED_DIFF_CORE_NMOS|RAISED_DIFF_$N20_flag\_CORE_NMOS/){
              &print_raise_diff($n20_indie_name,$t_type);
            }
            if ($t_type=~ /RAISED_DIFF/){
              my @n20_tmp = split(/\_/,$t_type);
              my $n20_tmp_name;
              if ($N20_flag ne 'G'){
                $n20_tmp_name = "$n20_tmp[-3]_$n20_tmp[-2]_$n20_tmp[-1]_active";
              }else{
                $n20_tmp_name = "$n20_tmp[-2]_$n20_tmp[-1]";
                if($n20_tmp_name =~ /IO/){
                  $n20_tmp_name = "G_1D5V".$n20_tmp_name."_active";
                }else{
                  $n20_tmp_name = "G_".$n20_tmp_name."_active";
                }
              }

              print ICT  "   sub_conductor  \"$n20_tmp_name\" { \n" ;
              printf ICT "     height %.5f \n",$stack_hash{GOX}{HEIGHT}- $stack_hash{NOD}{THICKNESS}  ;
              printf ICT "     thickness %.5f \n",$stack_hash{NOD}{THICKNESS} ;
              printf ICT "     resistivity %.4g \n",$stack_hash{NOD}{RESIST}  ;
              printf ICT "     temp_tc1 %.10f \n",$stack_hash{NOD}{TC1}  ;
              printf ICT "     temp_tc2 %.20f \n",$stack_hash{NOD}{TC2}  ;
              &print_raise_diff($n20_indie_name,$t_type);
              print ICT "   }\n" ;
              $n20_tmp_name = "";
            }
          }
        }
        $n20_indie_name = "INDIE_TABLE[POD]" ;
        foreach $t_type (@{$manuf_table{$n20_indie_name}{manuf_type_arr}}){
          if ($t_type=~ /RAISED_DIFF/){
            my @n20_tmp = split(/\_/,$t_type);
            my $n20_tmp_name;
            if ($N20_flag ne 'G'){
              $n20_tmp_name = "$n20_tmp[-3]_$n20_tmp[-2]_$n20_tmp[-1]_active";
            }else{
              $n20_tmp_name = "$n20_tmp[-2]_$n20_tmp[-1]";
              if ($n20_tmp_name =~ /IO/){
                $n20_tmp_name = "G_1D5V".$n20_tmp_name."_active";
              }else{
                $n20_tmp_name = "G_".$n20_tmp_name."_active";
              }
            }

            print ICT  "   sub_conductor  \"$n20_tmp_name\" { \n" ;
            printf ICT "     height %.5f \n",$stack_hash{GOX}{HEIGHT}- $stack_hash{POD}{THICKNESS}  ;
            printf ICT "     thickness %.5f \n",$stack_hash{POD}{THICKNESS} ;
            printf ICT "     resistivity %.2f \n",$stack_hash{POD}{RESIST}  ;
            printf ICT "     temp_tc1 %.10f \n",$stack_hash{POD}{TC1}  ;
            printf ICT "     temp_tc2 %.20f \n",$stack_hash{POD}{TC2}  ;
            &print_raise_diff($n20_indie_name,$t_type);
            print ICT "   }\n" ;
          }
        }
        print ICT  "   sub_conductor  \"nod\" { \n" ;
        #printf ICT "     height %.5f \n",$stack_hash{FOX}{THICKNESS}- $stack_hash{NOD}{THICKNESS}-0.001 ;
        if ($find_process_node == 20 ){
          printf ICT "     height %.5f \n",$stack_hash{GOX}{HEIGHT}- $stack_hash{NOD}{THICKNESS}  ;
        }else{
          printf ICT "     height %.5f \n",$stack_hash{FOX}{THICKNESS}- $stack_hash{NOD}{THICKNESS}  ;
        }
        printf ICT "     thickness %.5f \n",$stack_hash{NOD}{THICKNESS} ;
#N28_1_01        &print_wee_info( $find_process_node , $OD_indie_name );
        printf ICT "     resistivity %.2f \n",$stack_hash{NOD}{RESIST}  ;
        printf ICT "     temp_tc1 %.10f \n",$stack_hash{NOD}{TC1}  ;
        printf ICT "     temp_tc2 %.20f \n",$stack_hash{NOD}{TC2}  ;

        if ($find_process_node == 20){
          if ($N20_flag ne 'G'){
            &print_raise_diff("INDIE_TABLE[NOD]","RAISED_DIFF_$N20_flag\_CORE_NMOS");
          }else{
            &print_raise_diff("INDIE_TABLE[NOD]","RAISED_DIFF_CORE_NMOS");
          }
        }
        print ICT "   }\n" ;

        print ICT  "   sub_conductor  \"pod\" { \n" ;
        #printf ICT "     height %.5f \n",$stack_hash{FOX}{THICKNESS}- $stack_hash{POD}{THICKNESS}-0.001 ;
        if ($find_process_node == 20 ){
          printf ICT "     height %.5f \n",$stack_hash{GOX}{HEIGHT}- $stack_hash{POD}{THICKNESS} ;
        }else{
          printf ICT "     height %.5f \n",$stack_hash{FOX}{THICKNESS}- $stack_hash{POD}{THICKNESS} ;
        }
        printf ICT "     thickness %.5f \n",$stack_hash{POD}{THICKNESS} ;
#N28_1_01        &print_wee_info( $find_process_node , $OD_indie_name );
        printf ICT "     resistivity %.4g \n",$stack_hash{POD}{RESIST}  ;
        printf ICT "     temp_tc1 %.10f \n",$stack_hash{POD}{TC1}  ;
        printf ICT "     temp_tc2 %.20f \n",$stack_hash{POD}{TC2}  ;
        if ($find_process_node == 20){
          if ($N20_flag ne 'G'){
            &print_raise_diff("INDIE_TABLE[POD]","RAISED_DIFF_$N20_flag\_CORE_PMOS");
          }else{
            &print_raise_diff("INDIE_TABLE[POD]","RAISED_DIFF_CORE_PMOS");
          }
        }
        print ICT "   }\n" ;
        print ICT "}\n" ;
        $od_written_out = 1 ;
      }

    }


    if (@array_stack[$i] eq poly ||  @array_stack[$i] eq fpoly ){
      print ICT "conductor \"poly\" {\n" ;
    } elsif (@array_stack[$i] eq fpoly_srm){
      print ICT "conductor \"poly_srm\" {\n" ;
    }else {
      $array_conductor_name = @array_stack[$i] ;
      if ($find_process_node < 40) {

        $array_conductor_name =~ s/metal/M/i ;

        if ($alrdl_present==1){
          $temp_array_conductor_name = $array_conductor_name ;
          $temp_array_conductor_name =~ s/\D+//i ;
          if ($temp_array_conductor_name > $max_metal_layer_number) {
            $array_conductor_name = "AP" ;
          }
        }

      }
      if (@array_stack[$i] eq substrate ){
        print ICT "substrate \"$array_conductor_name\" {\n" ;
      }else{
        print ICT "conductor \"$array_conductor_name\" {\n" ;
      }
    }

    #For TSV info
    if (@array_stack[$i] eq substrate ){
      print ICT "   conformal FALSE \n" ;
      print ICT "   height 0.0 \n";
      $depth_sub =  $stack_hash{SPACER}{HEIGHT} - $stack_hash{@array_stack[$i]}{THICKNESS} ; 
      $depth_sub = sprintf("%.5f" , abs $depth_sub) ; 
      print ICT "   depth $depth_sub\n";
      printf ICT "   dielectric_constant %.5g \n", $stack_hash{@array_stack[$i]}{CONSTANT};
    }else{
      $wire_space =  $stack_hash{@array_stack[$i]}{SPACE} ;
      $wire_space = sprintf("%.5f" , $wire_space) ; 
      $wire_space = sprintf("%.5g" , $wire_space) ; 

      print ICT "   min_spacing $wire_space\n";


      if (@array_stack[$i] eq poly ||  @array_stack[$i] eq fpoly ){

        if ($find_process_node < 40) {
          if ($find_process_node == 20){
            $min_contact_poly_spacing = 0.02;
          }else {
            $min_contact_poly_spacing = $manuf_table{"CONTACT_TABLE[odCont]"}{"odCont"}{poly_contact_spacing}{VALUE} ;
            if ( $min_contact_poly_spacing == 0 ){
              $min_contact_poly_spacing = $stack_hash{polyCont}{SPACE}/2 ;
            }
          }

        } else {
          $min_contact_poly_spacing = $stack_hash{polyCont}{SPACE}/2 ;
        }
        $min_contact_poly_spacing = sprintf("%.6f" , $min_contact_poly_spacing) ;
        print ICT "   min_contact_poly_spacing $min_contact_poly_spacing\n";
      }


      $wire_width =  $stack_hash{@array_stack[$i]}{WIDTH} ;
      $wire_width = sprintf("%.5f" , $wire_width) ; 
      $wire_width = sprintf("%.5g" , $wire_width) ;
      print ICT "   min_width $wire_width\n";

      $wire_top_enlargement =  $stack_hash{@array_stack[$i]}{T_BIAS}/2 ;
      $wire_top_enlargement = sprintf("%.5f" , $wire_top_enlargement) ; 
      $wire_top_enlargement = sprintf("%.5g" , $wire_top_enlargement) ; 
      print ICT "   wire_top_enlargement $wire_top_enlargement\n";

      $wire_bottom_enlargement =  $stack_hash{@array_stack[$i]}{B_BIAS}/2 ;
      $wire_bottom_enlargement = sprintf("%.5f" , $wire_bottom_enlargement) ;
      $wire_bottom_enlargement = sprintf("%.5g" , $wire_bottom_enlargement) ;
      print ICT "   wire_bottom_enlargement $wire_bottom_enlargement\n";

      #$wire_height =  $stack_hash{@array_stack[$i]}{HEIGHT} ;
      #$wire_height = sprintf("%.5f" , $wire_height) ;
      #print ICT "   height $wire_height\n";


      if ($find_process_node < 40 && (@array_stack[$i] eq poly ||  @array_stack[$i] eq fpoly) ) {
        $wire_height =  $stack_hash{gpoly}{HEIGHT} ;
        $wire_height = sprintf("%.5f" , $wire_height) ;
        print ICT "   height $wire_height\n";

      } else {
        if ( $stack_hash{@array_stack[$i]}{HEIGHT} < 0 ){
          $wire_height =  $stack_hash{@array_stack[$i]}{HEIGHT} - $stack_hash{FOX}{THICKNESS} + $stack_hash{SPACER}{HEIGHT} + $stack_hash{@array_stack[$i]}{THICKNESS} ;
        }else{
          $wire_height =  $stack_hash{@array_stack[$i]}{HEIGHT} ;
        }
        $wire_height = sprintf("%.5f" , $wire_height) ;
        print ICT "   height $wire_height\n";

      }

      if ($find_process_node < 40 && (@array_stack[$i] eq poly ||  @array_stack[$i] eq fpoly) ) {
#Base on v0.1p2 iRCX
#        if ($find_process_node == 20 ){
#          $wire_thickness =  $stack_hash{gpoly}{THICKNESS} - $stack_hash{GOX}{THICKNESS} ;
#        }else{
#          $wire_thickness =  $stack_hash{gpoly}{THICKNESS} ;
#        }
        $wire_thickness =  $stack_hash{gpoly}{THICKNESS} ;
        $wire_thickness = sprintf("%.5f" , $wire_thickness) ;
        print ICT "   thickness $wire_thickness\n";
      } else {
        $wire_thickness =  $stack_hash{@array_stack[$i]}{THICKNESS} ;
        $wire_thickness = sprintf("%.5f" , $wire_thickness) ;
        if ($stack_hash{@array_stack[$i]}{HEIGHT} < 0 ){
          print ICT "   depth $wire_thickness\n";
        }else{
          print ICT "   thickness $wire_thickness\n";
        }
      }


      if ((@array_stack[$i] eq "fpoly") &&( $find_process_node < 40 )){
        $indie_name = "INDIE_TABLE[poly]" ;
      }elsif((@array_stack[$i] eq "fpoly_srm") &&( $find_process_node == 20 )){
        $indie_name = "INDIE_TABLE[n_fpoly_srm]" ;
      }else{
        $indie_name = "INDIE_TABLE[".@array_stack[$i]."]" ;
      }

      $rho_flag = 1;
      $tc_flag = 1;
      $opc_table_present = 0 ;
      $rho_t_table_present = 0 ;
      $rho_table_write = 0 ;
      foreach $opc_table_check ( sort  keys(%{$manuf_table{$indie_name}})) {

        if ($opc_table_check =~/ADI_BIAS/i){
          $opc_table_present = 1 ;
        }
      }

      foreach $rho_t_table_check ( sort  keys(%{$manuf_table{$indie_name}})) {

        if ($rho_t_table_check =~/RHO_T/i){
          $rho_t_table_present = 1 ;
        }
      }

      foreach $indie_effect ( sort  keys(%{$manuf_table{$indie_name}})) {
        if ($find_process_node > 45) {
          if ($indie_effect =~ /rho/i){
            $rho_table_write = 1;
            $rho_flag = 0 ;
            &print_rho($find_process_node,$indie_name);
          }
        } else {
          if ($indie_effect =~ /rho_t/i){
            $rho_flag = 0 ;
#Joe's suggestion, use resistivity for poly in N20
            if ($find_process_node == 20 && ($indie_name eq "INDIE_TABLE[poly]" || $indie_name eq "INDIE_TABLE[n_fpoly_srm]")){
              print_resistivity($find_process_node ,$indie_name);
            }else{
              &print_RHO_T($find_process_node,$indie_name);
            }
            $rho_t_table_present = 1 ;
          } 
        }
        if ($indie_effect =~ /rho/i && $rho_table_write == 0 && $rho_t_table_present == 0){ 
          #print "$indie_name\n";
          $rho_flag = 0 ;
#Joe's suggestion, use resistivity for poly in N20
          if ($find_process_node == 20 && ($indie_name eq "INDIE_TABLE[poly]" || $indie_name eq "INDIE_TABLE[n_fpoly_srm]")){
            print_resistivity($find_process_node ,$indie_name);
          }else{
            &print_rho($find_process_node,$indie_name);
          }
        }
      }
      foreach $indie_effect ( sort  keys(%{$manuf_table{$indie_name}})) {  
        if ($opc_table_present == 0 ) { 
          if ($indie_effect =~ /width/i && $indie_effect !~ /_/){
            &print_wee_info($find_process_node,$indie_name);
          }
        }





        if ($opc_table_present == 1 ) { 
          if ($indie_effect =~ /ADI_BIAS/i ){

            print ICT "   wire_edge_enlargement\n" ;
            print ICT "      wee_widths " ;

            for ($wef=1; $wef<=scalar @{ $manuf_table{$indie_name}{$indie_effect}{second_line}}-1;$wef++) {
              $wee_width_value = $manuf_table{$indie_name}{$indie_effect}{second_line}[$wef]+ ($stack_hash{@array_stack[$i]}{T_BIAS}/2+ $stack_hash{@array_stack[$i]}{B_BIAS}/2);
              print ICT "$wee_width_value " ;
            }
            print ICT "\n";

            print ICT "      wee_spacings " ;
            for ($wef=1; $wef<=scalar @{ $manuf_table{$indie_name}{$indie_effect}{first_line}}-1;$wef++) {
              $wee_space_value = $manuf_table{$indie_name}{$indie_effect}{first_line}[$wef]- ($stack_hash{@array_stack[$i]}{T_BIAS}/2+ $stack_hash{@array_stack[$i]}{B_BIAS}/2) ;
              print ICT "$wee_space_value " ;
            }
            print ICT "\n";

            print ICT "      wee_adjustments " ;
            for ($wef=1; $wef<=scalar @{ $manuf_table{$indie_name}{$indie_effect}{first_line}}-1;$wef++) {

              for ($sef=1; $sef<=scalar @{ $manuf_table{$indie_name}{$indie_effect}{second_line}}-1;$sef++) {

                $width_index_value =  $manuf_table{$indie_name}{$indie_effect}{second_line}[$sef] ;
                $space_index_value =  $manuf_table{$indie_name}{$indie_effect}{first_line}[$wef] ;

                $wee_adjust_value = $manuf_table{$indie_name}{$indie_effect}{$width_index_value}{$space_index_value}-(($stack_hash{@array_stack[$i]}{T_BIAS}/2+ $stack_hash{@array_stack[$i]}{B_BIAS}/2)/2)  ;

                if ($find_process_node <=45) {
                  $wee_adjust_value_final = sprintf("%.5f", ($wee_adjust_value)) ;
                  #	$wee_adjust_value_final = sprintf("%.5g", $wee_adjust_value_final) ;
                } else {
                  $wee_adjust_value_final = sprintf("%.5f", ($wee_adjust_value)) ;
                  #	$wee_adjust_value_final = sprintf("%.5g", $wee_adjust_value_final) ;
                }

                if (abs($wee_adjust_value_final) == 0.0000) {
                  $wee_adjust_value_final = 0 ;

                }
                print ICT "$wee_adjust_value_final " ;
              }
              print ICT "\n                      ";
            }
            print ICT "\n";
          }

          if ($indie_effect =~ /API_BIAS/i ){

            print ICT "   higher_order_wire_edge_enlargement 1 {\n" ;
            print ICT "      wee_widths " ;

            for ($wef=1; $wef<=scalar @{ $manuf_table{$indie_name}{$indie_effect}{second_line}}-1;$wef++) {
              $wee_width_value = $manuf_table{$indie_name}{$indie_effect}{second_line}[$wef] ;
              print ICT "$wee_width_value " ;
            }
            print ICT "\n";

            print ICT "      wee_spacings " ;
            for ($wef=1; $wef<=scalar @{ $manuf_table{$indie_name}{$indie_effect}{first_line}}-1;$wef++) {
              $wee_space_value = $manuf_table{$indie_name}{$indie_effect}{first_line}[$wef] ;
              print ICT "$wee_space_value " ;
            }
            print ICT "\n";

            print ICT "      wee_adjustments " ;
            for ($wef=1; $wef<=scalar @{ $manuf_table{$indie_name}{$indie_effect}{first_line}}-1;$wef++) {

              for ($sef=1; $sef<=scalar @{ $manuf_table{$indie_name}{$indie_effect}{second_line}}-1;$sef++) {

                $width_index_value =  $manuf_table{$indie_name}{$indie_effect}{second_line}[$sef] ;
                $space_index_value =  $manuf_table{$indie_name}{$indie_effect}{first_line}[$wef] ;

                $wee_adjust_value = $manuf_table{$indie_name}{$indie_effect}{$width_index_value}{$space_index_value} ;

                if ($find_process_node <=45) {
                  $wee_adjust_value_final = sprintf("%.5f", ($wee_adjust_value)) ;
                  #$wee_adjust_value_final = sprintf("%.5f", $wee_adjust_value_final) ;
                } else {
                  $wee_adjust_value_final = sprintf("%.5f", ($wee_adjust_value)) ;
                  #$wee_adjust_value_final = sprintf("%.5g", $wee_adjust_value_final) ;
                }

                if (abs($wee_adjust_value_final) == 0.0000) {
                  $wee_adjust_value_final = 0 ;

                }
                print ICT "$wee_adjust_value_final " ;
              }

              if ($wef == scalar @{ $manuf_table{$indie_name}{$indie_effect}{first_line}}-1){
                print ICT "\n  }";
              } else {
                print ICT "\n                      ";
              }
            }
            print ICT "\n";
          }

        }
      }

      $diel_load_flag = 0 ;
      #print " @array_stack[$i] \n @array_stack[$i-1]\n";
      $diel_load_name = "LOADING_EFFECT_TABLE[".@array_stack[$i-1]."_THK]" ;

      @diel_load_array =  keys(%manuf_table) ;

      $diel_name = @array_stack[$i-1]."_THK" ;
      foreach $diel_load_check (@diel_load_array) {
        #print "loadin_check : $diel_load_check\n";
        if ($diel_load_name eq $diel_load_check){
          $diel_load_flag = 1 ;
        }

      }

      if ($diel_load_flag == 1 ){

        $diel_name = @array_stack[$i-1]."_THK" ;
        print ICT "   loading_effect \n" ;
        print ICT "      loading_effect_spacings " ;

        for ($wef=1; $wef<=scalar @{ $manuf_table{$diel_load_name}{$diel_name}{first_line}}-1;$wef++) {
          $load_space_value = $manuf_table{$diel_load_name}{$diel_name}{first_line}[$wef] ;
          print ICT "$load_space_value " ;
        }
        print ICT "  \n";

        print ICT "      loading_effect_widths " ;
        for ($wef=1; $wef<=scalar @{ $manuf_table{$diel_load_name}{$diel_name}{second_line}}-1;$wef++) {
          $load_width_value = $manuf_table{$diel_load_name}{$diel_name}{second_line}[$wef];
          print ICT "$load_width_value " ;
        }
        print ICT "\n";

        print ICT "      loading_effect_adjustments " ;
        for ($wef=1; $wef<=scalar @{ $manuf_table{$diel_load_name}{$diel_name}{second_line}}-1;$wef++) {

          for ($sef=1; $sef<=scalar @{ $manuf_table{$diel_load_name}{$diel_name}{first_line}}-1;$sef++) {

            $space_index_value =  $manuf_table{$diel_load_name}{$diel_name}{first_line}[$sef] ;
            $width_index_value =  $manuf_table{$diel_load_name}{$diel_name}{second_line}[$wef] ;

            $load_adjust_value = $manuf_table{$diel_load_name}{$diel_name}{$width_index_value}{$space_index_value} ;

            $space_index_value_minpitch =  $manuf_table{$diel_load_name}{$diel_name}{first_line}[1] ;
            $width_index_value_minpitch =  $manuf_table{$diel_load_name}{$diel_name}{second_line}[1] ;

            $load_adjust_min_pitch = $manuf_table{$diel_load_name}{$diel_name}{$width_index_value_minpitch}{$space_index_value_minpitch}   ;
            #print " The load adjust min pitch value is $load_adjust_min_pitch \n";
            #$load_adjust_value_final = sprintf("%.4f", $load_adjust_value- $stack_hash{@array_stack[$i-1]}{THICKNESS}) ;
            $load_adjust_value_final = sprintf("%.4f", $load_adjust_value-$load_adjust_min_pitch ) ;

            print ICT "$load_adjust_value_final " ;
          }
          print ICT "\n                                 ";
        }
        print ICT "\n";
      }
      print_factor($find_process_node , $indie_name);


      foreach $indie_effect (  keys(%{$manuf_table{$indie_name}})) {


        if ($indie_effect eq WIDTH_DEPENDENT){

          $tc_flag = 0 ;

          if((scalar @{ $manuf_table{$indie_name}{$indie_effect}{second_line}}-1) == 1){
          } else {
            print ICT "    width_dependent_tc \n" ;
            print ICT "	temp_widths " ;
          }

          for ($wef=1; $wef<=scalar @{ $manuf_table{$indie_name}{$indie_effect}{second_line}}-1;$wef++) {

            if((scalar @{ $manuf_table{$indie_name}{$indie_effect}{second_line}}-1) == 1){
            } else {

              $temp_width_value = $manuf_table{$indie_name}{$indie_effect}{second_line}[$wef] ;
              print ICT "$temp_width_value " ;
            }
          }
          print ICT "  \n";


          for ($wef=1; $wef<=scalar @{ $manuf_table{$indie_name}{$indie_effect}{first_line}}-1;$wef++) {
            print ICT "	temp_tc".$wef." "  ;

            for ($sef=1; $sef<=scalar @{ $manuf_table{$indie_name}{$indie_effect}{second_line}}-1;$sef++) {

              $tc_index_value =  $manuf_table{$indie_name}{$indie_effect}{first_line}[$wef] ;
              $tc_width_index_value =  $manuf_table{$indie_name}{$indie_effect}{second_line}[$sef] ;

              $tc_adjust_value = $manuf_table{$indie_name}{$indie_effect}{$tc_width_index_value}{$tc_index_value} ;

              $tc_adjust_value = sprintf("%.4e" ,$tc_adjust_value) ;
              print ICT "$tc_adjust_value " ;
            }
            print ICT "\n";
          }
          print ICT "\n";
        }

      }

      $poly_resist_flag = 1 ;
      if ($rho_flag == 1 && (@array_stack[$i] eq poly || @array_stack[$i] eq fpoly)) {
        $poly_resist_flag = 0 ;


        if ($find_process_node < 40) {

          if (exists $manuf_table{"INDIE_TABLE[poly]"}{"RHO_T"}  ) {
            print ICT "   rho\n" ;
            print ICT "      rho_silicon_widths " ;

            for ($wef=1; $wef<=scalar @{ $manuf_table{"INDIE_TABLE[poly]"}{"RHO_T"}{first_line}}-1;$wef++) {
              $rho_width_value = $manuf_table{"INDIE_TABLE[poly]"}{"RHO_T"}{first_line}[$wef] ;
              print ICT "$rho_width_value " ;
            }
            print ICT "  \n";

            print ICT "      rho_silicon_thicknesses " ;
            for ($wef=1; $wef<=scalar @{ $manuf_table{"INDIE_TABLE[poly]"}{"RHO_T"}{second_line}}-1;$wef++) {
              $rho_thick_value = $manuf_table{"INDIE_TABLE[poly]"}{"RHO_T"}{second_line}[$wef];
              print ICT "$rho_thick_value " ;
            }
            print ICT "\n";

            print ICT "      rho_values " ;
            for ($wef=1; $wef<=scalar @{ $manuf_table{"INDIE_TABLE[poly]"}{"RHO_T"}{second_line}}-1;$wef++) {

              for ($sef=1; $sef<=scalar @{ $manuf_table{"INDIE_TABLE[poly]"}{"RHO_T"}{first_line}}-1;$sef++) {

                $width_index_value =  $manuf_table{"INDIE_TABLE[poly]"}{"RHO_T"}{first_line}[$sef] ;
                $thick_index_value =  $manuf_table{"INDIE_TABLE[poly]"}{"RHO_T"}{second_line}[$wef] ;

                $rho_adjust_value = $manuf_table{"INDIE_TABLE[poly]"}{"RHO_T"}{$thick_index_value}{$width_index_value} ;

                $rho_adjust_value_final = sprintf("%.4f", $rho_adjust_value) ;

                if (abs($rho_adjust_value_final) == 0.0000) {
                  $rho_adjust_value_final = 0 ;

                }
                print ICT "$rho_adjust_value_final " ;
              }
              print ICT "\n                 ";
            }
            print ICT "\n";

          } else {

            print ICT "   resistivity " ;
            if (exists $manuf_table{"INDIE_TABLE[poly]"}{"RSH"}){
              @poly_resist_widths=@{$manuf_table{"INDIE_TABLE[poly]"}{"RSH"}{second_line}} ;

              $prw_scalar = scalar(@poly_resist_widths);
              #print ICT " The poly widhts are @poly_resist_widths \n";
              for  ($prws=1;$prws<=$prw_scalar-1;$prws++)  {

                $space_index_value =  $manuf_table{"INDIE_TABLE[poly]"}{"RSH"}{first_line}[1] ;
                $width_index_value =  $manuf_table{"INDIE_TABLE[poly]"}{"RSH"}{second_line}[$prws] ;
                $rsh_adjust_value = sprintf("%.1f",$manuf_table{"INDIE_TABLE[poly]"}{"RSH"}{$width_index_value}{$space_index_value}) ;
                $poly_width_si = $manuf_table{"INDIE_TABLE[poly]"}{"WIDTH"}{$width_index_value}{$space_index_value} ;
                $poly_resist_values = $rsh_adjust_value*($poly_width_si/$width_index_value) ;

                $poly_resist_values =sprintf("%.5f",$poly_resist_values) ;
                print ICT "$poly_resist_values $poly_width_si " ;
              }
            }else{
              if ( $stack_hash{fpoly}{INDIE_TABLE} !~ /N\/A/){
                $space_index_value =  $manuf_table{"INDIE_TABLE[poly]"}{"WIDTH"}{first_line}[1] ;
                $width_index_value =  $manuf_table{"INDIE_TABLE[poly]"}{"WIDTH"}{second_line}[1] ;
                $poly_width_si = $manuf_table{"INDIE_TABLE[poly]"}{"WIDTH"}{$width_index_value}{$space_index_value} ;
              }else{
                $width_index_value =  $stack_hash{fpoly}{WIDTH} ;
                $poly_width_si =  $stack_hash{fpoly}{WIDTH} + $stack_hash{fpoly}{BIAS} ;
              }
              $rsh_adjust_value = sprintf("%.1f",$stack_hash{fpoly}{RESIST}) ;
              $poly_resist_values = $rsh_adjust_value*($poly_width_si/$width_index_value) ;

              $poly_resist_values =sprintf("%.5f",$poly_resist_values) ;
              print ICT "$poly_resist_values $poly_width_si " ;

            }

          }
        } else {
          print ICT "   resistivity " ;
          @poly_resist_widths = ($stack_hash{@array_stack[$i]}{WIDTH});
          foreach (qw/0.1 0.15 0.2 0.5 1 2/){
            if ($_ > $poly_resist_widths[0]){
              push @poly_resist_widths, $_;
            }
          }

          foreach $poly_widths (@poly_resist_widths){

            $poly_width_si = $poly_widths+$stack_hash{@array_stack[$i]}{BIAS} ;

            $poly_resist_values = $stack_hash{@array_stack[$i]}{RESIST}*($poly_width_si/$poly_widths) ;

            $poly_resist_values =sprintf("%.5f",$poly_resist_values) ;
            if ( abs($poly_resist_values) > 0 ){
              print ICT "$poly_resist_values $poly_width_si " ;
            }else{
              print ICT " $stack_hash{@array_stack[$i]}{RESIST} \n";
            }

          }
        }

        print ICT "\n";

      } 
      if ($rho_flag == 1 && @array_stack[$i] eq fpoly_srm && $find_process_node == 20 && $indie_name eq "INDIE_TABLE[n_fpoly_srm]"){
        $poly_resist_flag = 0 ;
        print_resistivity($find_process_node ,$indie_name);
      }
      if ($rho_flag == 1 && @array_stack[$i] ne poly && @array_stack[$i] ne fpoly && @array_stack[$i] ne fpoly_srm ){
        if ($poly_resist_flag == 0){
        } else {
          print ICT "   resistivity $stack_hash{@array_stack[$i]}{RESIST} \n";
        }
      }
      if ($stack_hash{@array_stack[$i]}{TC1}!~/N\/A/ && $tc_flag == 1) {

        $tc1_value_final = sprintf("%.10f", $stack_hash{@array_stack[$i]}{TC1} ) ;
        print ICT "   temp_tc1 $tc1_value_final \n";
      }
      if ($stack_hash{@array_stack[$i]}{TC2}!~/N\/A/ && $tc_flag == 1) {

        $tc2_value_final = sprintf("%.20f", $stack_hash{@array_stack[$i]}{TC2} ) ;
        print ICT "   temp_tc2 $tc2_value_final \n";
      }

      if (@array_stack[$i]=~/poly/i) {
        print ICT "   gate_forming_layer true \n";
        if ($find_process_node < 40 && @array_stack[$i] !~ /srm/) {
          print ICT "   layer_type gate \n";
#N28_1_01          if (exists $stack_hash{metal_interface}{RESIST}){
#            print ICT "   sub_conductor \"metal_interface\" {\n";
#            print ICT "       wire_top_enlargement_r   0\n";
#            print ICT "       wire_bottom_enlargement_r   0\n";
#            if ($find_process_node  > 20){
#              $wire_height_interface_r =  $stack_hash{metal_interface}{HEIGHT} + 0.001 ;
#            }else{
#              $wire_height_interface_r =  $stack_hash{metal_interface}{HEIGHT} ;
#            }
#            $wire_height_interface_r = sprintf("%.5f" , $wire_height_interface_r) ;
#            print ICT "       height $wire_height_interface_r\n";
#            $wire_thickness_interface_r =  $stack_hash{metal_interface}{THICKNESS} ;
#            $wire_thickness_interface_r = sprintf("%.5f" , $wire_thickness_interface_r) ;
#            print ICT "       thickness $wire_thickness_interface_r\n";
#            $wire_resistivity_interface_r =  $stack_hash{metal_interface}{RESIST} ;
#            $wire_resistivity_interface_r = sprintf("%.4f" , $wire_resistivity_interface_r) ;
#            print ICT "       resistivity $wire_resistivity_interface_r\n";
#            print ICT "   }\n" ;
#          }
          if ($find_process_node == 20) {
            print_sub_poly($find_process_node,"n_poly","n_gpoly" , "INDIE_TABLE[n_gpoly]");
          }else{
            print_sub_poly($find_process_node,"n_poly","n_fpoly" , "INDIE_TABLE[n_fpoly]");
          }
          print ICT " } \n" ;
          if ($find_process_node == 20) {
            print_sub_poly($find_process_node,"p_poly","p_gpoly" , "INDIE_TABLE[p_gpoly]");
          }else{
            print_sub_poly($find_process_node,"p_poly","p_fpoly" , "INDIE_TABLE[p_fpoly]");
          }
          print ICT " } \n" ;

          if ($find_process_node == 20 ) {
            $n20_indie_name = "INDIE_TABLE[n_gpoly]" ;
            foreach $t_type (@{$manuf_table{$n20_indie_name}{manuf_type_arr}}){
              if ($t_type =~ /COV/){
                my $mos_name =$t_type;
                my $mos_name_tmp;
                $mos_name =~ s/COV\_EFFECTIVE\_FACTOR\_TABLE\_//g;	
                if ($N20_flag ne 'G'){
                  $mos_name_tmp = $mos_name;
                }else{
                  if ($mos_name =~ /IO/){
                    $mos_name_tmp = "G_1D5V$mos_name";
                  }else{
                    $mos_name_tmp = "G_$mos_name";
                  }
                }
                print_sub_poly($find_process_node,$mos_name_tmp,"n_gpoly" , "INDIE_TABLE[n_gpoly]");
                print_cfi($find_process_node,"INDIE_TABLE[n_gpoly]",$t_type);
                print ICT " } \n" ;
              }
            }
            $n20_indie_name = "INDIE_TABLE[p_gpoly]" ;
            foreach $t_type (@{$manuf_table{$n20_indie_name}{manuf_type_arr}}){
              #print "p_gpoly : $t_type\n";
              if ($t_type =~ /COV/){
                my $mos_name =$t_type;
                my $mos_name_tmp;
                $mos_name =~ s/COV\_EFFECTIVE\_FACTOR\_TABLE\_//g;	
                if ($N20_flag ne 'G'){
                  $mos_name_tmp = $mos_name;
                }else{
                  if ($mos_name =~ /IO/){
                    $mos_name_tmp = "G_1D5V$mos_name";
                  }else{
                    $mos_name_tmp = "G_$mos_name";
                  }
                }
                print_sub_poly($find_process_node,$mos_name_tmp,"p_gpoly" , "INDIE_TABLE[p_gpoly]");
                print_cfi($find_process_node,"INDIE_TABLE[p_gpoly]",$t_type);
                print ICT " } \n" ;
              }
            }
          }
        }elsif($find_process_node == 20 && @array_stack[$i] =~ /srm/){
          print ICT "   layer_type gate \n";
          print_sub_poly($find_process_node,"n_poly_srm","n_fpoly_srm" , "INDIE_TABLE[n_fpoly_srm]");
          print ICT " } \n" ;
          print_sub_poly($find_process_node,"p_poly_srm","p_fpoly_srm" , "INDIE_TABLE[p_fpoly_srm]");
          print ICT " } \n" ;
          $n20_indie_name = "INDIE_TABLE[n_gpoly_srm]" ;
          foreach $t_type (@{$manuf_table{$n20_indie_name}{manuf_type_arr}}){
            if ($t_type =~ /COV/){
              my $mos_name =$t_type;
              my $mos_name_tmp;
              $mos_name =~ s/COV\_EFFECTIVE\_FACTOR\_TABLE\_//g;	
              if ($N20_flag ne 'G'){
                $mos_name_tmp = $mos_name;
              }else{
                if ($mos_name =~ /IO/){
                  $mos_name_tmp = "G_1D5V$mos_name";
                }else{
                  $mos_name_tmp = "G_$mos_name";
                }
              }
              print_sub_poly($find_process_node,$mos_name_tmp,"n_gpoly_srm" , "INDIE_TABLE[n_gpoly_srm]");
              print_cfi($find_process_node,"INDIE_TABLE[n_gpoly_srm]",$t_type);
              print ICT " } \n" ;
            }
          }
          $n20_indie_name = "INDIE_TABLE[p_gpoly_srm]" ;
          foreach $t_type (@{$manuf_table{$n20_indie_name}{manuf_type_arr}}){
            if ($t_type =~ /COV/){
              my $mos_name =$t_type;
              my $mos_name_tmp;
              $mos_name =~ s/COV\_EFFECTIVE\_FACTOR\_TABLE\_//g;	
              if ($N20_flag ne 'G'){
                $mos_name_tmp = $mos_name;
              }else{
                if ($mos_name =~ /IO/){
                  $mos_name_tmp = "G_1D5V$mos_name";
                }else{
                  $mos_name_tmp = "G_$mos_name";
                }
              }
              print_sub_poly($find_process_node,$mos_name_tmp,"p_gpoly_srm" , "INDIE_TABLE[p_gpoly_srm]");
              print_cfi($find_process_node,"INDIE_TABLE[p_gpoly_srm]",$t_type);
              print ICT " } \n" ;
            }
          }
        }


        $contact_table_name = "CONTACT_TABLE[odCont]" ;


        foreach $contact_effect  ( @{$manuf_table{$contact_table_name}{manuf_type_arr}}) {
#N28_1_01          my $second_cf = '';
#N28_1_01          if ($contact_effect =~ /cf/i && $contact_effect !~ /2ND_CF/i){
          if ($contact_effect =~ /cf/i ){

            if ($contact_effect =~ /^cf\_/i) {

              $contact_effect_temp = $contact_effect ;
              @multi_cf =  split /^cf\_/i,$contact_effect_temp ; 
              print ICT " sub_conductor \"@multi_cf[1]\" { \n" ; 
#N28_1_01              $second_cf = "2ND_CF_OFFSET_$multi_cf[1]";
            }

            if ($find_process_node < 40) {
              if (@multi_cf[1] =~ /NMOS/i || @multi_cf[1] =~ /NA/i  ) {

                $wire_height_cf =  $stack_hash{n_gpoly}{HEIGHT} ;
                $wire_height_cf = sprintf("%.5f" , $wire_height_cf) ;
                print ICT "   height $wire_height_cf\n";

                $wire_thickness_cf =  $stack_hash{n_gpoly}{THICKNESS} ;
                $wire_thickness_cf = sprintf("%.5f" , $wire_thickness_cf) ;

                print ICT "   thickness $wire_thickness_cf\n";


                if (exists $manuf_table{"INDIE_TABLE[n_fpoly]"}{"RHO_T"}  ) {

                  print_RHO_T($find_process_node , "INDIE_TABLE[n_fpoly]" ) ;


                } else {
                  print_resistivity($find_process_node , "INDIE_TABLE[n_fpoly]");

                }
                print ICT "\n";
                print_wee_info( $find_process_node , "INDIE_TABLE[n_fpoly]" );
                print_factor( $find_process_node , "INDIE_TABLE[n_fpoly]" );

                $tc1_value_final = sprintf("%.10f", $stack_hash{n_fpoly}{TC1} ) ;
                print ICT "   temp_tc1 $tc1_value_final \n";

                $tc2_value_final = sprintf("%.20f", $stack_hash{n_fpoly}{TC2} ) ;
                print ICT "   temp_tc2 $tc2_value_final \n";

              }

              if (@multi_cf[1] =~ /PMOS/i || @multi_cf[1] =~ /PA/i ) {

                $wire_height_cf =  $stack_hash{p_gpoly}{HEIGHT} ;
                $wire_height_cf = sprintf("%.5f" , $wire_height_cf) ;
                print ICT "   height $wire_height_cf\n";

                $wire_thickness_cf =  $stack_hash{p_gpoly}{THICKNESS} ;
                $wire_thickness_cf = sprintf("%.5f" , $wire_thickness_cf) ;
                print ICT "   thickness $wire_thickness_cf\n";

                if (exists $manuf_table{"INDIE_TABLE[p_fpoly]"}{"RHO_T"}  ) {
                  print_RHO_T( $find_process_node , "INDIE_TABLE[p_fpoly]" ) ;

                } else {
                  print_resistivity($find_process_node , "INDIE_TABLE[p_fpoly]" ) ;
                }
                print ICT "\n" ;
                print_wee_info( $find_process_node , "INDIE_TABLE[p_fpoly]" );
                print_factor( $find_process_node , "INDIE_TABLE[p_fpoly]" );

                $tc1_value_final = sprintf("%.10f", $stack_hash{p_fpoly}{TC1} ) ;
                print ICT "   temp_tc1 $tc1_value_final \n";

                $tc2_value_final = sprintf("%.20f", $stack_hash{p_fpoly}{TC2} ) ;
                print ICT "   temp_tc2 $tc2_value_final \n";

              }
#N28_1_01              if (@multi_cf[1] =~ /ZVT/i && @multi_cf[1] !~ /NMOS/i && @multi_cf[1] !~ /PMOS/i ) {
#
#                $wire_height_cf =  $stack_hash{n_gpoly}{HEIGHT} ;
#                $wire_height_cf = sprintf("%.5f" , $wire_height_cf) ;
#                print ICT "   height $wire_height_cf\n";
#
#                $wire_thickness_cf =  $stack_hash{n_gpoly}{THICKNESS} ;
#                $wire_thickness_cf = sprintf("%.5f" , $wire_thickness_cf) ;
#
#                print ICT "   thickness $wire_thickness_cf\n";
#
#
#                if (exists $manuf_table{"INDIE_TABLE[n_fpoly]"}{"RHO_T"}  ) {
#
#                  print_RHO_T($find_process_node , "INDIE_TABLE[n_fpoly]" ) ;
#
#
#                } else {
#                  print_resistivity($find_process_node , "INDIE_TABLE[n_fpoly]");
#
#                }
#                print ICT "\n";
#                print_wee_info( $find_process_node , "INDIE_TABLE[n_fpoly]" );
#                print_factor( $find_process_node , "INDIE_TABLE[n_fpoly]" );
#
#                $tc1_value_final = sprintf("%.10f", $stack_hash{n_fpoly}{TC1} ) ;
#                print ICT "   temp_tc1 $tc1_value_final \n";
#
#                $tc2_value_final = sprintf("%.20f", $stack_hash{n_fpoly}{TC2} ) ;
#                print ICT "   temp_tc2 $tc2_value_final \n";
#
#              }
            }
            print ICT "   gate_diffusion_fringing_cap\n" ;
            print ICT "      cf_coco_spacings " ;

            for ($wef=1; $wef<=scalar @{ $manuf_table{$contact_table_name}{$contact_effect}{second_line}}-1;$wef++) {
              $cf_coco_value = $manuf_table{$contact_table_name}{$contact_effect}{second_line}[$wef] ;
              print ICT "$cf_coco_value " ;
            }
            print ICT "\n";

            print ICT "      cf_poco_spacings " ;
            for ($wef=1; $wef<=scalar @{ $manuf_table{$contact_table_name}{$contact_effect}{first_line}}-1;$wef++) {
              $cf_poco_value = $manuf_table{$contact_table_name}{$contact_effect}{first_line}[$wef] ;
              print ICT "$cf_poco_value " ;
            }
            print ICT "\n";

            print ICT "             cf_values " ;
            for ($wef=1; $wef<=scalar @{ $manuf_table{$contact_table_name}{$contact_effect}{first_line}}-1;$wef++) {

              for ($sef=1; $sef<=scalar @{ $manuf_table{$contact_table_name}{$contact_effect}{second_line}}-1;$sef++) {


                $coco_index_value =  $manuf_table{$contact_table_name}{$contact_effect}{second_line}[$sef] ;
                $poco_index_value =  $manuf_table{$contact_table_name}{$contact_effect}{first_line}[$wef] ;

                $cf_adjust_value = $manuf_table{$contact_table_name}{$contact_effect}{$coco_index_value}{$poco_index_value} ;


                if (abs($cf_adjust_value) == 0.0000) {
                  $cf_adjust_value = 0 ;

                }
                print ICT "$cf_adjust_value " ;
              }
              print ICT "\n                      ";
            }
            print ICT "\n";
#N28_1_01            if (exists $manuf_table{$contact_table_name}{$second_cf}  ) {
#              print ICT "   gate_diffusion_fringing_delta_cap\n" ;
#              print ICT "      cf_poco_spacings " ;
#
#              for ($wef=1; $wef<=scalar @{ $manuf_table{$contact_table_name}{$second_cf}{first_line}}-1;$wef++) {
#                $cf_poco_value = $manuf_table{$contact_table_name}{$second_cf}{first_line}[$wef] ;
#                print ICT "$cf_poco_value " ;
#              }
#              print ICT "\n";
#
#              print ICT "      cf_poly_widths " ;
#              for ($wef=1; $wef<=scalar @{ $manuf_table{$contact_table_name}{$second_cf}{second_line}}-1;$wef++) {
#                $cf_polywidth_value = $manuf_table{$contact_table_name}{$second_cf}{second_line}[$wef] ;
#                print ICT "$cf_polywidth_value " ;
#              }
#              print ICT "\n";
#
#              print ICT "             cf_delta_values " ;
#              for ($wef=1; $wef<=scalar @{ $manuf_table{$contact_table_name}{$second_cf}{second_line}}-1;$wef++) {
#                for ($sef=1; $sef<=scalar @{ $manuf_table{$contact_table_name}{$second_cf}{first_line}}-1;$sef++) {
#                  $poco_index_value =  $manuf_table{$contact_table_name}{$second_cf}{first_line}[$sef] ;
#                  $polywidth_index_value =  $manuf_table{$contact_table_name}{$second_cf}{second_line}[$wef] ;
#                  $cf_delta_adjust_value = $manuf_table{$contact_table_name}{$second_cf}{$polywidth_index_value}{$poco_index_value} ;
##                  if (abs($cf_adjust_value) == 0.0000) {
##                    $cf_adjust_value = 0.0000 ;
##                  }
#                  print ICT "$cf_delta_adjust_value " ;
#                }
#                print ICT "\n                      ";
#              }
#            }
          }
          if ($contact_effect =~ /^cf\_/i) {
            print ICT " } \n" ; 
          }
        }
      } else {
        print ICT "   gate_forming_layer false \n";
      }
      &output_em_conductor($array_stack[$i]) ;
    }
    print ICT "}\n";


    if ($stack_hash{@array_stack[$i]}{ABOVE_IMD_DIFF}!= 0 && $stack_hash{@array_stack[$i]}{ABOVE_IMD_DIFF} !~/N\/A/i && $array_stack[$i] !~ /srm/) {

      $above_imd = $stack_hash{@array_stack[$i]}{ABOVE_IMD} ;
      $imd_diff_diel = $stack_hash{@array_stack[$i]}{ABOVE_IMD}."_A" ;
      print ICT "dielectric \"$imd_diff_diel\" { \n";
      print ICT "   conformal false \n";
      printf ICT "   height  %.5f \n",$stack_hash{@array_stack[$i]}{HEIGHT} ;
      $imd_diff_thickness = abs($stack_hash{@array_stack[$i]}{ABOVE_IMD_DIFF}) ;
      printf ICT "   thickness %.5f \n",$imd_diff_thickness ;
      printf ICT "   dielectric_constant %.3g \n", $stack_hash{$above_imd}{CONSTANT};

      print ICT "} \n";
    }
  }



  $step_layer_present = 0 ;
  #if ( @array_stack[$i]=~/STEP/i && ( $stack_hash{GOX}{HEIGHT}== $stack_hash{STEP}{HEIGHT})&& ( $stack_hash{GOX}{THICKNESS}== $stack_hash{STEP}{THICKNESS}) ) {
  #$step_layer_present = 1 ;
  #}

  if ( @array_stack[$i]=~/STEP/i && ( $stack_hash{FOX}{THICKNESS}== $stack_hash{STEP}{HEIGHT}) ) {
    $step_layer_present = 1 ;
  }

  $written_fox1_step = 0 ;

#output dielectric layer
  if (($stack_hash{@array_stack[$i]}{TYPE}=~/D/ || $stack_hash{@array_stack[$i]}{TYPE}=~/P/) && @array_stack[$i]!~/GOX/i && $step_layer_present != 1 ){



    while(($damage_key,$damage_diel) = each %damage_k_hash) {

      if (@array_stack[$i] eq $damage_diel){

        $expanded_from = $damage_key ; 
        $expanded_from =~ s/DAM_// ;

        if ($find_process_node < 40) {
          $expanded_from =~ s/metal/M/i ;
        }


        $dielectric_height = sprintf("%.5f", $stack_hash{$damage_key}{HEIGHT} ) ;
        #$dielectric_height = sprintf("%.5g", $stack_hash{$damage_key}{HEIGHT} ) ;
        $dielectric_thickness = sprintf("%.5f", $stack_hash{$damage_key}{THICKNESS} ) ;
        #$dielectric_thickness = sprintf("%.5g", $stack_hash{$damage_key}{THICKNESS} ) ;
        $dielectric_sidethickness = sprintf("%.5f", $stack_hash{$damage_key}{SIDE_THICKNESS} ) ;
        $dielectric_topthickness =  sprintf("%.5f", $stack_hash{$damage_key}{TOP_THICKNESS} ) ;
        $dielectric_bottomthickness = sprintf("%.5f", $stack_hash{$damage_key}{BOTTOM_THICKNESS} ) ;
        #$dielectric_constant = sprintf("%.3f", $stack_hash{$damage_key}{CONSTANT} ) ;
        $dielectric_constant = sprintf("%.3g", $stack_hash{$damage_key}{CONSTANT} ) ;

        $damage_key_M = $damage_key ;
        if ($find_process_node < 40) {
          $damage_key_M =~ s/metal/M/i ;

          if ($alrdl_present==1){
            $temp_array_conductor_name = $damage_key_M   ;
            $temp_array_conductor_name =~ s/\D+//i ;
            if ($temp_array_conductor_name > $max_metal_layer_number) {
              $damage_key_M = "AP" ;
            }
          }
        }

        print ICT "dielectric \"$damage_key_M\" {\n" ;

        print ICT "   conformal TRUE\n";
        print ICT "   expandedFrom $expanded_from\n";
        print ICT "   height $dielectric_height\n";
        print ICT "   thickness $dielectric_thickness\n";
        print ICT "   topThickness $dielectric_topthickness \n";
        print ICT "   sideExpand $dielectric_sidethickness\n";
        print ICT "   bottomExpand $dielectric_bottomthickness\n";
        print ICT "   dielectric_constant $dielectric_constant\n}\n" ;
      }
    }

    if (@array_stack[$i] =~/LINER/i){

      print ICT "dielectric \"@array_stack[$i]\" {\n" ; 
      if ($stack_hash{@array_stack[$i]}{SIDE_THICKNESS}!~/N\/A/ && $stack_hash{@array_stack[$i]}{TOP_THICKNESS}!~/N\/A/) {
        print ICT "   conformal true\n";

        $ild_poly_thickness =  sprintf("%.5f", $stack_hash{@array_stack[$i-2]}{THICKNESS} ) ;

        if ($find_process_node == 20 ){
          $spacer_expanded =  @array_stack[$i-1] ;
          if ( $spacer_expanded !~ /SPACER/){  
            $spacer_expanded =  @array_stack[$i-2] ;
          }
        }else{
          $spacer_expanded =  @array_stack[$i-1] ;
        }
        if ( @array_stack[$i-1] =~/fpoly/i){
          $spacer_expanded = poly ;
        }
        print ICT "   expandedFrom $spacer_expanded \n";
      } else {
        print ICT "   conformal false\n";
      }

      if ($find_process_node < 40) {

        if ($find_process_node == 20){
          $dielectric_height = sprintf("%.5f", $stack_hash{@array_stack[$i]}{HEIGHT}) ;
          $dielectric_height_over = sprintf("%.5f", $stack_hash{@array_stack[$i]}{HEIGHT}+$stack_hash{ILD0a}{THICKNESS} ) ;
        }else{


          $dielectric_height = sprintf("%.5f", $stack_hash{@array_stack[$i]}{HEIGHT}+$stack_hash{GOX}{THICKNESS} ) ;
        }

        print ICT "   height $dielectric_height\n";
        if ($find_process_node == 20){
          print ICT "   height_over \"active\" $dielectric_height_over\n";
        }
      } else {
        $dielectric_height = sprintf("%.5f", $stack_hash{@array_stack[$i]}{HEIGHT} ) ;

        print ICT "   height $dielectric_height\n";
      }
      $dielectric_thickness = sprintf("%.5f", $stack_hash{@array_stack[$i]}{THICKNESS} ) ;

      print ICT "   thickness $dielectric_thickness\n";

      if ($stack_hash{@array_stack[$i]}{TOP_THICKNESS}!~/N\/A/ &&  $stack_hash{@array_stack[$i]}{DAMAGE_K}=~/N\/A/) {

        $dielectric_topthickness = sprintf("%.5f", $stack_hash{@array_stack[$i]}{TOP_THICKNESS} ) ;
        print ICT "   topThickness $dielectric_topthickness\n";
      }
      #  idexpane and  

      if ($stack_hash{@array_stack[$i]}{SIDE_THICKNESS}!~/N\/A/ && $stack_hash{@array_stack[$i]}{DAMAGE_K}=~/N\/A/ ) {

        $dielectric_sidethickness = sprintf("%.5f", $stack_hash{@array_stack[$i]}{SIDE_THICKNESS} ) ;
        print ICT "   sideExpand $dielectric_sidethickness\n";
      }

      $dielectric_constant = sprintf("%.3g", $stack_hash{@array_stack[$i]}{CONSTANT} ) ;
      print ICT "   dielectric_constant $dielectric_constant\n}\n" ;

#for N20 SPACER_SRM only
      if ($find_process_node == 20 && @array_stack[$i] eq "LINER"){
        print ICT "dielectric \"LINER_SRM\" {\n";
        print ICT "   conformal true\n";
        print ICT "   expandedFrom SPACER_SRM\n";
        $dielectric_height = sprintf("%.5f", $stack_hash{@array_stack[$i]}{HEIGHT}) ;
        $dielectric_height_over = sprintf("%.5f", $stack_hash{@array_stack[$i]}{HEIGHT}+$stack_hash{ILD0a}{THICKNESS} ) ;
        print ICT "   height $dielectric_height\n";
        print ICT "   height_over \"active\" $dielectric_height_over\n";
        $dielectric_thickness = sprintf("%.5f", $stack_hash{@array_stack[$i]}{THICKNESS} ) ;
#for N20 LINER_SRM's thickness is 0
        print ICT "   thickness 0.00000\n";
        $dielectric_topthickness = sprintf("%.5f", $stack_hash{@array_stack[$i]}{TOP_THICKNESS} ) ;
        print ICT "   topThickness $dielectric_topthickness\n";
        $dielectric_sidethickness = sprintf("%.5f", $stack_hash{@array_stack[$i]}{SIDE_THICKNESS} ) ;
        print ICT "   sideExpand $dielectric_sidethickness\n";
        $dielectric_constant = sprintf("%.3g", $stack_hash{@array_stack[$i]}{CONSTANT} ) ;
        print ICT "   dielectric_constant $dielectric_constant\n}\n" ;
      }

      if ($find_process_node == 20 ){

        print ICT "dielectric \"under_the_poly_srm\" {\n" ; 
        print ICT "   conformal true\n";
        print ICT "   expandedFrom poly_srm\n";
        $under_poly_height = $stack_hash{fpoly_srm}{HEIGHT} ;
        print ICT "   height $under_poly_height\n";
        print ICT "   thickness 0.00000\n";
        print ICT "   topThickness 0.00000\n";
        $bottomExpand = sprintf("%.5f", $stack_hash{GOX}{THICKNESS} ) ;
        print ICT "   bottomExpand $bottomExpand\n";
        print ICT "   sideExpand 0.00000\n";
        $dielectric_constant = sprintf("%.3g", $stack_hash{GOX}{CONSTANT} ) ;
        print ICT "   dielectric_constant $dielectric_constant\n" ;
        print_sub_expandedFrom($find_process_node,n_fpoly_srm,$bottomExpand,$dielectric_constant,under_the_poly_srm);
        print_sub_expandedFrom($find_process_node,p_fpoly_srm,$bottomExpand,$dielectric_constant,under_the_poly_srm);
        print_sub_expandedFrom($find_process_node,n_gpoly_srm,$bottomExpand,$dielectric_constant,under_the_poly_srm);
        print_sub_expandedFrom($find_process_node,p_gpoly_srm,$bottomExpand,$dielectric_constant,under_the_poly_srm);

        print ICT "}\n";
        print ICT "dielectric \"under_the_poly\" {\n" ; 
        print ICT "   conformal true\n";
        print ICT "   expandedFrom poly\n";
        $under_poly_height = $stack_hash{gpoly}{HEIGHT} ;
        print ICT "   height $under_poly_height\n";
        print ICT "   thickness 0.00000\n";
        print ICT "   topThickness 0.00000\n";
        $bottomExpand = sprintf("%.5f", $stack_hash{GOX}{THICKNESS} ) ;
        print ICT "   bottomExpand $bottomExpand\n";
        print ICT "   sideExpand 0.00000\n";
        $dielectric_constant = sprintf("%.3g", $stack_hash{GOX}{CONSTANT} ) ;
        print ICT "   dielectric_constant $dielectric_constant\n" ;
        print_sub_expandedFrom($find_process_node,n_gpoly,$bottomExpand,$dielectric_constant,under_the_poly);
        print_sub_expandedFrom($find_process_node,p_gpoly,$bottomExpand,$dielectric_constant,under_the_poly);

        print ICT "}\n";

        print ICT "dielectric \"under_gate\" {\n" ; 
        print ICT "   conformal true\n";
        print ICT "   expandedFrom under_the_poly\n";
        $under_gate_height = $stack_hash{gpoly}{HEIGHT} ;
        print ICT "   height $under_gate_height\n";
        print ICT "   thickness 0.00000\n";
        print ICT "   topThickness 0.00000\n";
        $bottomExpand = sprintf("%.5f", $stack_hash{GOX}{HEIGHT} ) ;
        print ICT "   bottomExpand 0.00000\n";
        print ICT "   sideExpand 0.00000\n";
        if ( $stack_hash{n_gpoly_Bottom}{CONSTANT} > $stack_hash{p_gpoly_Bottom}{CONSTANT} ){
          $dielectric_constant = $stack_hash{n_gpoly_Bottom}{CONSTANT} ;
        }else{
          $dielectric_constant = $stack_hash{p_gpoly_Bottom}{CONSTANT} ;
        }

        print ICT "   dielectric_constant $dielectric_constant\n" ;
        print_sub_expandedFrom($find_process_node,"n_gpoly",$bottomExpand,$stack_hash{n_gpoly_Bottom}{CONSTANT},"under_the_gate");
        print_sub_expandedFrom($find_process_node,"p_gpoly",$bottomExpand,$stack_hash{p_gpoly_Bottom}{CONSTANT},"under_the_gate");
        print ICT "}\n";

        print ICT "dielectric \"under_gate_srm\" {\n" ; 
        print ICT "   conformal true\n";
        print ICT "   expandedFrom under_the_poly_srm\n";
        $under_gate_height = $stack_hash{gpoly}{HEIGHT} ;
        print ICT "   height $under_gate_height\n";
        print ICT "   thickness 0.00000\n";
        print ICT "   topThickness 0.00000\n";
        $bottomExpand = sprintf("%.5f", $stack_hash{GOX}{HEIGHT} ) ;
        print ICT "   bottomExpand 0.00000\n";
        print ICT "   sideExpand 0.00000\n";
        if ( $stack_hash{n_gpoly_Bottom}{CONSTANT} > $stack_hash{p_gpoly_Bottom}{CONSTANT} ){
          $dielectric_constant = $stack_hash{n_gpoly_Bottom}{CONSTANT} ;
        }else{
          $dielectric_constant = $stack_hash{p_gpoly_Bottom}{CONSTANT} ;
        }

        print ICT "   dielectric_constant $dielectric_constant\n" ;
        print_sub_expandedFrom($find_process_node,"n_gpoly_srm",$bottomExpand,$stack_hash{n_gpoly_Bottom}{CONSTANT},"under_the_gate");
        print_sub_expandedFrom($find_process_node,"p_gpoly_srm",$bottomExpand,$stack_hash{p_gpoly_Bottom}{CONSTANT},"under_the_gate");
        print ICT "}\n";

        print ICT "dielectric \"under_OD\" {\n" ;
        print ICT "   conformal true\n";
        print ICT "   expandedFrom active\n";
        if ( $stack_hash{NOD}{HEIGHT} >  $stack_hash{POD}{HEIGHT} ){
          $under_OD_height = $stack_hash{NOD}{HEIGHT} ;
        }else{
          $under_OD_height = $stack_hash{POD}{HEIGHT} ;
        }
        print ICT "   height $under_OD_height\n";
        print ICT "   thickness 0.00000\n";
        print ICT "   topThickness 0.00000\n";
        $bottomExpand = sprintf("%.5f", $under_OD_height ) ;
        print ICT "   bottomExpand $bottomExpand\n";
        print ICT "   sideExpand 0.00000\n";
        if ( $stack_hash{NOD_Bottom}{CONSTANT} > $stack_hash{POD_Bottom}{CONSTANT} ){
          $dielectric_constant = $stack_hash{NOD_Bottom}{CONSTANT} ;
        }else{
          $dielectric_constant = $stack_hash{POD_Bottom}{CONSTANT} ;
        }
        print ICT "   dielectric_constant $dielectric_constant\n" ;
        print_sub_expandedFrom($find_process_node,"NOD",$stack_hash{NOD}{HEIGHT},$stack_hash{NOD_Bottom}{CONSTANT},"under_OD");
        print_sub_expandedFrom($find_process_node,"POD",$stack_hash{POD}{HEIGHT},$stack_hash{POD_Bottom}{CONSTANT},"under_OD");
        print ICT "}\n";
        my @arr_temp;	
        push @arr_temp, "RH_TN";
        push @arr_temp, "M0_PO_TiN";
        push @arr_temp, "M0_PO_N";
        push @arr_temp, "M0_PO_P";
        push @arr_temp, "M0_STI1";
        push @arr_temp, "M0_STI2";
        push @arr_temp, "M0_STI2_fox";
        push @arr_temp, "M0_PO_N_SRM";
        push @arr_temp, "M0_PO_P_SRM";
        push @arr_temp, "M0_STI1_SRM";
        push @arr_temp, "M0_STI2_SRM";
        push @arr_temp, "M0_STI2_SRM_fox";
        push @arr_temp, "M0_OD1";
        push @arr_temp, "M0_OD1_SRM";
        push @arr_temp, "M0_OD2";
        push @arr_temp, "M0_OD2_SRM";
        foreach $PO_NAME (@arr_temp){
          print ICT "conductor \"$PO_NAME\" {\n" ;
          my $indie_name = "metal0_po";
          if ($PO_NAME =~ /SRM/){
            $indie_name = "metal0_po_srm";
            if ($PO_NAME =~ /M0_STI(\d+)_SRM_fox/){
              $indie_name = "metal0_sti$1_fox_srm";
            }elsif ($PO_NAME =~ /M0_STI(\d+)_SRM/){
              $indie_name = "metal0_sti$1_srm";
            }
            if ($PO_NAME =~ /M0_OD(\d+)_SRM/){
              $indie_name = "metal0_od$1_srm";
            }
          }else{
            if ($PO_NAME =~ /M0_STI(\S+)_fox/){
              $indie_name = "metal0_sti$1_fox";
            }elsif ($PO_NAME =~ /M0_STI(\S+)/){
              $indie_name = "metal0_sti$1";
            }
            if ($PO_NAME =~ /M0_OD(\S+)/){
              $indie_name = "metal0_od$1";
            }
            if ($PO_NAME =~ /RH_TN/){
              $indie_name = "rh_tn";
            }
            if ($PO_NAME =~ /M0_PO_TiN/){
              $indie_name = "metal0_po_tin";
            }
          }
          $indie_table = "INDIE_TABLE\[$indie_name\]" ;

          printf ICT "   min_spacing	%.4f \n",$stack_hash{$indie_name}{SPACE} ;
          printf ICT "   min_width	%.4f \n",$stack_hash{$indie_name}{WIDTH} ;
          printf ICT "   height	%.5f \n",$stack_hash{$indie_name}{HEIGHT} ;
          printf ICT "   thickness	%.5f \n",$stack_hash{$indie_name}{THICKNESS} ;
          print ICT "   gate_forming_layer true\n";
          $wire_top_enlargement =  $stack_hash{$indie_name}{T_BIAS}/2 ;
          printf ICT "   wire_top_enlargement %.5f \n", $wire_top_enlargement;

          $wire_bottom_enlargement =  $stack_hash{$indie_name}{B_BIAS}/2 ;
          printf ICT "   wire_bottom_enlargement %.5f \n", $wire_bottom_enlargement;
          if ($PO_NAME =~ /RH_TN|M0_PO_TiN/){
            print_resistivity($find_process_node ,$indie_table);
          }else{
            &print_rho($find_process_node,$indie_table);
          }
          printf ICT "   temp_tc1 %.10f \n", $stack_hash{$indie_name}{TC1} ;
          printf ICT "   temp_tc2 %.20f \n", $stack_hash{$indie_name}{TC2}  ;
#Change all coplanar layer( M0) to 1D-WEE table
          if ( $PO_NAME =~ /M0_OD1/){
            &print_wee_m0_info($find_process_node,$indie_table);
            if ($PO_NAME =~ /SRM/){
              &print_vee_table($find_process_node,$indie_table,"metal0_od1_srm");
            }else{
              &print_vee_table($find_process_node,$indie_table,"metal0_od1");
            }
          }else{
            &print_wee_m0_info($find_process_node,$indie_table);
          }
          &output_em_conductor_m0($indie_name) ;
          print ICT "}\n";
        }
        my @arr_tt ;
        push @arr_tt, "ILD0a";
        push @arr_tt, "ILD0b";
        push @arr_tt, "ILD1a";
        push @arr_tt, "ILD1b";
        if (exists($stack_hash{ILD1c}{HEIGHT})){
          push @arr_tt, "ILD1c";
        }
        if (exists($stack_hash{ILD1d}{HEIGHT})){
          push @arr_tt, "ILD1d";			
        }
        foreach $die_name (@arr_tt){

          print ICT "dielectric \"$die_name\" {\n" ;
          print ICT "   conformal false\n";
          if ($die_name =~ /ILD0a/){
            $die_height = $stack_hash{$die_name}{HEIGHT} + $stack_hash{GOX}{THICKNESS} ;
            $die_height = sprintf("%.6g" , $die_height);
            $die_thickness = $stack_hash{$die_name}{THICKNESS}  -$stack_hash{GOX}{THICKNESS} ;
            $die_thickness = sprintf("%.6g" , $die_thickness );
#          }elsif($die_name =~ /ILD0b/){
#            $die_height = $stack_hash{$die_name}{HEIGHT} + $stack_hash{LINER}{THICKNESS} ;
#            $die_height = sprintf("%.6g" , $die_height);
#            $die_thickness = $stack_hash{$die_name}{THICKNESS}  -$stack_hash{LINER}{THICKNESS} ;
#            $die_thickness = sprintf("%.6g" , $die_thickness );
          }else{
            $die_height = sprintf("%.6g" , $stack_hash{$die_name}{HEIGHT} );
            $die_thickness = sprintf("%.6g" , $stack_hash{$die_name}{THICKNESS} );
          }
          print ICT "   height	 $die_height \n";
          print ICT "   thickness	 $die_thickness \n";
          print ICT "   dielectric_constant $stack_hash{$die_name}{CONSTANT}\n" ;
          print ICT "}\n";
        }






      }else{


        print ICT "dielectric \"ILD_C\" {\n" ; 
        print ICT "   conformal false\n";
        #print " The write out ild_c_height is $ild_dielectric_height \n" ; 
        $ild_dielectric_height = sprintf("%.6g", $ild_dielectric_height ) ;
        $ild_poly_thickness = sprintf("%.6g", $ild_poly_thickness);
        #$ild_poly_thickness = sprintf("%.6g", $ild_poly_thickness - $stack_hash{LINER}{THICKNESS});

        print ICT "   height $ild_dielectric_height\n";
        print ICT "   thickness $ild_poly_thickness\n";
        print ICT "   dielectric_constant $ild_dielectric_constant\n}\n" ;

        print ICT "dielectric \"ILD_B\" {\n" ; 
        print ICT "   conformal false\n";
        $ild_b_height =  sprintf("%.5f",$ild_dielectric_height+ $ild_poly_thickness) ;
        $ild_b_thickness =  sprintf("%.5f",$ild_dielectric_thickness-$ild_poly_thickness) ;  
        print ICT "   height  $ild_b_height \n";
        print ICT "   thickness $ild_b_thickness \n";
        print ICT "   dielectric_constant $ild_dielectric_constant\n}\n" 
      }
    }

    if ($find_process_node < 40 ) {
      $ild_dielectric_height =   sprintf ("%.5f",$stack_hash{FOX}{THICKNESS}+$stack_hash{STEP}{THICKNESS}+ $stack_hash{LINER}{THICKNESS}+ $stack_hash{GOX}{THICKNESS}) ;
    } else {
      $ild_dielectric_height =   sprintf ("%.5f",$stack_hash{FOX}{THICKNESS}+$stack_hash{STEP}{THICKNESS}+ $stack_hash{LINER}{THICKNESS}) ;
    }

    #print " the ild dielectric height is $ild_dielectric_height \n" ;
    $ild_dielectric_thickness = sprintf ("%.5f", $stack_hash{ILD}{HEIGHT}+$stack_hash{ILD}{THICKNESS} -$ild_dielectric_height) ;
    $ild_dielectric_constant =  sprintf ("%.3g",$stack_hash{ILD}{CONSTANT}) ;

    if (@array_stack[$i] =~/ILD/i && $ILD_flag == 0){
      print ICT "dielectric \"ILD\" {\n" ; 
      print ICT "   conformal false\n";
      $ild_dielectric_height = sprintf("%.6g", $ild_dielectric_height ) ;
      $ild_dielectric_thickness = sprintf("%.6g", $ild_dielectric_thickness);

      print ICT "   height $ild_dielectric_height\n";
      print ICT "   thickness $ild_dielectric_thickness\n";
      print ICT "   dielectric_constant $ild_dielectric_constant\n}\n" ;
    }

    if (@array_stack[$i] !~/ILD/i && @array_stack[$i] !~/LINER/i) {
      print ICT "dielectric \"@array_stack[$i]\" {\n" ;

      if ($stack_hash{@array_stack[$i]}{SIDE_THICKNESS}!~/N\/A/ && $stack_hash{@array_stack[$i]}{TOP_THICKNESS}!~/N\/A/) {
        print ICT "   conformal true\n";


        $spacer_expanded =  @array_stack[$i-1] ;
        if ( @array_stack[$i-1] =~/fpoly/i){
          $spacer_expanded = poly ;
        }
        print ICT "   expandedFrom $spacer_expanded \n";
      } else {
        print ICT "   conformal false\n";
      }

      if ($find_process_node < 40 &&  @array_stack[$i] =~ /SPACER/i ) {
        $dielectric_height = sprintf("%.5f", $stack_hash{@array_stack[$i]}{HEIGHT}+$stack_hash{GOX}{THICKNESS} ) ;
        print ICT "   height $dielectric_height\n";
      } else {
        if ( $stack_hash{@array_stack[$i]}{HEIGHT} < 0 ){
          $dielectric_height = sprintf("%.5f", $stack_hash{@array_stack[$i]}{HEIGHT}-$stack_hash{FOX}{THICKNESS} + $stack_hash{SPACER}{HEIGHT} + $stack_hash{@array_stack[$i]}{THICKNESS}  ) ;
        }else{
          $dielectric_height = sprintf("%.5f", $stack_hash{@array_stack[$i]}{HEIGHT} ) ;
        }
        print ICT "   height $dielectric_height\n";
      }
      $dielectric_thickness = sprintf("%.5f", $stack_hash{@array_stack[$i]}{THICKNESS} ) ;

      if (@array_stack[$i]=~/FOX/){

        if ($find_process_node >=  40) {
          $dielectric_thickness = $stack_hash{FOX}{THICKNESS}+$stack_hash{STEP}{THICKNESS} ;
        }
        if ($find_process_node <  40) {
          #$dielectric_thickness = $stack_hash{FOX}{THICKNESS}- $stack_hash{OD}{THICKNESS}-0.001 ;
          #print " FOX : $stack_hash{FOX}{THICKNESS}\n";
          #print " OD : $stack_hash{OD}{THICKNESS}\n";
          if ($find_process_node == 20 ){
            if ($stack_hash{NOD}{THICKNESS} > $stack_hash{POD}{THICKNESS}){
              $od_t = $stack_hash{POD}{THICKNESS};
            }else{
              $od_t = $stack_hash{NOD}{THICKNESS};
            }
            $dielectric_thickness = $stack_hash{GOX}{HEIGHT} - $od_t;
          }else{
            $dielectric_thickness = $stack_hash{FOX}{THICKNESS} - $stack_hash{OD}{THICKNESS};
          }
          $fox_28nm_thickness = $dielectric_thickness ;
          $fox_28nm_thickness = sprintf("%.5f",$fox_28nm_thickness) ;
        }
        $dielectric_thickness = sprintf("%.5f",$dielectric_thickness) ;
        print ICT "   thickness $dielectric_thickness\n";
      } else {
        if ($stack_hash{@array_stack[$i]}{HEIGHT} < 0 ){ 
          $dielectric_thickness = sprintf("%.6g",$dielectric_thickness) ;
          print ICT "   depth $dielectric_thickness\n";
        }else{
          $dielectric_thickness = sprintf("%.6g",$dielectric_thickness) ;
          print ICT "   thickness $dielectric_thickness\n";
        }
      }

      if ($stack_hash{@array_stack[$i]}{TOP_THICKNESS}!~/N\/A/ &&  $stack_hash{@array_stack[$i]}{DAMAGE_K}=~/N\/A/) {

        $dielectric_topthickness = sprintf("%.5f", $stack_hash{@array_stack[$i]}{TOP_THICKNESS} ) ;
        print ICT "   topThickness $dielectric_topthickness\n";
      }


      if ($stack_hash{@array_stack[$i]}{SIDE_THICKNESS}!~/N\/A/ && $stack_hash{@array_stack[$i]}{DAMAGE_K}=~/N\/A/ ) {

        $dielectric_sidethickness = sprintf("%.5f", $stack_hash{@array_stack[$i]}{SIDE_THICKNESS} ) ;
        print ICT "   sideExpand $dielectric_sidethickness\n";
      }

      $dielectric_constant = sprintf("%.3g", $stack_hash{@array_stack[$i]}{CONSTANT} ) ;

#print DPT variable_dielectric_constant
      if (exists ($manuf_table{"INDIE_TABLE[$array_stack[$i-1]]"}{FACTOR_DPT_POLYNOMIAL1}{CONDITION})){
        my @dpt_spacing = ();
        my @dpt_polynomial = ();
        my $dpt_name = "INDIE_TABLE[$array_stack[$i-1]]";
        print ICT "   variable_dielectric_constant {\n" ;
        print ICT "      conductor_spacings " ;
        if ($opc_table_present == 1){
          for (my $dpts=1; $dpts<=scalar @{ $manuf_table{$dpt_name}{ADI_BIAS}{first_line}}-1;$dpts++) {
            my $dpt_space_value = $manuf_table{$dpt_name}{ADI_BIAS}{first_line}[$dpts]- ($stack_hash{$array_stack[$i-1]}{T_BIAS}/2+ $stack_hash{$array_stack[$i-1]}{B_BIAS}/2);
            $dpt_space_value = sprintf("%.5f", $dpt_space_value);
            push @dpt_spacing, $manuf_table{$dpt_name}{ADI_BIAS}{first_line}[$dpts];
            print ICT "$dpt_space_value " ;
          }
        }else{
          for (my $dpts=1; $dpts<=scalar @{ $manuf_table{$dpt_name}{WIDTH}{first_line}}-1;$dpts++) {
            my $dpt_space_value = $manuf_table{$dpt_name}{WIDTH}{first_line}[$dpts]- $stack_hash{$array_stack[$i-1]}{BIAS};
            $dpt_space_value = sprintf("%.5f", $dpt_space_value);
            push @dpt_spacing, $manuf_table{$dpt_name}{WIDTH}{first_line}[$dpts];
            print ICT "$dpt_space_value " ;
          }
        }
        print ICT "\n";
        print ICT "      dielectric_constants " ;

        foreach (@{$manuf_table{$dpt_name}{manuf_type_arr}}){
          if ($_ =~ /FACTOR_DPT_POLYNOMIAL/){
            push @dpt_polynomial, $_;
          }
        }
        foreach my $dpt_s (@dpt_spacing){
          foreach my $dpt_f (@dpt_polynomial){
            my $dpt_c = $manuf_table{$dpt_name}{$dpt_f}{CONDITION};
            my $dpt_e = $manuf_table{$dpt_name}{$dpt_f}{EQUATION};
            $dpt_e =~ s/\^/**/g;
            $dpt_e =~ s/s/$dpt_s/g;
            my @dpt_ca = split /\s+/,$manuf_table{$dpt_name}{$dpt_f}{CONDITION};
            if ($#dpt_ca == 2){
              $dpt_c =~ s/s/$dpt_s/;
              if (eval($dpt_c)){
                for (my $dpt_k = 1; $dpt_k <= scalar @{$manuf_table{$dpt_name}{$dpt_f}{second_line}} -1; $dpt_k++){
                  for (my $dpt_v = 1; $dpt_v <= scalar @{$manuf_table{$dpt_name}{$dpt_f}{first_line}} -1; $dpt_v++){
                    my $dpt_index_v = $manuf_table{$dpt_name}{$dpt_f}{first_line}[$dpt_v];
                    my $dpt_index_k = $manuf_table{$dpt_name}{$dpt_f}{second_line}[$dpt_k];
                    my $dpt_coef = $manuf_table{$dpt_name}{$dpt_f}{$dpt_index_k}{$dpt_index_v};
                    $dpt_e =~ s/$dpt_index_k/$dpt_coef/;
                  }
                }
                my $variable_diel = sprintf("%.6f", eval($dpt_e));
                print ICT "$variable_diel ";
              }
            }else{
              my $dpt_c1 = "$dpt_ca[0] $dpt_ca[1] $dpt_s";
              my $dpt_c2 = "$dpt_s $dpt_ca[3] $dpt_ca[4]";
              if (eval($dpt_c1) && eval($dpt_c2)){
                for (my $dpt_k = 1; $dpt_k <= scalar @{$manuf_table{$dpt_name}{$dpt_f}{second_line}} -1; $dpt_k++){
                  for (my $dpt_v = 1; $dpt_v <= scalar @{$manuf_table{$dpt_name}{$dpt_f}{first_line}} -1; $dpt_v++){
                    my $dpt_index_v = $manuf_table{$dpt_name}{$dpt_f}{first_line}[$dpt_v];
                    my $dpt_index_k = $manuf_table{$dpt_name}{$dpt_f}{second_line}[$dpt_k];
                    my $dpt_coef = $manuf_table{$dpt_name}{$dpt_f}{$dpt_index_k}{$dpt_index_v};
                    $dpt_e =~ s/$dpt_index_k/$dpt_coef/;
                  }
                }
                my $variable_diel = sprintf("%.6f", eval($dpt_e));
                print ICT "$variable_diel ";
              }
            }
          }
        }
        print ICT "\n";
        print ICT "   }\n";
        print ICT "}\n";
      }else{
        print ICT "   dielectric_constant $dielectric_constant\n}\n" ;
      }

#for N20 SPACER_SRM only
      if ($find_process_node == 20 && @array_stack[$i] eq "SPACER"){
        print ICT "dielectric \"SPACER_SRM\" {\n";
        print ICT "   conformal true\n";
        print ICT "   expandedFrom poly_srm\n";
        $dielectric_height = sprintf("%.5f", $stack_hash{@array_stack[$i]}{HEIGHT}+$stack_hash{GOX}{THICKNESS} ) ;
        print ICT "   height $dielectric_height\n";
        $dielectric_thickness = sprintf("%.5f", $stack_hash{@array_stack[$i]}{THICKNESS} ) ;
        print ICT "   thickness $dielectric_thickness\n";
        $dielectric_topthickness = sprintf("%.5f", $stack_hash{@array_stack[$i]}{TOP_THICKNESS} ) ;
        print ICT "   topThickness $dielectric_topthickness\n";
#sideExpand is based on param_file, not in iRCX
#Base on V0.5 to V1.0, sideExpand is from 0.0055 to 0.005
        print ICT "   sideExpand 0.0050\n";
        $dielectric_constant = sprintf("%.3g", $stack_hash{@array_stack[$i]}{CONSTANT} ) ;
        print ICT "   dielectric_constant $dielectric_constant\n}\n" ;
      }

      if ($find_process_node < 40 &&   @array_stack[$i]=~/FOX/i && $written_fox1_step == 0 ) {
        print ICT "dielectric \"FOX1\" {\n" ;

        $dielectric_constant = sprintf("%.3g", $stack_hash{FOX}{CONSTANT} ) ;
        print ICT "   conformal false\n" ;
        $dielectric_height = $fox_28nm_thickness ;
        print ICT "   height $dielectric_height\n";
        if ($find_process_node == 20 ){
          $dielectric_thickness = sprintf("%.5f", $od_t ) ;
        }else{
          $dielectric_thickness = sprintf("%.5f", $stack_hash{OD}{THICKNESS} ) ;
        }
        print ICT "   thickness $dielectric_thickness\n";
        print ICT "   dielectric_constant $dielectric_constant\n" ;
        print ICT "} \n" ;
        #print ICT "dielectric \"STEP\" {\n" ;
        #print ICT "   conformal FALSE\n" ;
        #$dielectric_height =  $stack_hash{OD}{THICKNESS}+$fox_28nm_thickness ;
        #print ICT "   height $dielectric_height \n" ; 
        #print ICT "   thickness 0.001\n";
        #print ICT "   dielectric_constant $dielectric_constant\n" ;
        #print ICT " } \n" ;

        print ICT "dielectric \"GOX\" {\n" ;
        print ICT "   conformal false\n" ;
        #$dielectric_height =  $stack_hash{OD}{THICKNESS}+$fox_28nm_thickness ;
        print ICT "   height  $stack_hash{GOX}{HEIGHT} \n" ; 
        print ICT "   thickness  $stack_hash{GOX}{THICKNESS}\n";
        if ($find_process_node == 20){
        #Follow Joe's ict file
          print ICT "   dielectric_constant  $stack_hash{ILD0a}{CONSTANT}\n" ;
        }else{
          print ICT "   dielectric_constant  $stack_hash{GOX}{CONSTANT}\n" ;
        }
        print ICT "} \n" ;

        $written_fox1_step = 1 ;

      }

    }
  }
}

if ($find_process_node <= 20){
  for ($i=0;$i<=(scalar(@array_stack_via)-1);$i++) {
    if ($array_stack_via[$i] =~ /dup/i || $array_stack_via[$i] =~ /n_odtap/ || $array_stack_via[$i] =~ /p_odtap/ || $array_stack_via[$i] =~ /^fptap/){
      if ($array_stack_via[$i] ne "n_odtap_srm"){
        next;
      }
    }

    $cont_upper_name = $stack_hash{$array_stack_via[$i]}{UPPER} ;
    $cont_lower_name = $stack_hash{$array_stack_via[$i]}{LOWER} ;
    if ($array_stack_via[$i] =~ /via0/i ) {
      if ($cont_lower_name =~ /po/ && $cont_lower_name !~ /tin/ ){
        if ($cont_lower_name =~ /srm/){
          &print_via0_info($find_process_node , $array_stack_via[$i],$cont_upper_name,"M0_PO_N_SRM" );
          &print_via0_info($find_process_node , $array_stack_via[$i],$cont_upper_name,"M0_PO_P_SRM" );
        }else{
          &print_via0_info($find_process_node , $array_stack_via[$i],$cont_upper_name,"M0_PO_N" );
          &print_via0_info($find_process_node , $array_stack_via[$i],$cont_upper_name,"M0_PO_P" );
        }
      }else{
        &print_via0_info($find_process_node , $array_stack_via[$i],$cont_upper_name,$cont_lower_name );
      }

    }
    if ($array_stack_via[$i] =~ /tap/i){
      &print_via0_info($find_process_node , $array_stack_via[$i],$cont_upper_name,$cont_lower_name );

    }
  }
}


if ($find_process_node >= 28 ){ 

  print ICT "via \"polyCont\" {\n" ;

  $polycont_upper_name = $stack_hash{polyCont}{UPPER} ;

  if ($find_process_node < 40) {
    $polycont_upper_name =~ s/metal/M/i ;
  }

  print ICT "   top_layer     \"$polycont_upper_name\"\n" ;
  print ICT "   bottom_layer  \"poly\"\n" ;

  $via_resist = sprintf("%.6g", $stack_hash{polyCont}{RESIST});

  if ($ircx_process_node =~/cbest/ && $ircx_process_node !~ /typical/ && $find_process_node <= 65){
    @via_variation_info = split /\//,  $stack_hash{polyCont}{VARIATION};
    $via_resist = $via_resist + @via_variation_info[-1] ;
  }

  if ($ircx_process_node =~/cworst/ && $ircx_process_node !~ /typical/ && $find_process_node <= 65){
    @via_variation_info = split /\//,  $stack_hash{polyCont}{VARIATION};
    $via_resist = $via_resist + @via_variation_info[-2] ;
  }
  print ICT "   area_resistance  $via_resist ", $stack_hash{polyCont}{WIDTH}*$stack_hash{polyCont}{LENGTH}," \n" ;

  $via_tc1 = sprintf("%.10f", $stack_hash{polyCont}{TC1});
  $via_tc2 = sprintf("%.20f", $stack_hash{polyCont}{TC2});

  if ($find_process_node < 40) {
    print ICT "   min_top_encl 0.00 \n" ;
    print ICT "   min_bot_encl -0.0045 \n" ;
    print ICT "   min_width $stack_hash{polyCont}{WIDTH} \n" ;
    print ICT "   min_spacing $stack_hash{polyCont}{SPACE} \n" ;
  }
  print ICT "   temp_tc1 $via_tc1  \n" ;
  print ICT "   temp_tc2 $via_tc2 \n" ;

  if ($find_process_node < 40) {
    $via_resist_n = sprintf("%.6g", $stack_hash{n_polyCont}{RESIST});

    if ($ircx_process_node =~/cbest/ && $ircx_process_node !~ /typical/){
      @via_variation_info_n = split /\//,  $stack_hash{n_polyCont}{VARIATION};
      $via_resist_n = $via_resist_n + @via_variation_info_n[-1] ;
    }

    if ($ircx_process_node =~/cworst/ && $ircx_process_node !~ /typical/){
      @via_variation_info_n = split /\//,  $stack_hash{n_polyCont}{VARIATION};
      $via_resist_n = $via_resist_n + @via_variation_info_n[-2] ;
    }

    $via_resist_p = sprintf("%.6g", $stack_hash{p_polyCont}{RESIST});

    if ($ircx_process_node =~/cbest/ && $ircx_process_node !~ /typical/){
      @via_variation_info_p = split /\//,  $stack_hash{p_polyCont}{VARIATION};
      $via_resist_p = $via_resist_p + @via_variation_info_p[-1] ;
    }

    if ($ircx_process_node =~/cworst/ && $ircx_process_node !~ /typical/){
      @via_variation_info_p = split /\//,  $stack_hash{p_polyCont}{VARIATION};
      $via_resist_p = $via_resist_p + @via_variation_info_p[-2] ;
    }

    print ICT "     sub_via \"n_polyCont\" {\n" ;

    print ICT "        area_resistance  $via_resist_n ", $stack_hash{n_polyCont}{WIDTH}*$stack_hash{n_polyCont}{LENGTH}," \n" ;

    $via_tc1_n = sprintf("%.10f", $stack_hash{n_polyCont}{TC1});
    $via_tc2_n = sprintf("%.20f", $stack_hash{n_polyCont}{TC2});
    print ICT "       temp_tc1 $via_tc1_n  \n" ;
    print ICT "       temp_tc2 $via_tc2_n \n" ;
    print ICT "   } \n" ;

    print ICT "     sub_via \"p_polyCont\" {\n" ;

    print ICT "        area_resistance  $via_resist_p ", $stack_hash{p_polyCont}{WIDTH}*$stack_hash{p_polyCont}{LENGTH}," \n" ;

    $via_tc1_p = sprintf("%.10f", $stack_hash{p_polyCont}{TC1});
    $via_tc2_p = sprintf("%.20f", $stack_hash{p_polyCont}{TC2});
    print ICT "       temp_tc1 $via_tc1_p  \n" ;
    print ICT "       temp_tc2 $via_tc2_p \n" ;
    print ICT "   } \n" ;

  }

  &output_em_via("polyCont") ;

  print ICT "}  \n" ;
}

if ($find_process_node >28) {
  print ICT "via \"odCont\" {\n" ;

  $podcont_upper_name = $stack_hash{podCont}{UPPER} ;

  if ($find_process_node < 40) {
    $podcont_upper_name =~ s/metal/M/i ;
  }

  print ICT "   top_layer     \"$podcont_upper_name\"\n" ;
  print ICT "   bottom_layer  \"P_SOURCE_DRAIN\"\n" ;

  $via_resist = sprintf("%.6g", $stack_hash{podCont}{RESIST});
  if ($ircx_process_node =~/cbest/ && $ircx_process_node !~ /typical/ && $find_process_node <= 65){
    @via_variation_info = split /\//,  $stack_hash{podCont}{VARIATION};
    $via_resist = $via_resist + @via_variation_info[-1] ;
  }

  if ($ircx_process_node =~/cworst/ && $ircx_process_node !~ /typical/ && $find_process_node <= 65){
    @via_variation_info = split /\//,  $stack_hash{podCont}{VARIATION};
    $via_resist = $via_resist + @via_variation_info[-2] ;
  }
  print ICT "   area_resistance  $via_resist ", $stack_hash{podCont}{WIDTH}*$stack_hash{podCont}{LENGTH}," \n" ;

  $via_tc1 = sprintf("%.10f", $stack_hash{podCont}{TC1});
  $via_tc2 = sprintf("%.20f", $stack_hash{podCont}{TC2});
  print ICT "   temp_tc1 $via_tc1  \n" ;
  print ICT "   temp_tc2 $via_tc2 \n" ;

  $contact_table_name = "CONTACT_TABLE[odCont]" ;

  $cco_present = 0 ; 
  foreach $contact_effect  ( keys(%{$manuf_table{$contact_table_name}})) {

    if ($contact_effect =~ /^cco/i){

      $cco_present = 1 ; 
    }

  }



  foreach $contact_effect  ( keys(%{$manuf_table{$contact_table_name}})) {
    if ($contact_effect =~ /odCont/i){
      if ($find_process_node <=45) {
        print ICT "   min_top_encl 0.00  \n" ;
        print ICT "   min_bot_encl 0.01  \n" ;
        print ICT "   min_width  $stack_hash{podCont}{WIDTH} \n" ;
        print ICT "   min_spacing  $stack_hash{podCont}{SPACE} \n" ;
      }
      if (($find_process_node ==65)  || ($find_process_node ==55)) {
        print ICT "   min_top_encl 0.00  \n" ;
        print ICT "   min_bot_encl 0.015  \n" ;
        print ICT "   min_width  $stack_hash{podCont}{WIDTH} \n" ;
        print ICT "   min_spacing  $stack_hash{podCont}{SPACE} \n" ;
      }
      if($manuf_table{$contact_table_name}{$contact_effect}{cco_width_effective}{VALUE} && $cco_present == 0 ){


        $od_top_bot =  ($manuf_table{$contact_table_name}{$contact_effect}{cco_width_effective}{VALUE} - $stack_hash{podCont}{WIDTH})/2 ;
        print ICT "   via_top_enlargement $od_top_bot \n";
        print ICT "   via_bottom_enlargement $od_top_bot \n";
      }
    }
  }



  foreach $contact_effect  ( @{$manuf_table{$contact_table_name}{manuf_type_arr}}) {
    if ($contact_effect =~ /cco/i ){
      if ($contact_effect =~ /^cco\_/i) {

        $contact_effect_temp = $contact_effect ;
        @multi_cf =  split /^cco\_/i,$contact_effect_temp ; 
        $multi_cco = @multi_cf[1]."_odCont" ;
        print ICT " sub_via \"$multi_cco\" { \n" ; 
      }

      print ICT "   via_edge_enlargement\n" ;
      print ICT "      vee_coco_spacings " ;

      for ($wef=1; $wef<=scalar @{ $manuf_table{$contact_table_name}{$contact_effect}{second_line}}-1;$wef++) {
        $vee_coco_value = $manuf_table{$contact_table_name}{$contact_effect}{second_line}[$wef] ;
        print ICT "$vee_coco_value " ;
      }
      print ICT "\n";

      print ICT "      vee_poco_spacings " ;
      for ($wef=1; $wef<=scalar @{ $manuf_table{$contact_table_name}{$contact_effect}{first_line}}-1;$wef++) {
        $vee_poco_value = $manuf_table{$contact_table_name}{$contact_effect}{first_line}[$wef] ;
        print ICT "$vee_poco_value " ;
      }
      print ICT "\n";

      print ICT "      vee_adjustments " ;
      for ($wef=1; $wef<=scalar @{ $manuf_table{$contact_table_name}{$contact_effect}{first_line}}-1;$wef++) {

        for ($sef=1; $sef<=scalar @{ $manuf_table{$contact_table_name}{$contact_effect}{second_line}}-1;$sef++) {


          $coco_index_value =  $manuf_table{$contact_table_name}{$contact_effect}{second_line}[$sef] ;
          $poco_index_value =  $manuf_table{$contact_table_name}{$contact_effect}{first_line}[$wef] ;

          $vee_adjust_value = -($manuf_table{$contact_table_name}{$contact_effect}{$coco_index_value}{$poco_index_value}) ;


          if (abs($vee_adjust_value) == 0.0000) {
            $vee_adjust_value = 0 ;

          }

          if ($vee_adjust_value =~ /^\+/) {

            $vee_adjust_value =~ s/^\+// ; 
          }
          print ICT "$vee_adjust_value " ;
        }
        print ICT "\n                      ";
      }
      print ICT "\n";
      if ($contact_effect =~ /^cco\_/i) {

        print ICT " } \n" ; 
      }
    }

  }

  &output_em_via("podCont") ;

  print ICT "}  \n" ;

  print ICT "via \"odCont\" {\n" ;

  $nodcont_upper_name = $stack_hash{nodCont}{UPPER} ;

  if ($find_process_node < 40) {
    $nodcont_upper_name =~ s/metal/M/i ;
  }


  print ICT "   top_layer     \"$nodcont_upper_name\"\n" ;
  print ICT "   bottom_layer  \"N_SOURCE_DRAIN\"\n" ;

  $via_resist = sprintf("%.6g", $stack_hash{nodCont}{RESIST});
  if ($ircx_process_node =~/cbest/ && $ircx_process_node !~ /typical/ && $find_process_node <= 65){
    @via_variation_info = split /\//,  $stack_hash{nodCont}{VARIATION};
    $via_resist = $via_resist + @via_variation_info[-1] ;
  }

  if ($ircx_process_node =~/cworst/ && $ircx_process_node !~ /typical/ && $find_process_node <= 65){
    @via_variation_info = split /\//,  $stack_hash{nodCont}{VARIATION};
    $via_resist = $via_resist + @via_variation_info[-2] ;
  }
  print ICT "   area_resistance  $via_resist ", $stack_hash{nodCont}{WIDTH}*$stack_hash{nodCont}{LENGTH}," \n" ;

  $via_tc1 = sprintf("%.10f", $stack_hash{nodCont}{TC1});
  $via_tc2 = sprintf("%.20f", $stack_hash{nodCont}{TC2});
  print ICT "   temp_tc1 $via_tc1  \n" ;
  print ICT "   temp_tc2 $via_tc2 \n" ;

  $contact_table_name = "CONTACT_TABLE[odCont]" ;

  $cco_present = 0 ; 
  foreach $contact_effect  ( keys(%{$manuf_table{$contact_table_name}})) {

    if ($contact_effect =~ /^cco/i){

      $cco_present = 1 ; 
    }

  }
  foreach $contact_effect  ( keys(%{$manuf_table{$contact_table_name}})) {

    #print " The contact effect is $contact_effect \n" ;
    if ($contact_effect =~ /odCont/i){
      if ($find_process_node <=45) {
        print ICT "   min_top_encl 0.00  \n" ;
        print ICT "   min_bot_encl 0.01  \n" ;
        print ICT "   min_width  $stack_hash{nodCont}{WIDTH} \n" ;
        print ICT "   min_spacing  $stack_hash{nodCont}{SPACE} \n" ;
      }
      if (($find_process_node ==65)  || ($find_process_node ==55)) {
        print ICT "   min_top_encl 0.00  \n" ;
        print ICT "   min_bot_encl 0.015  \n" ;
        print ICT "   min_width  $stack_hash{podCont}{WIDTH} \n" ;
        print ICT "   min_spacing  $stack_hash{podCont}{SPACE} \n" ;
      }
      if($manuf_table{$contact_table_name}{$contact_effect}{cco_width_effective}{VALUE} && $cco_present == 0 ){
        $od_top_bot =  ($manuf_table{$contact_table_name}{$contact_effect}{cco_width_effective}{VALUE}-  $stack_hash{nodCont}{WIDTH})/2  ;
        print ICT "   via_top_enlargement $od_top_bot \n";
        print ICT "   via_bottom_enlargement $od_top_bot \n";
      }
    }

  } 


  foreach $contact_effect  ( @{$manuf_table{$contact_table_name}{manuf_type_arr}}) {
    if ($contact_effect =~ /cco/i ){

      if ($contact_effect =~ /^cco\_/i) {

        $contact_effect_temp = $contact_effect ;
        @multi_cf =  split /^cco\_/i,$contact_effect_temp ; 
        $multi_cco = @multi_cf[1]."_odCont" ;
        print ICT " sub_via \"$multi_cco\" { \n" ; 
      }
      print ICT "   via_edge_enlargement\n" ;
      print ICT "      vee_coco_spacings " ;

      for ($wef=1; $wef<=scalar @{ $manuf_table{$contact_table_name}{$contact_effect}{second_line}}-1;$wef++) {
        $vee_coco_value = $manuf_table{$contact_table_name}{$contact_effect}{second_line}[$wef] ;
        print ICT "$vee_coco_value " ;
      }
      print ICT "\n";

      print ICT "      vee_poco_spacings " ;
      for ($wef=1; $wef<=scalar @{ $manuf_table{$contact_table_name}{$contact_effect}{first_line}}-1;$wef++) {
        $vee_poco_value = $manuf_table{$contact_table_name}{$contact_effect}{first_line}[$wef] ;
        print ICT "$vee_poco_value " ;
      }
      print ICT "\n";

      print ICT "      vee_adjustments " ;
      for ($wef=1; $wef<=scalar @{ $manuf_table{$contact_table_name}{$contact_effect}{first_line}}-1;$wef++) {

        for ($sef=1; $sef<=scalar @{ $manuf_table{$contact_table_name}{$contact_effect}{second_line}}-1;$sef++) {


          $coco_index_value =  $manuf_table{$contact_table_name}{$contact_effect}{second_line}[$sef] ;
          $poco_index_value =  $manuf_table{$contact_table_name}{$contact_effect}{first_line}[$wef] ;

          $vee_adjust_value = -($manuf_table{$contact_table_name}{$contact_effect}{$coco_index_value}{$poco_index_value}) ;


          if (abs($vee_adjust_value) == 0.0000) {
            $vee_adjust_value = 0 ;

          }

          if ($vee_adjust_value =~ /^\+/) {

            $vee_adjust_value =~ s/^\+// ; 
          }
          print ICT "$vee_adjust_value " ;
        }
        print ICT "\n                      ";
      }
      print ICT "\n";
      if ($contact_effect =~ /^cco\_/i) {

        print ICT " } \n" ; 
      }

    }

  }

  &output_em_via("nodCont") ;

  print ICT "}  \n" ;
}


if ($find_process_node < 40 && $find_process_node > 20) {
  print ICT "via \"odCont\" {\n" ;

  $odcont_upper_name = $stack_hash{odCont}{UPPER} ;

  if ($find_process_node < 40) {
    $odcont_upper_name =~ s/metal/M/i ;
  }

  print ICT "   top_layer     \"$odcont_upper_name\"\n" ;
  print ICT "   bottom_layer  \"active\"\n" ;

  $via_resist = sprintf("%.6g", $stack_hash{odCont}{RESIST});
  if ($ircx_process_node =~/cbest/ && $ircx_process_node !~ /typical/){
    @via_variation_info = split /\//,  $stack_hash{odCont}{VARIATION};
    $via_resist = $via_resist + @via_variation_info[-1] ;
  }

  if ($ircx_process_node =~/cworst/ && $ircx_process_node !~ /typical/){
    @via_variation_info = split /\//,  $stack_hash{odCont}{VARIATION};
    $via_resist = $via_resist + @via_variation_info[-2] ;
  }
  print ICT "   area_resistance  $via_resist ", $stack_hash{odCont}{WIDTH}*$stack_hash{odCont}{LENGTH}," \n" ;

  $via_tc1 = sprintf("%.10f", $stack_hash{odCont}{TC1});
  $via_tc2 = sprintf("%.20f", $stack_hash{odCont}{TC2});
  print ICT "   temp_tc1 $via_tc1  \n" ;
  print ICT "   temp_tc2 $via_tc2 \n" ;


  $via_resist_n = sprintf("%.6g", $stack_hash{n_odCont}{RESIST});
  if ($ircx_process_node =~/cbest/ && $ircx_process_node !~ /typical/){
    @via_variation_info_n = split /\//,  $stack_hash{n_odCont}{VARIATION};
    $via_resist_n = $via_resist_n + @via_variation_info_n[-1] ;
  }

  if ($ircx_process_node =~/cworst/ && $ircx_process_node !~ /typical/){
    @via_variation_info_n = split /\//,  $stack_hash{n_odCont}{VARIATION};
    $via_resist_n = $via_resist_n + @via_variation_info_n[-2] ;
  }

  $via_resist_p = sprintf("%.6g", $stack_hash{p_odCont}{RESIST});
  if ($ircx_process_node =~/cbest/ && $ircx_process_node !~ /typical/){
    @via_variation_info_p = split /\//,  $stack_hash{p_odCont}{VARIATION};
    $via_resist_p = $via_resist_p + @via_variation_info_p[-1] ;
  }

  if ($ircx_process_node =~/cworst/ && $ircx_process_node !~ /typical/){
    @via_variation_info_p = split /\//,  $stack_hash{p_odCont}{VARIATION};
    $via_resist_p = $via_resist_p + @via_variation_info_p[-2] ;
  }


  $contact_table_name = "CONTACT_TABLE[odCont]" ;

  $cco_present = 0 ; 
  foreach $contact_effect  ( keys(%{$manuf_table{$contact_table_name}})) {

    if ($contact_effect =~ /^cco/i){

      $cco_present = 1 ; 
    }

  }
  foreach $contact_effect  ( keys(%{$manuf_table{$contact_table_name}})) {

    #print " The contact effect is $contact_effect \n" ;
    if ($contact_effect =~ /odCont/i){
      if ($find_process_node <=45) {
        print ICT "   min_top_encl 0.00  \n" ;
        print ICT "   min_bot_encl 0.01  \n" ;
        print ICT "   min_width  $stack_hash{odCont}{WIDTH} \n" ;
        print ICT "   min_spacing  $stack_hash{odCont}{SPACE} \n" ;
      }
      if (($find_process_node ==65)  || ($find_process_node ==55)) {
        print ICT "   min_top_encl 0.00  \n" ;
        print ICT "   min_bot_encl 0.015  \n" ;
        print ICT "   min_width  $stack_hash{odCont}{WIDTH} \n" ;
        print ICT "   min_spacing  $stack_hash{odCont}{SPACE} \n" ;
      }
      if ($find_process_node < 40) {
        print ICT "     sub_via \"n_odCont\" {\n" ;

        print ICT "        area_resistance  $via_resist_n ", $stack_hash{n_odCont}{WIDTH}*$stack_hash{n_odCont}{LENGTH}," \n" ;

        $via_tc1_n = sprintf("%.10f", $stack_hash{n_odCont}{TC1});
        $via_tc2_n = sprintf("%.20f", $stack_hash{n_odCont}{TC2});
        print ICT "       temp_tc1 $via_tc1_n  \n" ;
        print ICT "       temp_tc2 $via_tc2_n \n" ;
        print ICT "   } \n" ;

        print ICT "     sub_via \"p_odCont\" {\n" ;

        print ICT "        area_resistance  $via_resist_p ", $stack_hash{p_odCont}{WIDTH}*$stack_hash{p_odCont}{LENGTH}," \n" ;

        $via_tc1_p = sprintf("%.10f", $stack_hash{p_odCont}{TC1});
        $via_tc2_p = sprintf("%.20f", $stack_hash{p_odCont}{TC2});
        print ICT "       temp_tc1 $via_tc1_p  \n" ;
        print ICT "       temp_tc2 $via_tc2_p \n" ;
        print ICT "   } \n" ;

      }
      if($manuf_table{$contact_table_name}{$contact_effect}{cco_width_effective}{VALUE} && $cco_present == 0 ){
        $od_top_bot =  ($manuf_table{$contact_table_name}{$contact_effect}{cco_width_effective}{VALUE}-  $stack_hash{odCont}{WIDTH})/2  ;
        print ICT "   via_top_enlargement $od_top_bot \n";
        print ICT "   via_bottom_enlargement $od_top_bot \n";
      }
    }

  } 


  foreach $contact_effect  ( @{$manuf_table{$contact_table_name}{manuf_type_arr}}) {
    if ($contact_effect =~ /cco/i ){

      if ($contact_effect =~ /^cco\_/i) {

        $contact_effect_temp = $contact_effect ;
        @multi_cf =  split /^cco\_/i,$contact_effect_temp ; 
        $multi_cco = @multi_cf[1]."_odCont" ;
        print ICT " sub_via \"$multi_cco\" { \n" ; 
      }
      if ($find_process_node < 40) {
        if ($multi_cco =~ /NMOS/i ) {

          $via_resist_n = sprintf("%.6g", $stack_hash{n_odCont}{RESIST});
          if ($ircx_process_node =~/cbest/ && $ircx_process_node !~ /typical/){
            @via_variation_info_n = split /\//,  $stack_hash{n_odCont}{VARIATION};
            $via_resist_n = $via_resist_n + @via_variation_info_n[-1] ;
          }
          if ($ircx_process_node =~/cworst/ && $ircx_process_node !~ /typical/){
            @via_variation_info_n = split /\//,  $stack_hash{n_odCont}{VARIATION};
            $via_resist_n = $via_resist_n + @via_variation_info_n[-2] ;
          }
          print ICT "        area_resistance  $via_resist_n ", $stack_hash{n_odCont}{WIDTH}*$stack_hash{n_odCont}{LENGTH}," \n" ;
          $via_tc1_n = sprintf("%.10f", $stack_hash{n_odCont}{TC1});
          $via_tc2_n = sprintf("%.20f", $stack_hash{n_odCont}{TC2});
          print ICT "       temp_tc1 $via_tc1_n  \n" ;
          print ICT "       temp_tc2 $via_tc2_n \n" ;
        }

        if ($multi_cco =~ /PMOS/i ) {

          $via_resist_p = sprintf("%.6g", $stack_hash{p_odCont}{RESIST});
          if ($ircx_process_node =~/cbest/ && $ircx_process_node !~ /typical/){
            @via_variation_info_p = split /\//,  $stack_hash{p_odCont}{VARIATION};
            $via_resist_p = $via_resist_p + @via_variation_info_p[-1] ;
          }

          if ($ircx_process_node =~/cworst/ && $ircx_process_node !~ /typical/){
            @via_variation_info_p = split /\//,  $stack_hash{p_odCont}{VARIATION};
            $via_resist_p = $via_resist_p + @via_variation_info_p[-2] ;
          }

          print ICT "        area_resistance  $via_resist_p ", $stack_hash{p_odCont}{WIDTH}*$stack_hash{p_odCont}{LENGTH}," \n" ;
          $via_tc1_p = sprintf("%.10f", $stack_hash{p_odCont}{TC1});
          $via_tc2_p = sprintf("%.20f", $stack_hash{p_odCont}{TC2});
          print ICT "       temp_tc1 $via_tc1_p  \n" ;
          print ICT "       temp_tc2 $via_tc2_p \n" ;
        }

#N28_1_01        if ($multi_cco =~ /ZVT/i && $multi_cco !~ /NMOS/i && $multi_cco !~ /PMOS/i) {
#
#          $via_resist_n = sprintf("%.6g", $stack_hash{n_odCont}{RESIST});
#          if ($ircx_process_node =~/cbest/ && $ircx_process_node !~ /typical/){
#            @via_variation_info_n = split /\//,  $stack_hash{n_odCont}{VARIATION};
#            $via_resist_n = $via_resist_n + @via_variation_info_n[-1] ;
#          }
#          if ($ircx_process_node =~/cworst/ && $ircx_process_node !~ /typical/){
#            @via_variation_info_n = split /\//,  $stack_hash{n_odCont}{VARIATION};
#            $via_resist_n = $via_resist_n + @via_variation_info_n[-2] ;
#          }
#          print ICT "        area_resistance  $via_resist_n ", $stack_hash{n_odCont}{WIDTH}*$stack_hash{n_odCont}{LENGTH}," \n" ;
#          $via_tc1_n = sprintf("%.10f", $stack_hash{n_odCont}{TC1});
#          $via_tc2_n = sprintf("%.20f", $stack_hash{n_odCont}{TC2});
#          print ICT "       temp_tc1 $via_tc1_n  \n" ;
#          print ICT "       temp_tc2 $via_tc2_n \n" ;
#        }

        if ($multi_cco =~ /PA/i ) {
          $via_resist_p = sprintf("%.6g", $stack_hash{p_odCont}{RESIST});
          if ($ircx_process_node =~/cbest/ && $ircx_process_node !~ /typical/){
            @via_variation_info_p = split /\//,  $stack_hash{p_odCont}{VARIATION};
            $via_resist_p = $via_resist_p + @via_variation_info_p[-1] ;
          }

          if ($ircx_process_node =~/cworst/ && $ircx_process_node !~ /typical/){
            @via_variation_info_p = split /\//,  $stack_hash{p_odCont}{VARIATION};
            $via_resist_p = $via_resist_p + @via_variation_info_p[-2] ;
          }

          print ICT "        area_resistance  $via_resist_p ", $stack_hash{p_odCont}{WIDTH}*$stack_hash{p_odCont}{LENGTH}," \n" ;

          $odcont_tc1_ict_out =  $stack_hash{odCont}{TC1} ;
          if ( $stack_hash{odCont}{TC1} >= $stack_hash{n_odCont}{TC1}) {
            $odcont_tc1_ict_out =  $stack_hash{odCont}{TC1} ;
          } else {
            $odcont_tc1_ict_out =  $stack_hash{n_odCont}{TC1} ;
          }
          if ( $odcont_tc1_ict_out >=  $stack_hash{p_odCont}{TC1}) {
          } else {
            $odcont_tc1_ict_out =  $stack_hash{p_odCont}{TC1} ;
          }

          if ( $stack_hash{odCont}{TC2} < 0) {
            $odcont_tc2_ict_out =  $stack_hash{odCont}{TC2} ;
            if ( $stack_hash{odCont}{TC2} <= $stack_hash{n_odCont}{TC2}) {
              $odcont_tc2_ict_out =  $stack_hash{odCont}{TC2} ;
            } else {
              $odcont_tc2_ict_out =  $stack_hash{n_odCont}{TC2} ;
            }
            if ( $odcont_tc2_ict_out <=  $stack_hash{p_odCont}{TC2}) {
            } else {
              $odcont_tc2_ict_out =  $stack_hash{p_odCont}{TC2} ;
            }
          } else {
            $odcont_tc2_ict_out =  $stack_hash{odCont}{TC2} ;
            if ( $stack_hash{odCont}{TC2} >= $stack_hash{n_odCont}{TC2}) {
              $odcont_tc2_ict_out =  $stack_hash{odCont}{TC2} ;
            } else {
              $odcont_tc2_ict_out =  $stack_hash{n_odCont}{TC2} ;
            }
            if ( $odcont_tc2_ict_out >=  $stack_hash{p_odCont}{TC2}) {
            } else {
              $odcont_tc2_ict_out =  $stack_hash{p_odCont}{TC2} ;
            }

          }
          printf ICT "   temp_tc1 %.10f \n",$odcont_tc1_ict_out  ;
          printf ICT "   temp_tc2 %.20f \n",$odcont_tc2_ict_out  ;
        }
        if ($multi_cco =~ /NA/i ) {
          $via_resist_n = sprintf("%.6g", $stack_hash{n_odCont}{RESIST});
          if ($ircx_process_node =~/cbest/ && $ircx_process_node !~ /typical/){
            @via_variation_info_n = split /\//,  $stack_hash{n_odCont}{VARIATION};
            $via_resist_n = $via_resist_n + @via_variation_info_n[-1] ;
          }
          if ($ircx_process_node =~/cworst/ && $ircx_process_node !~ /typical/){
            @via_variation_info_n = split /\//,  $stack_hash{n_odCont}{VARIATION};
            $via_resist_n = $via_resist_n + @via_variation_info_n[-2] ;
          }
          print ICT "        area_resistance  $via_resist_n ", $stack_hash{n_odCont}{WIDTH}*$stack_hash{n_odCont}{LENGTH}," \n" ;

          $odcont_tc1_ict_out =  $stack_hash{odCont}{TC1} ;
          if ( $stack_hash{odCont}{TC1} >= $stack_hash{n_odCont}{TC1}) {
            $odcont_tc1_ict_out =  $stack_hash{odCont}{TC1} ;
          } else {
            $odcont_tc1_ict_out =  $stack_hash{n_odCont}{TC1} ;
          }
          if ( $odcont_tc1_ict_out >=  $stack_hash{p_odCont}{TC1}) {
          } else {
            $odcont_tc1_ict_out =  $stack_hash{p_odCont}{TC1} ;
          }

          if ( $stack_hash{odCont}{TC2} < 0) {
            $odcont_tc2_ict_out =  $stack_hash{odCont}{TC2} ;
            if ( $stack_hash{odCont}{TC2} <= $stack_hash{n_odCont}{TC2}) {
              $odcont_tc2_ict_out =  $stack_hash{odCont}{TC2} ;
            } else {
              $odcont_tc2_ict_out =  $stack_hash{n_odCont}{TC2} ;
            }
            if ( $odcont_tc2_ict_out <=  $stack_hash{p_odCont}{TC2}) {
            } else {
              $odcont_tc2_ict_out =  $stack_hash{p_odCont}{TC2} ;
            }
          } else {
            $odcont_tc2_ict_out =  $stack_hash{odCont}{TC2} ;
            if ( $stack_hash{odCont}{TC2} >= $stack_hash{n_odCont}{TC2}) {
              $odcont_tc2_ict_out =  $stack_hash{odCont}{TC2} ;
            } else {
              $odcont_tc2_ict_out =  $stack_hash{n_odCont}{TC2} ;
            }
            if ( $odcont_tc2_ict_out >=  $stack_hash{p_odCont}{TC2}) {
            } else {
              $odcont_tc2_ict_out =  $stack_hash{p_odCont}{TC2} ;
            }

          }
          printf ICT "   temp_tc1 %.10f \n",$odcont_tc1_ict_out  ;
          printf ICT "   temp_tc2 %.20f \n",$odcont_tc2_ict_out  ;
        }
      }
      print ICT "   via_edge_enlargement\n" ;
      print ICT "      vee_coco_spacings " ;

      for ($wef=1; $wef<=scalar @{ $manuf_table{$contact_table_name}{$contact_effect}{second_line}}-1;$wef++) {
        $vee_coco_value = $manuf_table{$contact_table_name}{$contact_effect}{second_line}[$wef] ;
        print ICT "$vee_coco_value " ;
      }
      print ICT "\n";

      print ICT "      vee_poco_spacings " ;
      for ($wef=1; $wef<=scalar @{ $manuf_table{$contact_table_name}{$contact_effect}{first_line}}-1;$wef++) {
        $vee_poco_value = $manuf_table{$contact_table_name}{$contact_effect}{first_line}[$wef] ;
        print ICT "$vee_poco_value " ;
      }
      print ICT "\n";

      print ICT "      vee_adjustments " ;
      for ($wef=1; $wef<=scalar @{ $manuf_table{$contact_table_name}{$contact_effect}{first_line}}-1;$wef++) {

        for ($sef=1; $sef<=scalar @{ $manuf_table{$contact_table_name}{$contact_effect}{second_line}}-1;$sef++) {


          $coco_index_value =  $manuf_table{$contact_table_name}{$contact_effect}{second_line}[$sef] ;
          $poco_index_value =  $manuf_table{$contact_table_name}{$contact_effect}{first_line}[$wef] ;

          $vee_adjust_value = -($manuf_table{$contact_table_name}{$contact_effect}{$coco_index_value}{$poco_index_value}) ;


          if (abs($vee_adjust_value) == 0.0000) {
            $vee_adjust_value = 0 ;

          }

          if ($vee_adjust_value =~ /^\+/) {

            $vee_adjust_value =~ s/^\+// ; 
          }
          print ICT "$vee_adjust_value " ;
        }
        print ICT "\n                      ";
      }
      print ICT "\n";
      if ($contact_effect =~ /^cco\_/i) {

        print ICT " } \n" ; 
      }

    }

  }

  &output_em_via("odCont") ;

  print ICT "}  \n" ;
}

for ($i=0;$i<=(scalar(@array_stack_via)-1);$i++) {


  if (@array_stack_via[$i] !~/Cont/i && @array_stack_via[$i] !~/dup/i && @array_stack_via[$i] !~ /via0/i && @array_stack_via[$i] !~ /tap/i ) {
    $uppercase_via_name = uc(@array_stack_via[$i]) ;
    if ($find_process_node < 40) {
      #$uppercase_via_name = @array_stack_via[$i] ;
      $upper_via_name = $stack_hash{@array_stack_via[$i]}{UPPER};
      if ($alrdl_present==1){
        $temp_array_conductor_name = $upper_via_name  ;
        $temp_array_conductor_name =~ s/\D+//i ;
        if ($temp_array_conductor_name > $max_metal_layer_number) {
          $uppercase_via_name = "RV" ;
        }
      }
    }
    print ICT "via \"$uppercase_via_name\" {\n" ;
    $upper_via_name = $stack_hash{@array_stack_via[$i]}{UPPER};
    $lower_via_name =$stack_hash{@array_stack_via[$i]}{LOWER} ;

    if ($find_process_node < 40) {
      $upper_via_name =~ s/metal/M/i ;
      if ($alrdl_present==1){
        $temp_array_conductor_name = $upper_via_name  ;
        $temp_array_conductor_name =~ s/\D+//i ;
        if ($temp_array_conductor_name > $max_metal_layer_number) {
          $upper_via_name = "AP" ;
        }
      }
      $lower_via_name = uc($lower_via_name);
      $lower_via_name =~ s/metal/M/i ;

    }

    print ICT "   top_layer     \"$upper_via_name\"\n" ;
    print ICT "   bottom_layer  \"$lower_via_name\"\n" ;

    if (exists $stack_hash{@array_stack_via[$i]}{AREA} ) {

      print ICT "   area_resistance ";
      foreach $area_via_value ( sort keys(%{$stack_hash{@array_stack_via[$i]}{AREA}}))  {

        $via_resist_value = $stack_hash{@array_stack_via[$i]}{AREA}{$area_via_value}{RESIST} ;

        if ($ircx_process_node =~/cbest/i && $ircx_process_node !~ /typical/ && $find_process_node <= 65){

          $via_resist_value = $via_resist_value + $stack_hash{@array_stack_via[$i]}{AREA}{$area_via_value}{VARIATION_CBEST} ;
        }
        if ($ircx_process_node =~/cworst/i && $ircx_process_node !~ /typical/ && $find_process_node <= 65){
          $via_resist_value = $via_resist_value + $stack_hash{@array_stack_via[$i]}{AREA}{$area_via_value}{VARIATION_CWORST} ;

        }

        print ICT " $via_resist_value  $area_via_value" ;


      }
      print ICT "\n";
    } else {

      $via_resist = $stack_hash{@array_stack_via[$i]}{RESIST} ; 
      if ($ircx_process_node =~/cbest/i && $ircx_process_node !~ /typical/ && $find_process_node <= 65){ 
        @via_variation_info = split /\//,  $stack_hash{@array_stack_via[$i]}{VARIATION} ;
        $via_resist = $via_resist + @via_variation_info[-1] ;
      }

      if ($ircx_process_node =~/cworst/i && $ircx_process_node !~ /typical/ && $find_process_node <= 65){
        @via_variation_info = split /\//,  $stack_hash{@array_stack_via[$i]}{VARIATION} ;
        $via_resist = $via_resist + @via_variation_info[-2] ;
      }
      print ICT "   area_resistance  $via_resist ", $stack_hash{@array_stack_via[$i]}{WIDTH}*$stack_hash{@array_stack_via[$i]}{LENGTH}," \n" ;
    }

    if ($find_process_node >= 40 ) {
      $via_tc1 = sprintf("%.10f", $stack_hash{@array_stack_via[$i]}{TC1});
      $via_tc2 = sprintf("%.20f", $stack_hash{@array_stack_via[$i]}{TC2});
      print ICT "   temp_tc1 $via_tc1  \n" ;
      print ICT "   temp_tc2 $via_tc2  \n" ;
      if (($find_process_node == 65) || ($find_process_node == 55) ) {
        print ICT "   min_top_encl 0.00 \n" ;
        print ICT "   min_bot_encl 0.01 \n" ;
        print ICT "   min_width   $stack_hash{@array_stack_via[$i]}{WIDTH} \n";
        print ICT "   min_spacing   $stack_hash{@array_stack_via[$i]}{SPACE} \n";

      } 
      if ($uppercase_via_name =~ /TSV/){
        print ICT "   min_width   $stack_hash{@array_stack_via[$i]}{WIDTH} \n";
        print ICT "   min_spacing   $stack_hash{@array_stack_via[$i]}{SPACE} \n";
        print ICT "   $tsv\n";
      }

    }

    if ($find_process_node < 40 ) {
      print ICT "   min_top_encl 0.00 \n" ;
      print ICT "   min_bot_encl 0.01 \n" ;
      if (exists $stack_hash{@array_stack_via[$i]}{WIDTH_ARRAY} ) {

        @max_width_array_value = sort(@{$stack_hash{@array_stack_via[$i]}{WIDTH_ARRAY}}) ;
        print ICT "   min_width @max_width_array_value[0]  \n" ;

      } else {
        print ICT "   min_width  $stack_hash{@array_stack_via[$i]}{WIDTH} \n" ;
      }
      if (exists $stack_hash{@array_stack_via[$i]}{SPACE_ARRAY} ) {

        @max_space_array_value = sort(@{$stack_hash{@array_stack_via[$i]}{SPACE_ARRAY}}) ;
        print ICT "   min_spacing @max_space_array_value[0]  \n" ;

      } else {
        print ICT "   min_spacing  $stack_hash{@array_stack_via[$i]}{SPACE} \n" ;
      }



      if (exists $stack_hash{@array_stack_via[$i]}{AREA} ) {
        $via_not_match_tc1 = 0 ; 
        $via_not_match_tc2 = 0 ;
        @via_area_array_tc1 =  keys(%{$stack_hash{@array_stack_via[$i]}{AREA}});
        @via_area_array_tc2 =  keys(%{$stack_hash{@array_stack_via[$i]}{AREA}});
        for ($av=0;$av<=scalar(@via_area_array_tc1)-1;$av++){

          #print " The area avv is $av \n" ; 
          $area_via_value = @via_area_array_tc1[$av] ;

          #print " The area via value is $area_via_value \n" ; 

          if ($av == 0) {
            $via_tc1_prev = $stack_hash{@array_stack_via[$i]}{AREA}{$area_via_value}{TC1} ;


          } else {

            if ( $stack_hash{@array_stack_via[$i]}{AREA}{$area_via_value}{TC1} != $via_tc1_prev) {

              $via_not_match_tc1 = 1 ;
              $via_tc1_prev = $stack_hash{@array_stack_via[$i]}{AREA}{$area_via_value}{TC1} ;
            }
            $via_tc1_prev = $stack_hash{@array_stack_via[$i]}{AREA}{$area_via_value}{TC1} ;
          }
        }


        for ($av=0;$av<=scalar(@via_area_array_tc2)-1;$av++){

          #print " The area avv is $av \n" ; 
          $area_via_value = @via_area_array_tc2[$av] ;

          #print " The area via value is $area_via_value \n" ; 

          if ($av == 0) {
            $via_tc2_prev = $stack_hash{@array_stack_via[$i]}{AREA}{$area_via_value}{TC2} ;
          } else {

            if ( $stack_hash{@array_stack_via[$i]}{AREA}{$area_via_value}{TC2} != $via_tc2_prev) {

              $via_not_match_tc2 = 1 ;
              $via_tc2_prev = $stack_hash{@array_stack_via[$i]}{AREA}{$area_via_value}{TC2} ;
            }
            $via_tc2_prev = $stack_hash{@array_stack_via[$i]}{AREA}{$area_via_value}{TC2} ;
          }
        }




        if ($via_not_match_tc1 == 1 && $via_not_match_tc2 == 1 ) {
          print ICT "   area_dependent_tc \n" ;
          print ICT "     temp_areas " ;
          foreach $area_via_value ( sort keys(%{$stack_hash{@array_stack_via[$i]}{AREA}}))  {

            print ICT " $area_via_value ";  
          }
          print ICT " \n     temp_tc1 ";

          foreach $area_via_value ( sort keys(%{$stack_hash{@array_stack_via[$i]}{AREA}}))  {

            $via_tc1 =  sprintf("%.10f", $stack_hash{@array_stack_via[$i]}{AREA}{$area_via_value}{TC1}) ;
            print ICT " $via_tc1 ";  
          }
          print ICT " \n     temp_tc2 ";
          foreach $area_via_value ( sort keys(%{$stack_hash{@array_stack_via[$i]}{AREA}}))  {

            $via_tc2 =  sprintf("%.10f", $stack_hash{@array_stack_via[$i]}{AREA}{$area_via_value}{TC2}) ;
            print ICT "$via_tc2  ";  
          }
          print ICT " \n" ; 
        } else {
          $via_tc1 = sprintf("%.10f", $stack_hash{@array_stack_via[$i]}{TC1});
          $via_tc2 = sprintf("%.20f", $stack_hash{@array_stack_via[$i]}{TC2});
          print ICT "   temp_tc1 $via_tc1  \n" ;
          print ICT "   temp_tc2 $via_tc2  \n" ;

        }
      } else {

        $via_tc1 = sprintf("%.10f", $stack_hash{@array_stack_via[$i]}{TC1});
        $via_tc2 = sprintf("%.20f", $stack_hash{@array_stack_via[$i]}{TC2});
        print ICT "   temp_tc1 $via_tc1  \n" ;
        print ICT "   temp_tc2 $via_tc2  \n" ;
      }

      #$via_tc1 = sprintf("%.10f", $stack_hash{@array_stack_via[$i]}{TC1});
      #$via_tc2 = sprintf("%.20f", $stack_hash{@array_stack_via[$i]}{TC2});
      #$via_tc1_L = sprintf("%.10f", $stack_hash{@array_stack_via[$i]}{TC1_L});
      #$via_tc2_L = sprintf("%.20f", $stack_hash{@array_stack_via[$i]}{TC2_L});

      if (exists $stack_hash{@array_stack_via[$i]}{AREA} ) {
        if ($stack_hash{@array_stack_via[$i]}{EFFECTIVE_WIDTH} !~ /N\/A/i ) {

          print ICT "   slot_via_long_edge ";
          foreach $area_via_value ( sort keys(%{$stack_hash{@array_stack_via[$i]}{AREA}}))  {

            $via_long =  sprintf("%.5f", $stack_hash{@array_stack_via[$i]}{AREA}{$area_via_value}{LENGTH}) ;
            print ICT " $via_long ";

          }
          print ICT "  \n";
          print ICT "   slot_via_short_edge ";
          foreach $area_via_value ( sort keys(%{$stack_hash{@array_stack_via[$i]}{AREA}}))  {

            $via_short =  sprintf("%.5f", $stack_hash{@array_stack_via[$i]}{AREA}{$area_via_value}{WIDTH}) ;
            print ICT " $via_short ";

          }
          print ICT "  \n";
          print ICT "   slot_via_long_edge_enlargement ";
          foreach $area_via_value ( sort keys(%{$stack_hash{@array_stack_via[$i]}{AREA}}))  {

            $via_l_enlarge =  sprintf("%.5f", ($stack_hash{@array_stack_via[$i]}{AREA}{$area_via_value}{EFFECTIVE_LENGTH}-$stack_hash{@array_stack_via[$i]}{AREA}{$area_via_value}{LENGTH})/2) ;
            print ICT " $via_l_enlarge ";

          }
          print ICT "  \n";
          print ICT "   slot_via_short_edge_enlargement ";
          foreach $area_via_value ( sort keys(%{$stack_hash{@array_stack_via[$i]}{AREA}}))  {

            $via_s_enlarge =  sprintf("%.5f", ($stack_hash{@array_stack_via[$i]}{AREA}{$area_via_value}{EFFECTIVE_WIDTH}-$stack_hash{@array_stack_via[$i]}{AREA}{$area_via_value}{WIDTH})/2) ;
            print ICT " $via_s_enlarge ";

          }
          print ICT "  \n";
        }
      }
    }

    &output_em_via($array_stack_via[$i]) ;

    print ICT "}  \n" ;

  }
}
if (!$em_write_flag){
  if ($La_flag == 1 && (!exists($em_value_flag{"La"}))){
    print "Warning! La is not declared as a variable but used in EQU ...... in od2 layer in iRCX file.\n";
  }
}
printf "\nICT Conversion complete, please check ICT file: \"%s\"\n",$ict_file;
exit;

sub conductor_manuf_info {
  my ($my_start) = $_[0]   ;
  my ($my_end) = $_[1]   ;
  my @info_ircx = @{$_[2]} ;
  my ($my_manuf)= $_[3] ;
#Base on DRM 0.5 iRCX delivered after mid-Aug 2012, change INDIE_TABLE[poly] to INDIE_TABLE[fpoly]
  $my_manuf =~ s/\[fpoly\]/\[poly\]/;
  $m_gate = 0 ; 
  $tsv_layer =0 ;
  $zero_flag = 0 ;
  $check_zero = 0;
  $DPT_flag = 0;

  $manuf_line_number = 0;
  @manuf_line_info =();
  @manuf_first_line =();
  @manuf_second_line =();
  @manuf_type_arr =();

  for ($iyi=$my_start;$iyi<=$my_end;$iyi++) {
    if ($info_ircx[$iyi] =~ /NO_OF_SPACE_DEPENDENT_COEFFICIENT_TABLE\s*:=\s*(\d+)/){
      $DPT_flag = $1;
    }
    if ($my_manuf =~ /tsv_circuit/){
      $tsv_layer = 1 ;
      if ( @info_ircx[$iyi] =~ /}/ ){
        $bracket_var_notused = 0 ;
        last;
      }
    }
    if ( $tsv_layer == 1 && @info_ircx[$iyi] !~ /}/ ) {
      if (@info_ircx[$iyi] !~ /{/) {
        $tsv .= @info_ircx[$iyi] ;
      }
    }else{

      if ($iyi > $my_start+1 && @info_ircx[$iyi] =~ /{/ ) {
        #print "TEST 3 : @info_ircx[$iyi]\n";
        @bracket_array = split /\s+/,,@info_ircx[$iyi];

        $bracket_var = @bracket_array[0] ;
        #print " The bracket array is $bracket_var \n";


        $bracket_var =~ s/\[//g ;
        $bracket_var =~ s/\]//g ;
        $bracket_var_notused = 1 ;
        if ($DPT_flag > 0){
          $bracket_var = 'DPT_'.$bracket_var;
        }


      }

      if ($iyi > $my_start+1 && @info_ircx[$iyi] =~ /}/ ) {
        $bracket_var_notused = 0 ;
        $DPT_flag--;
      }

      if (@info_ircx[$iyi] =~/CONDITION/){
        @condition_array = split /\s+/,@info_ircx[$iyi];
        if ($DPT_flag > 0){
          @condition_dpt = split /:=\s*/,$info_ircx[$iyi];
          $manuf_table{$my_manuf}{"FACTOR_$bracket_var"}{CONDITION} = $condition_dpt[-1];
        }else{
          $manuf_table{$my_manuf}{CONDITION} = @condition_array[-1];
        }
      }

      if (@info_ircx[$iyi] =~/EQUATION/ && $DPT_flag > 0){
        @equation_dpt = split /=\s*/,$info_ircx[$iyi];
        $manuf_table{$my_manuf}{"FACTOR_$bracket_var"}{EQUATION} = $equation_dpt[-1];
      }


      if (@info_ircx[$iyi] =~/\*\s*\w*\s*/ && @info_ircx[$iyi]=~/:\s*V/ ) {
        #print "TEST 4 @info_ircx[$iyi]\n";
        $manuf_line = @info_ircx[$iyi] ;
        $manuf_line_number = $iyi ;
        $m_gate = 1 ; 
        @manuf_line_info =split /\s+/, $manuf_line ;
        $manuf_type_flag = 1 ;
        foreach $manuf_type_name (@manuf_type_arr) {
          if ( $manuf_line_info[1] eq  $manuf_type_name){
            $manuf_type = @manuf_line_info[1]."2" ;
            push @manuf_type_arr,$manuf_type ;
            $manuf_type_flag = 0 ;
          }
        } 
        if ($manuf_type_flag == 0){
        } else {
          $manuf_type = @manuf_line_info[1] ;

          if ( $bracket_var_notused == 1 ) {

            $manuf_type = $manuf_type."_".$bracket_var ;

          } 

          push @manuf_type_arr,$manuf_type ;
          $manuf_table{$my_manuf}{manuf_type_arr} = [ @manuf_type_arr ] ;
        }

        $manuf_row = @manuf_line_info[2] ;
        $manuf_col = @manuf_line_info[3] ;
        #print "TEST 4 $manuf_row\n";
        #print "TEST 4 $manuf_col\n";
        $manuf_table{$my_manuf}{$manuf_type}{manuf_row} = $manuf_row ;
        $manuf_table{$my_manuf}{$manuf_type}{manuf_col} = $manuf_col ;
      }

      if ($iyi ==  $manuf_line_number+1 && $m_gate == 1 ) {
        @manuf_first_line = split /\s+/, @info_ircx[$iyi] ;
        $manuf_table{$my_manuf}{$manuf_type}{first_line} = [ @manuf_first_line ] ;
      }
      if ($iyi ==  $manuf_line_number+2 && $m_gate == 1 ) {
        @manuf_second_line = split /\s+/, @info_ircx[$iyi] ;
      }
      @manuf_effect_line =();
      if ($iyi <=  $manuf_line_number+$manuf_row+2 && $m_gate == 1 && $iyi >  $manuf_line_number+2 ) {
        @manuf_effect_line = split /\s+/, @info_ircx[$iyi] ;
        push @manuf_second_line,@manuf_effect_line[0];
        for ($mel =1;$mel<=scalar(@manuf_effect_line)-1;$mel++){
          $manuf_table{$my_manuf}{$manuf_type}{@manuf_effect_line[0]}{@manuf_first_line[$mel]} = @manuf_effect_line[$mel] ;
          if ($manuf_type =~ /width/i){
            $manuf_name = $my_manuf ;
            $manuf_name =~ s/INDIE\_TABLE\[//g;
            $manuf_name =~ s/\]//g;
            if ($manuf_name eq "poly"){
              $manuf_name = "fpoly";
            }
            $check_zero = sprintf("%.4f",abs(@manuf_effect_line[$mel] -   @manuf_effect_line[0] - $stack_hash{$manuf_name}{BIAS})); 
            #if ($manuf_name =~ /metal0/){
            #print "name :$manuf_name\n";
            #print " 1. @manuf_effect_line[$mel]\n";
            #print " 2. @manuf_effect_line[0]\n";
            #print " 3. $my_manuf $stack_hash{$manuf_name}{RHO}\n";
            #print " 4. $check_zero\n";
            #}
          }else{ 
            $check_zero = @manuf_effect_line[$mel] ; 
          }
          if (abs($check_zero) > 0 ){ 
            $zero_flag = 1;
          }

        }
      }
      $manuf_table{$my_manuf}{$manuf_type}{second_line} = [@manuf_second_line] ;
      $manuf_table{$my_manuf}{$manuf_type}{zero_flag} = $zero_flag ;
    }
  }
}

sub conductor_manuf {
  my ($get_manuf) = $_[0]   ;
  my @my_ircx = @{$_[1]} ;
  #	print "TEST : $get_manuf\n ";

  $get_manuf=~s/\_/\\\_/g ;
  $get_manuf=~s/\[/\\\[/g ;
  $get_manuf=~s/\]/\\\]/g ;

  %stack_hash_get_manuf =() ;

  $my_ircx_file_length =scalar(@my_ircx);

  $brace_count = 0;
  $manuf_start_line =0 ;
  $close_brace_count =0;
  $my_k = 0 ;
  $my_b = 0 ;
  for ($myi=0;$myi<=$my_ircx_file_length;$myi++) {
    if (@my_ircx[$myi] =~/\s*$get_manuf\s*\{/) {
      $manuf_start_line = $myi ; 
      $brace_count = 1 ;
      $my_k=1;
    }


    if ( $my_b == 1 ) {
      if  ( @my_ircx[$myi] =~ /INDIE/i  ||  @my_ircx[$myi] =~ /LOADING/i  ||  @my_ircx[$myi] =~ /CONTACT/i  ||  @my_ircx[$myi] =~ /EM\s*INFORMATION/i    ) {
        #print " I reach here man \n" ;
        last ; 

      } 
    }

    if ( $my_k == 1  &&  $myi > $manuf_start_line && @my_ircx[$myi] =~/\{/ ) {
      $brace_count = $brace_count + 1 ;
      $my_b = 0 ;
    }

    if ( $my_k == 1  && @my_ircx[$myi] =~/\}/ ) {
      $close_brace_count = $close_brace_count + 1 ;
      if ($close_brace_count == $brace_count) {
        $manuf_end_line = $myi ;
        $my_b = 1 ;
        #     print " I reach here man $get_manuf \n" ;
      }
    }



  }
  #print " I reach here man $get_manuf $manuf_start_line $manuf_end_line \n";
  conductor_manuf_info($manuf_start_line,$manuf_end_line,\@my_ircx,$_[0]) ;
}

#sub floating_floor {
#  my ($my_value) = $_[0]   ;

#$my_value = sprintf("%.6f",$my_value ) ;
#$my_value = substr($my_value , 0 , -2) ;

#return $my_value ; 

#}

sub output_em_conductor {
  if (!$em_write_flag) {
    $em_print_flag = 0 ;
    $epf = 0 ;
    #$peak_count = 0 ; 
    $rms_count = 0 ;
    #avoid printing empty em_model
    $em_empty_count = 0;
    my $ind_name = $_[0];
    if (exists $em_equivalent_layer{$array_stack[$i]}){
      $ind_name = $em_equivalent_layer{$array_stack[$i]};
    }
    foreach $em_effect (@em_effect_hash_array) {
      #print "@array_stack[$i] $em_effect\n" ;
      if ($find_process_node == 180 && $em_effect eq "RMS"){
        if ($epf == (scalar(@em_effect_hash_array)-1) && $em_print_flag == 1 ){
          print ICT "   } \n"; 
        }
        $epf=$epf+1 ;
        next;
      }
      foreach (keys(%{$em_hash{$em_effect}{$ind_name}})) {
        $em_empty_count++;
      }

###### debugging purpose by Grant
       if ($my_debug) {
        print ICT "my test1 : $ind_name\n";
        print ICT "my test2 : $em_equivalent_layer{$array_stack[$i]}\n";
       }
######
      if (exists $em_hash{$em_effect}{$ind_name} && $em_empty_count > 2) {
        if ($em_print_flag == 0){ print ICT "   em_model {\n" ; $em_print_flag = 1 ; }
        $order_eval = 0 ; $order_mode = "polynomial" ;
        %em_output_string = (); $em_condition_1 = "0"; %em_polynomial = () ;
        @em_condition_2 = "0"; %em_length = () ;

        for ($iem=1;$iem<= $em_hash{$em_effect}{$ind_name}{NO_OF_POLYNOMIAL_TABLE};$iem++){
          $em_condition_3 = '';
          $polynomial_word = "POLYNOMIAL".$iem ;
          $condition_word = "CONDITION".$iem ;
          $factor_word =  "FACTOR".$iem ;
          $em_polynomial{$iem} =  $em_hash{$em_effect}{$ind_name}{$polynomial_word} ;
          if ($em_polynomial{$iem} =~ /La/){
            $La_flag = 1;
          }
          $em_polynomial{$iem} =~ s/mA\/um/\* w/g;
          $em_condition = $em_hash{$em_effect}{$ind_name}{$condition_word} ;
 ##add by echo for CCR1199834
          if ($process_node=~m/N16/ && $process_ver_number >=1.0 ) {
          $em_condition =~ s/Power_Grid/power_rail W >= $power_rail_min W <= $power_rail_max Lv2v <= $power_rail_pitch /; }
            elsif ($process_node=~m/N20/ && $process_ver_number >1.1 ) {
          $em_condition =~ s/Power_Grid/power_rail W >= $power_rail_min W <= $power_rail_max Lv2v <= $power_rail_pitch /; } 
           elsif ($process_node=~m/N10/ ) {
          $em_condition =~ s/Power_Grid/power_rail W >= $power_rail_min W <= $power_rail_max Lv2v <= $power_rail_pitch /; }
           else { $em_condition =~ s/Power_Grid/power_rail W >= $power_rail_min W <= $power_rail_max Lv2v <= $power_rail_pitch Itolerance <= 0.05/; }
 ##add end by echo for CCR1199834
          @em_first_array = @{$em_hash{$em_effect}{$ind_name}{$factor_word}{first_line}} ;
          @em_second_array = @{$em_hash{$em_effect}{$ind_name}{$factor_word}{second_line}} ;

          if ($em_polynomial{$iem} =~ /^[+-]?[0-9]*\.?[0-9]+$/){
            $em_output_string{$iem} = "$em_polynomial{$iem}";
          } else {
            for ($esa=0;$esa<=scalar(@em_second_array)-1;$esa++){
              for ($efa=1;$efa<=scalar(@em_first_array)-1;$efa++){
                $first_pointer = $em_hash{$em_effect}{$ind_name}{$factor_word}{first_line}[$efa];
                $second_pointer = $em_hash{$em_effect}{$ind_name}{$factor_word}{second_line}[$esa];
                $em_polynomial{$iem} =~ s/@em_first_array[$efa]/$em_hash{$em_effect}{$ind_name}{$factor_word}{$second_pointer}{$first_pointer}/ ;
              }
            }
            $em_output_string{$iem} = "EQU $em_polynomial{$iem}";
          }
          #print ICT "Debug Poly: $em_output_string{$iem}\n" ;

          if (exists $em_hash{$em_effect}{$ind_name}{RATING_FACTOR}){
            @rating_first_array = @{$em_hash{$em_effect}{$ind_name}{RATING_FACTOR}{first_line}} ;
            @rating_second_array = @{$em_hash{$em_effect}{$ind_name}{RATING_FACTOR}{second_line}} ;

            $em_output_string{$iem} = join " ", $em_output_string{$iem}, "jmax_factor" ;
            for ($esa=0;$esa<=scalar(@rating_second_array)-1;$esa++){
              for ($efa=1;$efa<=scalar(@rating_first_array)-1;$efa++){
                $first_pointer = $em_hash{$em_effect}{$ind_name}{RATING_FACTOR}{first_line}[$efa];
                $second_pointer = $em_hash{$em_effect}{$ind_name}{RATING_FACTOR}{second_line}[$esa];
                if ( $em_hash{$em_effect}{$ind_name}{RATING_FACTOR}{$second_pointer}{$first_pointer} !~ /N\/A/i  ){
                  $em_output_string{$iem} = join " ", $em_output_string{$iem}, $first_pointer, $em_hash{$em_effect}{$ind_name}{RATING_FACTOR}{$second_pointer}{$first_pointer};
                }
              }
            }
          }

          $em_condition =~ m/([a-z]+)/i ;
          $em_condition_1 = substr  $em_condition, index($em_condition, $1); 
          if($em_condition_1 =~ /AND/i) {$em_condition_1 =~ s/AND//; }
          if($em_condition_1 =~ /w/) {$em_condition_1 =~ s/w/W/; }
          @em_condition_2 = split('\s+',$em_condition_1) ;
          $em_condition_2 = split('\s+',$em_condition_1) ;
          for ($j = 0; $j < $em_condition_2; $j++) {
            if($em_condition_2[$j] eq "L") {
              $em_length{$iem}[0] = $iem;
              $em_length{$iem}[1] = $em_condition_2[$j+1]; #Capture sign
              $em_length{$iem}[2] = $em_condition_2[$j+2]; #Capture length value
              $order_eval = 1 ;
            }
          }
          #enhance to support L <= 4 and 4 >= L, 4 >= L > 2 and 2 < L <= 4
          @split_em_condition_3 = split('AND', $em_condition);
          for ($mi = 0; $mi <= $#split_em_condition_3; $mi++){
            $split_em_condition_3[$mi] =~ s/^\s+|\s+$//g;
            @local_em_3 = split('\s+',$split_em_condition_3[$mi]);
            if ($#local_em_3 == 2){
              #printf( "local_em_3 == 2: %s\n", $em_condition);
              if ($local_em_3[2] =~ /[wl]/i || $local_em_3[2] =~ /Td/i ) {
                $local_em_3_tmp = $local_em_3[0];
                $local_em_3[0] = $local_em_3[2];
                $local_em_3[2] = $local_em_3_tmp;
                if($local_em_3[1] eq ">="){
                  $local_em_3[1] = "<=";
                }elsif($local_em_3[1] eq ">"){
                  $local_em_3[1] = "<";
                }elsif($local_em_3[1] eq "<="){
                  $local_em_3[1] = ">=";
                }elsif($local_em_3[1] eq "<"){
                  $local_em_3[1] = ">";
                }
                $split_em_condition_3[$mi] = "$local_em_3[0] $local_em_3[1] $local_em_3[2]";
              }
            }elsif ($#local_em_3 == 4){
              #printf( "local_em_3 == 4: %s\n", $em_condition);
              if($local_em_3[1] eq ">="){
                $local_em_3[1] = "<=";
              }elsif($local_em_3[1] eq ">"){
                $local_em_3[1] = "<";
              }elsif($local_em_3[1] eq "<="){
                $local_em_3[1] = ">=";
              }elsif($local_em_3[1] eq "<"){
                $local_em_3[1] = ">";
              }
              $split_em_condition_3[$mi] = "$local_em_3[2] $local_em_3[1] $local_em_3[0] $local_em_3[2] $local_em_3[3] $local_em_3[4]";
            }
            $em_condition_3 = $em_condition_3." $split_em_condition_3[$mi]";
          }
          $em_condition_3 =~ s/w/W/g;
          $em_condition_3 =~ s/poWer/power/g;
          $em_condition_3 =~ s/^\s+//;
          $em_condition_3 =~ s/\s+/ /g;
          #$em_output_string{$iem} = join " ", $em_output_string{$iem}, $em_condition_1 ;
          $em_output_string{$iem} = join " ", $em_output_string{$iem}, $em_condition_3 ;
        }
        if ($em_effect =~ /DC/i && $order_eval){
          foreach $iem (sort keys (%em_polynomial)) {
            if($em_polynomial{$iem} =~ /L/i) { $order_mode = "length"; }
          }
          if($order_mode eq "polynomial") {
            foreach $iem (sort { $em_polynomial{$a} <=> $em_polynomial{$b} } keys (%em_polynomial)) {
              if (defined($em_output_string{$iem})){
                print ICT "      em_jmax_dc_avg $em_output_string{$iem}\n";
              }
            }
          }
          if($order_mode eq "length") {
            foreach $iem (sort keys(%em_length)) {
              #foreach $iem (sort { $em_length{$b}[2] <=> $em_length{$a}[2]} keys(%em_length)) {#}
              if (defined($em_output_string{$iem})){
                print ICT "      em_jmax_dc_avg $em_output_string{$iem}\n";
              }
            }
          }
        } else {
          for($ic=1;$ic<$iem;$ic++) {
            if ($em_effect =~ /DC/i) {
              if (defined($em_output_string{$ic})){
                print ICT "      em_jmax_dc_avg $em_output_string{$ic}\n";
              }
            }
          }
          my $Ipeak_Td_threshold = $em_hash{$em_effect}{PARAMS}{Ipeak_Td_threshold};
          my $r_upperBound = 0.05; # CCR1143863 hardcode set by TSMC
          my $eps = 1E-10;
          for($ic=1;$ic<$iem;$ic++) {
            # DC PEAK (AC PEAK must repeat below )
            if ($em_effect =~ /PEAK/i) {
              if (defined($em_output_string{$ic})) {
                print ICT "      em_jmax_dc_peak $em_output_string{$ic}";

                if ( defined( $Ipeak_Td_threshold ) ) {
                  my $TdVal = -1.0E0;
                  my $rVal = 1.0E10;
                  if ( $em_output_string{$ic} =~ m/Td\s*>=\s*(\S+)/ ) {
                     $TdVal = 1.0 * $1;
                  }
                  if ( $em_output_string{$ic} =~ m/r\s*<\s*(\S+)/ ) {
                     $rVal = 1.0 * $1;
                  }
                  if ( $TdVal > ($Ipeak_Td_threshold - $eps) ) {
                     print ICT " apply r = 1.0"; 
                     # COMMENT: Because of Td>=Ipeak_Td_threshold
                  }
                  if ( $r_upperBound > ($rVal - $eps) ) {
                     print ICT " apply r = $r_upperBound"; 
                     # COMMENT: Because of r < 0.05
                  }
                }
                if ( defined ( $em_hash{$em_effect}{PARAMS}{HI_RESISTANCE}{${ind_name}} ) ) {
                  print ICT "$em_hash{$em_effect}{PARAMS}{HI_RESISTANCE}{${ind_name}}";
                }
                print ICT "\n";
              }
            }
          }
          for($ic=1;$ic<$iem;$ic++) {
            # AC PEAK
            if ($em_effect =~ /PEAK/i) {
              if (defined($em_output_string{$ic})) {
                print ICT "      em_jmax_ac_peak $em_output_string{$ic}";

                if ( defined( $Ipeak_Td_threshold ) ) {
                  my $TdVal = -1.0E0;
                  my $rVal = 1.0E10;
                  if ( $em_output_string{$ic} =~ m/Td\s*>=\s*(\S+)/ ) {
                     $TdVal = 1.0 * $1;
                  }
                  if ( $em_output_string{$ic} =~ m/r\s*<\s*(\S+)/ ) {
                     $rVal = 1.0 * $1;
                  }
                  if ( $TdVal > ($Ipeak_Td_threshold - $eps) ) {
                     print ICT " apply r = 1.0"; 
                     # COMMENT: Because of Td>=Ipeak_Td_threshold
                  }
                  if ( $r_upperBound > ($rVal - $eps) ) {
                     print ICT " apply r = $r_upperBound"; 
                     # COMMENT: Because of r < 0.05
                  }
                }
                if ( defined ( $em_hash{$em_effect}{PARAMS}{HI_RESISTANCE}{${ind_name}} ) ) {
                  print ICT "$em_hash{$em_effect}{PARAMS}{HI_RESISTANCE}{${ind_name}}";
                }
                print ICT "\n";
              }
            }
          }
          for($ic=1;$ic<$iem;$ic++) {
            if ($em_effect =~ /RMS/i){
              if (defined($em_output_string{$ic})){
                print ICT "      em_jmax_dc_rms $em_output_string{$ic}\n";
                print ICT "      em_jmax_ac_rms $em_output_string{$ic}\n";
              }
            }
          }
        }
      }
      if ($epf == (scalar(@em_effect_hash_array)-1) && $em_print_flag == 1 ){ print ICT "   } \n"; }
      $epf=$epf+1 ;
    }
  }
}

sub output_em_conductor_m0 {
  if (!$em_write_flag) {
    $em_print_flag = 0 ;
    $epf = 0 ;
    #$peak_count = 0 ; 
    $rms_count = 0 ;
    #avoid printing empty em_model
    $em_empty_count = 0;
    my $ind_name = $_[0];
    if (exists $em_equivalent_layer{$ind_name}){
      $ind_name = $em_equivalent_layer{$ind_name};
    }
    foreach $em_effect (@em_effect_hash_array) {
      #print "@array_stack[$i] $em_effect\n" ;
      foreach (keys(%{$em_hash{$em_effect}{$ind_name}})) {
        $em_empty_count++;
      }
      if (exists $em_hash{$em_effect}{$ind_name} && $em_empty_count > 2) {
        if ($em_print_flag == 0){ print ICT "   em_model {\n" ; $em_print_flag = 1 ; }
        $order_eval = 0 ; $order_mode = "polynomial" ;
        %em_output_string = (); $em_condition_1 = "0"; %em_polynomial = () ;
        @em_condition_2 = "0"; %em_length = () ;

        for ($iem=1;$iem<= $em_hash{$em_effect}{$ind_name}{NO_OF_POLYNOMIAL_TABLE};$iem++){
          $em_condition_3 = '';
          $polynomial_word = "POLYNOMIAL".$iem ;
          $condition_word = "CONDITION".$iem ;
          $factor_word =  "FACTOR".$iem ;
          $em_polynomial{$iem} =  $em_hash{$em_effect}{$ind_name}{$polynomial_word} ;
          $em_condition = $em_hash{$em_effect}{$ind_name}{$condition_word} ;
          if ($em_polynomial{$iem} =~ /La/){
            $La_flag = 1;
          }
          if ($em_condition =~ /VERTICAL/){
            next;
          }else{
            $em_condition =~ s/\(|\)|(AND)*\s*\(*\s*HORIZONTAL\s*\)*//g;
          }

          @em_first_array = @{$em_hash{$em_effect}{$ind_name}{$factor_word}{first_line}} ;
          @em_second_array = @{$em_hash{$em_effect}{$ind_name}{$factor_word}{second_line}} ;

          if ($em_polynomial{$iem} =~ /^[+-]?[0-9]*\.?[0-9]+$/){
            $em_output_string{$iem} = "$em_polynomial{$iem}";
          } else {
            for ($esa=0;$esa<=scalar(@em_second_array)-1;$esa++){
              for ($efa=1;$efa<=scalar(@em_first_array)-1;$efa++){
                $first_pointer = $em_hash{$em_effect}{$ind_name}{$factor_word}{first_line}[$efa];
                $second_pointer = $em_hash{$em_effect}{$ind_name}{$factor_word}{second_line}[$esa];
                $em_polynomial{$iem} =~ s/@em_first_array[$efa]/$em_hash{$em_effect}{$ind_name}{$factor_word}{$second_pointer}{$first_pointer}/ ;
              }
            }
            $em_output_string{$iem} = "EQU $em_polynomial{$iem}";
          }
          #print ICT "Debug Poly: $em_output_string{$iem}\n" ;

          if (exists $em_hash{$em_effect}{$ind_name}{RATING_FACTOR}){
            @rating_first_array = @{$em_hash{$em_effect}{$ind_name}{RATING_FACTOR}{first_line}} ;
            @rating_second_array = @{$em_hash{$em_effect}{$ind_name}{RATING_FACTOR}{second_line}} ;

            $em_output_string{$iem} = join " ", $em_output_string{$iem}, "jmax_factor" ;
            for ($esa=0;$esa<=scalar(@rating_second_array)-1;$esa++){
              for ($efa=1;$efa<=scalar(@rating_first_array)-1;$efa++){
                $first_pointer = $em_hash{$em_effect}{$ind_name}{RATING_FACTOR}{first_line}[$efa];
                $second_pointer = $em_hash{$em_effect}{$ind_name}{RATING_FACTOR}{second_line}[$esa];
                if ( $em_hash{$em_effect}{$ind_name}{RATING_FACTOR}{$second_pointer}{$first_pointer} !~ /N\/A/i  ){
                  $em_output_string{$iem} = join " ", $em_output_string{$iem}, $first_pointer, $em_hash{$em_effect}{$ind_name}{RATING_FACTOR}{$second_pointer}{$first_pointer};
                }
              }
            }
          }

          $em_condition =~ m/([a-z]+)/i ;
          $em_condition_1 = substr  $em_condition, index($em_condition, $1); 
          if($em_condition_1 =~ /AND/i) {$em_condition_1 =~ s/AND//; }
          if($em_condition_1 =~ /w/) {$em_condition_1 =~ s/w/W/; }
          @em_condition_2 = split('\s+',$em_condition_1) ;
          $em_condition_2 = split('\s+',$em_condition_1) ;
          for ($j = 0; $j < $em_condition_2; $j++) {
            if($em_condition_2[$j] eq "L") {
              $em_length{$iem}[0] = $iem;
              $em_length{$iem}[1] = $em_condition_2[$j+1]; #Capture sign
              $em_length{$iem}[2] = $em_condition_2[$j+2]; #Capture length value
              $order_eval = 1 ;
            }
          }
          #enhance to support L <= 4 and 4 >= L, 4 >= L > 2 and 2 < L <= 4
          @split_em_condition_3 = split('AND', $em_condition);
          for ($mi = 0; $mi <= $#split_em_condition_3; $mi++){
            $split_em_condition_3[$mi] =~ s/^\s+|\s+$//g;
            @local_em_3 = split('\s+',$split_em_condition_3[$mi]);
            if ($#local_em_3 == 2){
              #printf( "local_em_3 == 2 also: %s\n", $em_condition);
              if ($local_em_3[2] =~ /[wl]/i || $local_em_3[2] =~ /Td/i ) {
                $local_em_3_tmp = $local_em_3[0];
                $local_em_3[0] = $local_em_3[2];
                $local_em_3[2] = $local_em_3_tmp;
                if($local_em_3[1] eq ">="){
                  $local_em_3[1] = "<=";
                }elsif($local_em_3[1] eq ">"){
                  $local_em_3[1] = "<";
                }elsif($local_em_3[1] eq "<="){
                  $local_em_3[1] = ">=";
                }elsif($local_em_3[1] eq "<"){
                  $local_em_3[1] = ">";
                }
                $split_em_condition_3[$mi] = "$local_em_3[0] $local_em_3[1] $local_em_3[2]";
              }
            }elsif ($#local_em_3 == 4){
              if($local_em_3[1] eq ">="){
                $local_em_3[1] = "<=";
              }elsif($local_em_3[1] eq ">"){
                $local_em_3[1] = "<";
              }elsif($local_em_3[1] eq "<="){
                $local_em_3[1] = ">=";
              }elsif($local_em_3[1] eq "<"){
                $local_em_3[1] = ">";
              }
              $split_em_condition_3[$mi] = "$local_em_3[2] $local_em_3[1] $local_em_3[0] $local_em_3[2] $local_em_3[3] $local_em_3[4]";
            }
            $em_condition_3 = $em_condition_3." $split_em_condition_3[$mi]";
          }
          $em_condition_3 =~ s/w/W/g;
          $em_condition_3 =~ s/^\s+//;
          $em_condition_3 =~ s/\s+/ /g;
          #$em_output_string{$iem} = join " ", $em_output_string{$iem}, $em_condition_1 ;
          $em_output_string{$iem} = join " ", $em_output_string{$iem}, $em_condition_3 ;
        }
        if ($em_effect =~ /DC/i && $order_eval){
          foreach $iem (sort keys (%em_polynomial)) {
            if($em_polynomial{$iem} =~ /L/i) { $order_mode = "length"; }
          }
          if($order_mode eq "polynomial") {
            foreach $iem (sort { $em_polynomial{$a} <=> $em_polynomial{$b} } keys (%em_polynomial)) {
              if (defined($em_output_string{$iem})){
                print ICT "      em_jmax_dc_avg $em_output_string{$iem}\n";
              }
            }
          }
          if($order_mode eq "length") {
            foreach $iem (sort keys(%em_length)) {
                if (defined($em_output_string{$iem})){
                #foreach $iem (sort { $em_length{$b}[2] <=> $em_length{$a}[2]} keys(%em_length)) {#}
                print ICT "      em_jmax_dc_avg $em_output_string{$iem}\n";
              }
            }
          }
        } else {
          for($ic=1;$ic<$iem;$ic++) {
            if ($em_effect =~ /DC/i) {
              if (defined($em_output_string{$ic})){
                print ICT "      em_jmax_dc_avg $em_output_string{$ic}\n";
              }
            }
          }

          my $Ipeak_Td_threshold = $em_hash{$em_effect}{PARAMS}{Ipeak_Td_threshold};
          my $r_upperBound = 0.05; # CCR1143863 hardcode set by TSMC
          my $eps = 1E-10;

          for($ic=1;$ic<$iem;$ic++) {
            # DC PEAK (AC PEAK must repeat below )
            if ($em_effect =~ /PEAK/i) {
              if (defined($em_output_string{$ic})) {
                print ICT "      em_jmax_dc_peak $em_output_string{$ic}";

                if ( defined( $Ipeak_Td_threshold ) ) {
                  my $TdVal = -1.0E0;
                  my $rVal = 1.0E10;
                  if ( $em_output_string{$ic} =~ m/Td\s*>=\s*(\S+)/ ) {
                     $TdVal = 1.0 * $1;
                  }
                  if ( $em_output_string{$ic} =~ m/r\s*<\s*(\S+)/ ) {
                     $rVal = 1.0 * $1;
                  }
                  if ( $TdVal > ($Ipeak_Td_threshold - $eps) ) {
                     print ICT " apply r = 1.0"; 
                     # COMMENT: Because of Td>=Ipeak_Td_threshold
                  }
                  if ( $r_upperBound > ($rVal - $eps) ) {
                     print ICT " apply r = $r_upperBound"; 
                     # COMMENT: Because of r < 0.05
                  }
                }
                if ( defined ( $em_hash{$em_effect}{PARAMS}{HI_RESISTANCE}{${ind_name}} ) ) {
                  print ICT "$em_hash{$em_effect}{PARAMS}{HI_RESISTANCE}{${ind_name}}";
                }
                print ICT "\n";
              }
            }
          }

          for($ic=1;$ic<$iem;$ic++) {
            # AC PEAK
            if ($em_effect =~ /PEAK/i) {
              if (defined($em_output_string{$ic})) {
                print ICT "      em_jmax_ac_peak $em_output_string{$ic}";

                if ( defined( $Ipeak_Td_threshold ) ) {
                  my $TdVal = -1.0E0;
                  my $rVal = 1.0E10;
                  if ( $em_output_string{$ic} =~ m/Td\s*>=\s*(\S+)/ ) {
                     $TdVal = 1.0 * $1;
                  }
                  if ( $em_output_string{$ic} =~ m/r\s*<\s*(\S+)/ ) {
                     $rVal = 1.0 * $1;
                  }
                  if ( $TdVal > ($Ipeak_Td_threshold - $eps) ) {
                     print ICT " apply r = 1.0"; 
                     # COMMENT: Because of Td>=Ipeak_Td_threshold
                  }
                  if ( $r_upperBound > ($rVal - $eps) ) {
                     print ICT " apply r = $r_upperBound"; 
                     # COMMENT: Because of r < 0.05
                  }
                }
                if ( defined ( $em_hash{$em_effect}{PARAMS}{HI_RESISTANCE}{${ind_name}} ) ) {
                  print ICT "$em_hash{$em_effect}{PARAMS}{HI_RESISTANCE}{${ind_name}}";
                }
                print ICT "\n";
              }
            }
          }

          for($ic=1;$ic<$iem;$ic++) {
            if ($em_effect =~ /RMS/i){
              if (defined($em_output_string{$ic})){
                print ICT "      em_jmax_dc_rms $em_output_string{$ic}\n";
                print ICT "      em_jmax_ac_rms $em_output_string{$ic}\n";
              }
            }
          }
        }
      }
      if ($epf == (scalar(@em_effect_hash_array)-1) && $em_print_flag == 1 ){ print ICT "   } \n"; }
      $epf=$epf+1 ;
    }
  }
}

sub output_em_via {
  if (!$em_write_flag){
    $em_print_flag = 0 ;
    $epf = 0 ; 
    #$peak_count = 0 ;
    $rms_count = 0 ;  
    $em_layer = $_[0];
    foreach $em_effect (@em_effect_hash_array) {

      if(($em_layer eq "podCont") || ($em_layer eq "nodCont") || ($em_layer eq "odCont")) {
        $em_via_layer = "odCont" ;
      } elsif ($em_layer eq "polyCont") {
        $em_via_layer = "polyCont";
      } else {
        #$em_via_layer = @array_stack_via[$i] ;
        $em_via_layer = $em_layer;
      }
      if (exists $em_equivalent_layer{$em_via_layer}){
        $em_via_layer = $em_equivalent_layer{$em_via_layer};
      }



      if (exists($stack_hash{$em_layer}{WIDTH})){
        $vcwidth = $stack_hash{$em_layer}{WIDTH} ;
      }else{
        $vcwidth = $em_vcwidth_ict;
      }
      $area_vcwidth = $vcwidth*$vcwidth ;
      if (exists $em_hash{$em_effect}{$em_via_layer}) {
        if ($em_print_flag == 0){
####Debugging purpose by Grant
##          print ICT "em_layer : $em_layer\n";
##          print ICT "em_via_layer : $em_via_layer\n";
##          print ICT "em_equivalent_layer : $em_equivalent_layer{$em_via_layer}\n";
#############
          print ICT "   em_model {\n" ;
          print ICT "      em_vcwidth $vcwidth\n";
          $em_print_flag = 1 ;
        }
        if ($em_effect =~ /DC/i){ $em_effect_word = "em_jmax_dc_avg" ; } 
        if ($em_effect =~ /PEAK/i){ $em_effect_word = "em_jmax_dc_peak" ; }
        if ($em_effect =~ /RMS/i){ $em_effect_word = "em_jmax_ac_rms" ; }
        $order_eval = 0 ; $emc = "0" ; $order_mode = "polynomial" ;
        %em_output_string = (); @em_condition_1 = 0; %em_polynomial = () ; %em_polynomial_eval = () ; @em_output_string_via = 0;
        @length_string = "0"; @width_string = "0"; @wv = 0; @lv = 0; @lu = "0"; @wu = "0"; @lb = "0"; @wb = "0";
        %em_condition_3 = () ; %length = () ; %width = () ;
        @em_condition_5 = ();

        for ($iem=1;$iem<= $em_hash{$em_effect}{$em_via_layer}{NO_OF_POLYNOMIAL_TABLE};$iem++){
          $polynomial_word = "POLYNOMIAL".$iem ;
          $condition_word = "CONDITION".$iem ;
          $factor_word =  "FACTOR".$iem ;
          $array_word =  "ARRAY".$iem ;
          $em_condition_flag = 0 ; 
          $power_grid = '';
          $em_polynomial{$iem} =  $em_hash{$em_effect}{$em_via_layer}{$polynomial_word} ;
          if ($em_polynomial{$iem} =~ /La/){
            $La_flag = 1;
          }
          if ($em_polynomial{$iem} =~ /^\d+$/){
#Po-Kai's request
            $em_polynomial{$iem} = sprintf("%.1f", $em_polynomial{$iem} );
          }
          $em_condition = $em_hash{$em_effect}{$em_via_layer}{$condition_word} ;
          if ($em_condition =~ /Power_Grid/){
            $power_grid = ' power_rail';
          }
          #support ARRAY syntax for N40 process above
          if (exists $em_hash{$em_effect}{$em_via_layer}{ARRAY}){
            $em_condition = "( Wv == $vcwidth AND Lv == $vcwidth ) AND ".$em_condition;
          }
          @em_first_array = @{$em_hash{$em_effect}{$em_via_layer}{$factor_word}{first_line}} ;
          @em_second_array = @{$em_hash{$em_effect}{$em_via_layer}{$factor_word}{second_line}} ;

          if ($em_polynomial{$iem} !~ /^[+-]?[0-9]*\.?[0-9]+$/){
            for ($esa=0;$esa<=scalar(@em_second_array)-1;$esa++){
              for ($efa=1;$efa<=scalar(@em_first_array)-1;$efa++){
                $first_pointer = $em_hash{$em_effect}{$em_via_layer}{$factor_word}{first_line}[$efa];
                $second_pointer = $em_hash{$em_effect}{$em_via_layer}{$factor_word}{second_line}[$esa];
                $em_polynomial{$iem} =~ s/@em_first_array[$efa]/$em_hash{$em_effect}{$em_via_layer}{$factor_word}{$second_pointer}{$first_pointer}/ ;
                if ($em_condition =~ /ARRAY/){
                  $em_array{$em_effect}{$em_via_layer}{$array_word} = $em_hash{$em_effect}{$em_via_layer}{$factor_word}{$second_pointer}{$first_pointer};
                }
              }
            }
            if($em_polynomial{$iem} !~ /L/i) {
              $em_polynomial_eval{$iem} = eval($em_polynomial{$iem}) ;
              $emtype = "pwl" ;
            } else {
              $emtype = "equ" ;
              $em_output_string{$iem} = "EQU $em_polynomial{$iem}";
            } 
          } else {
            $emtype = "num" ;
            $em_output_string{$iem} = "$em_polynomial{$iem}";
          }

          if (exists $em_hash{$em_effect}{$em_via_layer}{RATING_FACTOR}){
            @rating_first_array = @{$em_hash{$em_effect}{$em_via_layer}{RATING_FACTOR}{first_line}} ;
            @rating_second_array = @{$em_hash{$em_effect}{$em_via_layer}{RATING_FACTOR}{second_line}} ;
            $em_output_string_jmax[$iem] = "jmax_factor";
            for ($esa=0;$esa<=scalar(@rating_second_array)-1;$esa++){
              for ($efa=1;$efa<=scalar(@rating_first_array)-1;$efa++){
                $first_pointer = $em_hash{$em_effect}{$em_via_layer}{RATING_FACTOR}{first_line}[$efa];
                $second_pointer = $em_hash{$em_effect}{$em_via_layer}{RATING_FACTOR}{second_line}[$esa];
                if ( $em_hash{$em_effect}{$em_via_layer}{RATING_FACTOR}{$second_pointer}{$first_pointer} !~ /N\/A/i  ){
                  $em_output_string_jmax[$iem] = join " ", $em_output_string_jmax[$iem], $first_pointer, $em_hash{$em_effect}{$em_via_layer}{RATING_FACTOR}{$second_pointer}{$first_pointer} ;
                }
              }
            }
          }

          SWITCH : {
            if($em_condition =~ /L \=\=/){
              $order_eval = 0 ;
              $emtype = "pwl" ;
              $em_condition =~ m/(L \=\=)/i ;
              $em_condition_v1 = substr  $em_condition, index($em_condition, $1);
              @em_condition_v2 = split('\s+',$em_condition_v1) ;
              $em_condition_v2 = split('\s+',$em_condition_v1) ;
              for ($j = 0; $j < $em_condition_v2; $j++) {
                if($em_condition_v2[$j] eq "L") { $lv{$iem} = $em_condition_v2[$j+2] ; }
              }
#              $em_output_string_via[$iem] = $lv{$iem}*$lv{$iem} ;
              if ($lv{$iem}*$lv{$iem} =~ /\./){
                $em_output_string_via[$iem] =  $lv{$iem}*$lv{$iem} ;
              }else{
                $em_output_string_via[$iem] = sprintf("%.1f", $lv{$iem}*$lv{$iem} );
              }
              last SWITCH ;
            }

            if(($em_condition =~ /Lv \=\=/) && ($em_condition =~ /Wv \=\=/) && (($em_condition !~ /\(/) || ($em_condition !~ /\)/))) {
              $order_eval = 0 ;
              $emtype = "pwl" ;
              $em_condition =~ m/(Lv \=\=)/i ;
              $em_condition_v1 = substr  $em_condition, index($em_condition, $1);
              @em_condition_v2 = split('\s+',$em_condition_v1) ;
              $em_condition_v2 = split('\s+',$em_condition_v1) ;
              for ($j = 0; $j < $em_condition_v2; $j++) {
                if($em_condition_v2[$j] eq "Lv") { $lv{$iem} = $em_condition_v2[$j+2] ; }
                if($em_condition_v2[$j] eq "Wv") { $wv{$iem} = $em_condition_v2[$j+2] ; }
              }
#              $em_output_string_via[$iem] =  $lv{$iem}*$wv{$iem} ;
#Po-Kai's request
              if ($lv{$iem}*$wv{$iem} =~ /\./){
                $em_output_string_via[$iem] =  $lv{$iem}*$wv{$iem} ;
              }else{
                $em_output_string_via[$iem] = sprintf("%.1f", $lv{$iem}*$wv{$iem} );
              }
              last SWITCH ;
            }

            if(($em_condition !~ /Wv \=\=/) || ($em_condition !~ /Lv \=\=/)) {
              #if(($em_condition !~ /Wv \=\=/) || ($em_condition !~ /Lv \=\=/) && ($em_condition !~ /L \=\=/)) {#}
              $order_eval = 1 ;
              if($emtype ne "num") { $emtype = "equ"; }
              $em_condition =~ m/([a-z]+)/i ;
              $em_condition_1[$iem] = substr  $em_condition, index($em_condition, $1); 
              if($em_condition_1[$iem] =~ /AND/i) {$em_condition_1[$iem] =~ s/AND//; }
              if($em_condition_1[$iem] =~ /w/) {$em_condition_1[$iem] =~ s/w/W/; }
              @em_condition_2 = split('\s+',$em_condition_1[$iem]) ;
              $em_condition_2 = split('\s+',$em_condition_1[$iem]) ;
              for ($j = 0; $j < $em_condition_2; $j++) {
                if($em_condition_2[$j] eq "L") {
                  $length{$iem}[0] = $iem; 
                  $length{$iem}[1] = $em_condition_2[$j+1]; #Capture length sign
                  $length{$iem}[2] = $em_condition_2[$j+2]; #Capture length value
                }
                if($em_condition_2[$j] eq "W") {
                  $width{$iem}[0] = $iem;
                  $width{$iem}[1] = $em_condition_2[$j+1]; #Capture width sign
                  $width{$iem}[2] = $em_condition_2[$j+2]; #Capture width value
                }
              }
              last SWITCH ;
            }

            if(($em_condition =~ /Lv \=\=/) && ($em_condition =~ /Wv \=\=/) && ($em_condition =~ /\(/) && ($em_condition =~ /\)/)) {
              $current_stream = '';
              $order_eval = 2 ;
              $emtype = "pwl" ;
              #print ICT "$em_condition\n";
              $em_condition_orig[$iem] = $em_condition ;
              $em_condition_1[$iem] = substr  $em_condition, index($em_condition, $1); 
              @split_em_condition = split('\s+\(\s+\(\s+\(\s+|\s+\)\s+\)\s+OR\s+\(\s+\(\s+|\s+\)\s+AND\s+\(\s+|\s+AND\s+|\s+\)\s+\)\s+\)|\(\s+|\s+\)',$em_condition) ;
              $split_em_condition = split('\s+\(\s+\(\s+\(\s+|\s+\)\s+\)\s+OR\s+\(\s+\(\s+|\s+\)\s+AND\s+\(\s+|\s+AND\s+|\s+\)\s+\)\s+\)|\(\s+|\s+\)',$em_condition) ;
              #print ICT "$split_em_condition @split_em_condition\n" ;
              for ($j = 0; $j < $split_em_condition; $j++) {
                $split_em_condition[$j] =~ s/^\s+|\s+$//g;
                @local_em = split('\s+',$split_em_condition[$j]) ;
                $local_em = split('\s+',$split_em_condition[$j]) ;
                #print ICT "$split_em_condition[$k] $local_em @local_em\n";
                #enhance to support Lu <= 4 and 4 >= Lu, 4 >= Lb > 2 and 2 < Lb <= 4
                if ($local_em == 3){
                  if ($local_em[2] =~ /Wv|Lv|Wu|Lu|Wb|Lb/){
                    $local_em_tmp = $local_em[0];
                    $local_em[0] = $local_em[2];
                    $local_em[2] = $local_em_tmp;
                    if ($local_em[1] eq "<="){
                      $local_em[1] = ">=";
                    }elsif ($local_em[1] eq ">="){
                      $local_em[1] = "<=";
                    }elsif ($local_em[1] eq "<"){
                      $local_em[1] = ">";
                    }elsif ($local_em[1] eq ">"){
                      $local_em[1] = "<";
                    }
                  }
                }elsif ($local_em == 5){
                  if ($local_em[4] > $local_em[0]){
                    $local_em_tmp = $local_em[0];
                    $local_em[0] = $local_em[4];
                    $local_em[4] = $local_em_tmp;
                    $operation_tmp = $local_em[1];
                    if ($local_em[3] eq "<="){
                      $local_em[1] = ">=";
                    }elsif ($local_em[3] eq "<"){
                      $local_em[1] = ">";
                    }
                    if ($operation_tmp eq "<="){
                      $local_em[3] = ">=";
                    }elsif ($operation_tmp eq "<"){
                      $local_em[3] = ">";
                    }
                  }
                }
                for($k = 0; $k < $local_em; $k++) {
                  #print ICT "$local_em[$k] $local_em[$k+1] $local_em[$k+2]\n" ;
                  if(($local_em[$k] eq "Wv") && ($local_em[$k+1] eq "\=\=")) { $wv{$iem} = $local_em[$k+2] ; }
                  if(($local_em[$k] eq "Lv") && ($local_em[$k+1] eq "\=\=")) { $lv{$iem} = $local_em[$k+2] ; }
                  if($local_em == 3) {
                    $temp_string = join " ", $local_em[$k+1], $local_em[$k+2] ;
                    if($local_em[$k] eq "Lu") { $lu[$iem] = join " ", "L", $temp_string; }
                    if($local_em[$k] eq "Wu") { $wu[$iem] = join " ", "W", $temp_string; }
                    if($local_em[$k] eq "Lb") { $lb[$iem] = join " ", "L", $temp_string; }
                    if($local_em[$k] eq "Wb") { $wb[$iem] = join " ", "W", $temp_string; }
                    if($local_em[$k] eq "L") { 
                      $lb[$iem] = join " ", "L", $temp_string; 
                      $lu[$iem] = join " ", "L", $temp_string;
                    }
                    if($local_em[$k] eq "w" || $local_em[$k] eq "W") { 
                      $wb[$iem] = join " ", "W", $temp_string; 
                      $wu[$iem] = join " ", "W", $temp_string;
                    }
                  } elsif ($local_em == 5) {
                    SWITCH: {
                      if($local_em[$k-1] eq ">=") { $local_em[$k-1] = "<=" ; last SWITCH ; }
                      if($local_em[$k-1] eq ">") { $local_em[$k-1] = "<" ; last SWITCH ; }
                      if($local_em[$k-1] eq "<=") { $local_em[$k-1] = ">=" ; last SWITCH ; }
                      if($local_em[$k-1] eq "<") { $local_em[$k-1] = ">" ; last SWITCH ; }
                    }
                    #$temp_string_1 = join " ", $local_em[$k-2], $local_em[$k-1] ;
                    $temp_string_1 = join " ", $local_em[$k-1], $local_em[$k-2] ;
                    $temp_string_2 = join " ", $local_em[$k+1], $local_em[$k+2] ;
                    #if($local_em[$k] eq "Lu") { $lu[$iem] = join " ", $temp_string_1, "L", $temp_string_2 ; }
                    #if($local_em[$k] eq "Wu") { $wu[$iem] = join " ", $temp_string_1, "W", $temp_string_2 ; }
                    #if($local_em[$k] eq "Lb") { $lb[$iem] = join " ", $temp_string_1, "L", $temp_string_2 ; }
                    #if($local_em[$k] eq "Wb") { $wb[$iem] = join " ", $temp_string_1, "W", $temp_string_2 ; }
                    if($local_em[$k] eq "Lu") { $lu[$iem] = join " ", "L", $temp_string_1, "L", $temp_string_2 ; }
                    if($local_em[$k] eq "Wu") { $wu[$iem] = join " ", "W", $temp_string_1, "W", $temp_string_2 ; }
                    if($local_em[$k] eq "Lb") { $lb[$iem] = join " ", "L", $temp_string_1, "L", $temp_string_2 ; }
                    if($local_em[$k] eq "Wb") { $wb[$iem] = join " ", "W", $temp_string_1, "W", $temp_string_2 ; }
                    if($local_em[$k] eq "L") { 
                      $lb[$iem] = join " ", "L", $temp_string_1, "L", $temp_string_2; 
                      $lu[$iem] = join " ", "L", $temp_string_1, "L", $temp_string_2; 
                    }
                    if($local_em[$k] eq "w" || $local_em[$k] eq "W") { 
                      $wb[$iem] = join " ", "W", $temp_string_1, "W", $temp_string_2; 
                      $wu[$iem] = join " ", "W", $temp_string_1, "W", $temp_string_2; 
                    }
                  }
                }
              }
              $area_wvlv =  $wv{$iem}*$lv{$iem} ;
              if ($area_wvlv !~ /\./){
                $em_output_string_via[$iem] = sprintf("%.1f", $lv{$iem}*$wv{$iem} );
              }
              $lcombo = 0; $wcombo = 0;
              if ($em_condition =~ /UPSTREAM/){
                $current_stream = ' current_direction down';
              }elsif ($em_condition =~ /DOWNSTREAM/){
                $current_stream = ' current_direction up';
              }
              if($em_condition =~ /NOT/) {
                $emc = "NOT" ;
              } else {
                #if($wu[$iem] && !$wb[$iem]) {
                #  $length_string[$iem] = $lu[$iem] ;
                #  $width_string[$iem] = $wu[$iem] ;
                #} elsif(!$wu[$iem] && $wb[$iem]) {
                #  $length_string[$iem] = $lb[$iem] ;
                #  $width_string[$iem] = $wb[$iem] ;
                #} else {
                if($lu[$iem] eq $lb[$iem]) {
                  $length_string[$iem] = $lu[$iem] ;
                } else { $lcombo = 1; }
                if($wu[$iem] eq $wb[$iem]) {
                  $width_string[$iem] = $wu[$iem] ;
                } else { $wcombo = 1; }
                #}
                if($lcombo || $wcombo) {
                  $lu[$iem] =~ s/L/Lu/g ; $lb[$iem] =~ s/L/Lb/g ; $wu[$iem] =~ s/W/Wu/g ; $wb[$iem] =~ s/W/Wb/g ;
                  $emc = join " ", $lu[$iem], $wu[$iem], $lb[$iem], $wb[$iem] ;
                  $emc =~ s/\s+$//;
                  $emc = $emc.$power_grid.$current_stream;
                } else {
                  $emc = join " ", $length_string[$iem], $width_string[$iem] ;
                  $emc =~ s/\s+$//;
                  $emc = $emc.$power_grid.$current_stream;
                }
              }
              if(!$em_condition_3{$emc}) {
                $em_condition_3{$emc}[0] = 1 ;
                push @em_condition_5, $emc;
                if($emc eq "NOT") { $em_condition_3{$emc}[1] = ""; } else { $em_condition_3{$emc}[1] = $emc ;}
                if($em_output_string_via[$iem]) { $em_condition_3{$emc}[2] = $em_output_string_via[$iem] ; }
                $em_condition_3{$emc}[3] = $em_output_string_jmax[$iem] ;
              } else { $em_condition_3{$emc}[0] = $em_condition_3{$emc}[0] + 1 ; }
              $em_condition_3{$emc}[4]{$em_condition_3{$emc}[0]}[1] = $em_polynomial_eval{$iem} ;
              $em_condition_3{$emc}[4]{$em_condition_3{$emc}[0]}[2] = $area_wvlv ;
              if ($em_condition =~ /ARRAY/){
                $emc_array = $emc.' single';
                $tmp_word = 'ARRAY'.$iem;
                if(!$em_condition_3{$emc_array}) {
                  unless ($emc_array eq "NOT single"){
                    push @em_condition_5, $emc_array;
                  }
                  $em_condition_3{$emc_array}[0] = 1 ;
                if($emc eq "NOT") {
                  $em_condition_3{$emc_array}[1] = ""; 
                } else { 
                  $em_condition_3{$emc_array}[1] = $emc_array;
                }
                if($em_output_string_via[$iem]) {
                  $em_condition_3{$emc_array}[2] = $em_output_string_via[$iem];
                }
                $em_condition_3{$emc_array}[3] = $em_output_string_jmax[$iem];
                } else {
                  $em_condition_3{$emc_array}[0] = $em_condition_3{$emc_array}[0] + 1;
                }
                $em_condition_3{$emc_array}[4]{$em_condition_3{$emc_array}[0]}[1] = $em_array{$em_effect}{$em_via_layer}{$tmp_word};
                $em_condition_3{$emc_array}[4]{$em_condition_3{$emc_array}[0]}[2] = $area_wvlv ;
              }
              #print ICT "Debug: Num: $em_condition_3{$emc}[0] Con: $em_condition_3{$emc}[1] EMC: $emc Via: $em_condition_3{$emc}[2] Val: $em_condition_3{$emc}[4]{$em_condition_3{$emc}[0]}[1] Area: $em_condition_3{$emc}[4]{$em_condition_3{$emc}[0]}[2]\n" ;
              last SWITCH ;
            }
          }
          if($emtype eq "num") {
            $em_output_string{$iem} = join " ", $em_effect_word, $em_polynomial{$iem};
          } elsif($emtype eq "pwl") {
            if ($em_polynomial_eval{$iem} =~ /^\d+$/){
              $em_polynomial_eval{$iem} = sprintf("%.1f", $em_polynomial_eval{$iem});
            }
            if ($area_vcwidth !~ /\./){
              $area_vcwidth = sprintf("%.1f", $area_vcwidth);
            }
            $em_output_string{$iem} = join " ", $em_effect_word, "PWL", $em_polynomial_eval{$iem}, $area_vcwidth ;
          } else {
            $em_output_string{$iem} = join " ", $em_effect_word, "EQU", $em_polynomial{$iem} ;
          }
          #if($em_output_string_via[$iem]) { $em_output_string{$iem} = join " ", $em_output_string{$iem}, $em_output_string_via[$iem]; }
          $em_output_string{$iem} = join " ", $em_output_string{$iem}, $em_output_string_jmax[$iem] ;
        }

        SWITCH: {
          if($order_eval == 0) {
            print ICT "      $em_effect_word PWL";
            foreach $emc (sort {$em_polynomial{$a} <=> $em_polynomial{$b}} keys(%em_polynomial)) {
              print ICT " $em_polynomial{$emc} $em_output_string_via[$emc]" ;
              $jmax_tmp = $em_output_string_jmax[$emc] ;
              $cond_tmp = $em_condition_1[$emc] ;
            }
            print ICT " $jmax_tmp $cond_tmp\n" ;
            last SWITCH ;
          }

          if($order_eval == 2) {
            %em_NOT = ();
            for ($tmp1 = 0; $tmp1 <= $#em_condition_5; $tmp1++){
              if ($em_condition_5[$tmp1] eq "NOT"){
                for ($tmp2 = $tmp1; $tmp2 < $#em_condition_5; $tmp2++){
                  $em_condition_5[$tmp2] = $em_condition_5[$tmp2 + 1];
                }
                $em_condition_5[-1] = "NOT";
                last;
              }
            }
            foreach $emc (@em_condition_5){
              $tc = 1 ;
              foreach $t (sort {$em_condition_3{$emc}[4]{$a}[2] <=> $em_condition_3{$emc}[4]{$b}[2]} keys(%{$em_condition_3{$emc}[4]})) {
                if($tc == 1) { print ICT "      $em_effect_word PWL"; }
                if ($emc eq "NOT"){
                  $emc_tmp = "$em_condition_3{$emc}[4]{$t}[1] $em_condition_3{$emc}[4]{$t}[2]";
                  unless (exists $em_NOT{$emc_tmp}){
                    print ICT " $em_condition_3{$emc}[4]{$t}[1] $em_condition_3{$emc}[4]{$t}[2]" ;
                    $em_NOT{$emc_tmp} = 1;
                  }
                }else{
                  print ICT " $em_condition_3{$emc}[4]{$t}[1] $em_condition_3{$emc}[4]{$t}[2]" ;
                }
                if($tc == $em_condition_3{$emc}[0]) {
                  if($em_condition_3{$emc}[2]) {
                    print ICT " $em_condition_3{$emc}[2] $em_condition_3{$emc}[3] $em_condition_3{$emc}[1]\n" ;
                  } else {
                    print ICT " $em_condition_3{$emc}[3] $em_condition_3{$emc}[1]\n" ;
                  }
                  if ($em_condition_3{$emc}[1] =~ /Wb|Lb/ && $em_condition_3{$emc}[1] =~ /current_direction down/){
                    print "Warning! For $ind_name, UPSTREAM should depend on Lu/Wu.\n";
                  }
                  if ($em_condition_3{$emc}[1] =~ /Wu|Lu/ && $em_condition_3{$emc}[1] =~ /current_direction up/){
                    print "Warning! For $ind_name, DOWNSTREAM should depend on Lb/Wb.\n";
                  }
                }
                $tc++ ;
              }
            }
            last SWITCH ;
          }

          if($order_eval == 1) {
            @same_length = 0 ;
            @print_length = 0 ;
            for($ic=1;$ic<$iem;$ic++) {
              if($length{$ic}[0] && $width{$ic}[0]) {
                for($ip=1;$ip<$iem;$ip++) {
                  if($length{$ic}[1] == $length{$ip}[1] && $length{$ic}[2] == $length{$ip}[2] && $em_polynomial_eval{$ic} == $em_polynomial_eval{$ip} && $ic < $ip) {
                    $same_length[$ic] = 1 ; $same_length[$ip] = 1 ; $print_length[$ic] = 1 ; $print_length[$ip] = 0 ;
                  }
                }
              }
            }
            foreach $iem (sort keys (%em_polynomial)) {
              if($em_polynomial{$iem} =~ /L/i) { $order_mode = "length"; }
              #print ICT "Ordering mode = $order_mode $em_polynomial{$iem}\n";
            }
            if($order_mode eq "polynomial") {
              foreach $iem (sort { $em_polynomial{$a} <=> $em_polynomial{$b} } keys (%em_polynomial)) {
                SWITCH: {
                  if($same_length[$iem] && $print_length[$iem]) {
                    print ICT "      $em_output_string{$iem} L $length{$iem}[1] $length{$iem}[2]\n" ;
                    last SWITCH;
                  }
                  if(!$same_length[$iem]) {
                    print ICT "      $em_output_string{$iem} $em_condition_1[$iem]\n";
                    last SWITCH;
                  }
                }
              }
            }
            if($order_mode eq "length") {
              foreach $iem (sort keys(%length)) {
                #foreach $iem (sort { $length{$b}[2] <=> $length{$a}[2]} keys(%length)) {#}
                SWITCH: {
                  if($same_length[$iem] && $print_length[$iem]) {
                    print ICT "      $em_output_string{$iem} L $length{$iem}[1] $length{$iem}[2]\n" ;
                    last SWITCH;
                  }
                  if(!$same_length[$iem]) {
                    print ICT "      $em_output_string{$iem} $em_condition_1[$iem]\n";
                    last SWITCH;
                  }
                }
              }
            }
            last SWITCH;
          }
          for($ic=1;$ic<$iem;$ic++) {
            print ICT "      $em_output_string{$ic} $em_condition_1[$ic]\n";
            #print ICT " $em_condition_orig[$ic]\n" ;
          }
        }
      }
      if ($epf == (scalar(@em_effect_hash_array)-1)&& $em_print_flag == 1 ){ print ICT "   } \n"; }
      $epf=$epf+1 ;
    }
  }
}

sub output_em_via_m0 {
  if (!$em_write_flag){
    my $ind_name = $_[0];
    $em_print_flag = 0 ;
    $epf = 0 ; 
    #$peak_count = 0 ;
    $rms_count = 0 ;  
    if (exists $em_equivalent_layer{$ind_name}){
      $ind_name = $em_equivalent_layer{$ind_name};
    }
    foreach $em_effect (@em_effect_hash_array) {
      if (exists($stack_hash{$ind_name}{WIDTH})){
        $vcwidth = $stack_hash{$ind_name}{WIDTH} ;
      }else{
        $vcwidth = $em_vcwidth_ict;
      }
      $area_vcwidth = $vcwidth*$vcwidth ;
      if (exists $em_hash{$em_effect}{$ind_name}) {
        if ($em_print_flag == 0){
          print ICT "   em_model {\n" ;
          print ICT "      em_vcwidth $vcwidth\n";
          $em_print_flag = 1 ;
        }
        if ($em_effect =~ /DC/i){ $em_effect_word = "em_jmax_dc_avg" ; } 
        if ($em_effect =~ /PEAK/i){ $em_effect_word = "em_jmax_dc_peak" ; }
        if ($em_effect =~ /RMS/i){ $em_effect_word = "em_jmax_ac_rms" ; }
        $order_eval = 0 ; $emc = "0" ; $order_mode = "polynomial" ;
        %em_output_string = (); @em_condition_1 = 0; %em_polynomial = () ; %em_polynomial_eval = () ; @em_output_string_via = 0;
        @length_string = "0"; @width_string = "0"; @wv = 0; @lv = 0; @lu = "0"; @wu = "0"; @lb = "0"; @wb = "0";
        %em_condition_3 = () ; %length = () ; %width = () ;
        %em_single = ();
        @em_condition_5 = ();
        @em_condition_5_NOT = ();
        @em_condition_5_NOT_UD = ();

        for ($iem=1;$iem<= $em_hash{$em_effect}{$ind_name}{NO_OF_POLYNOMIAL_TABLE};$iem++){
          $polynomial_word = "POLYNOMIAL".$iem ;
          $condition_word = "CONDITION".$iem ;
          $factor_word =  "FACTOR".$iem ;
          $array_word =  "ARRAY".$iem ;
          $em_condition_flag = 0 ; 
          $em_polynomial{$iem} =  $em_hash{$em_effect}{$ind_name}{$polynomial_word} ;
          if ($em_polynomial{$iem} =~ /La/){
            $La_flag = 1;
          }
          if ($em_polynomial{$iem} =~ /^\d+$/){
#Po-Kai's request
            $em_polynomial{$iem} = sprintf("%.1f", $em_polynomial{$iem} );
          }
          $em_condition = $em_hash{$em_effect}{$ind_name}{$condition_word} ;

          @em_first_array = @{$em_hash{$em_effect}{$ind_name}{$factor_word}{first_line}} ;
          @em_second_array = @{$em_hash{$em_effect}{$ind_name}{$factor_word}{second_line}} ;

          if ($em_polynomial{$iem} !~ /^[+-]?[0-9]*\.?[0-9]+$/){
            for ($esa=0;$esa<=scalar(@em_second_array)-1;$esa++){
              for ($efa=1;$efa<=scalar(@em_first_array)-1;$efa++){
                $first_pointer = $em_hash{$em_effect}{$ind_name}{$factor_word}{first_line}[$efa];
                $second_pointer = $em_hash{$em_effect}{$ind_name}{$factor_word}{second_line}[$esa];
                $em_polynomial{$iem} =~ s/@em_first_array[$efa]/$em_hash{$em_effect}{$ind_name}{$factor_word}{$second_pointer}{$first_pointer}/ ;
                if ($em_condition =~ /ARRAY/){
                  $em_array{$em_effect}{$ind_name}{$array_word} = $em_hash{$em_effect}{$ind_name}{$factor_word}{$second_pointer}{$first_pointer};
                }
              }
            }
            if($em_polynomial{$iem} !~ /L/i) {
              $em_polynomial_eval{$iem} = eval($em_polynomial{$iem}) ;
              $emtype = "pwl" ;
            } else {
              $emtype = "equ" ;
              $em_output_string{$iem} = "EQU $em_polynomial{$iem}";
            } 
          } else {
            $emtype = "num" ;
            $em_output_string{$iem} = "$em_polynomial{$iem}";
          }

          if (exists $em_hash{$em_effect}{$ind_name}{RATING_FACTOR}){
            @rating_first_array = @{$em_hash{$em_effect}{$ind_name}{RATING_FACTOR}{first_line}} ;
            @rating_second_array = @{$em_hash{$em_effect}{$ind_name}{RATING_FACTOR}{second_line}} ;
            $em_output_string_jmax[$iem] = "jmax_factor";
            for ($esa=0;$esa<=scalar(@rating_second_array)-1;$esa++){
              for ($efa=1;$efa<=scalar(@rating_first_array)-1;$efa++){
                $first_pointer = $em_hash{$em_effect}{$ind_name}{RATING_FACTOR}{first_line}[$efa];
                $second_pointer = $em_hash{$em_effect}{$ind_name}{RATING_FACTOR}{second_line}[$esa];
                if ( $em_hash{$em_effect}{$ind_name}{RATING_FACTOR}{$second_pointer}{$first_pointer} !~ /N\/A/i  ){
                  $em_output_string_jmax[$iem] = join " ", $em_output_string_jmax[$iem], $first_pointer, $em_hash{$em_effect}{$ind_name}{RATING_FACTOR}{$second_pointer}{$first_pointer} ;
                }
              }
            }
          }

          SWITCH : {
            if($em_condition =~ /L \=\=/){
              $order_eval = 0 ;
              $emtype = "pwl" ;
              $em_condition =~ m/(L \=\=)/i ;
              $em_condition_v1 = substr  $em_condition, index($em_condition, $1);
              @em_condition_v2 = split('\s+',$em_condition_v1) ;
              $em_condition_v2 = split('\s+',$em_condition_v1) ;
              for ($j = 0; $j < $em_condition_v2; $j++) {
                if($em_condition_v2[$j] eq "L") { $lv{$iem} = $em_condition_v2[$j+2] ; }
              }
#              $em_output_string_via[$iem] = $lv{$iem}*$lv{$iem} ;
              if ($lv{$iem}*$lv{$iem} =~ /\./){
                $em_output_string_via[$iem] =  $lv{$iem}*$lv{$iem} ;
              }else{
                $em_output_string_via[$iem] = sprintf("%.1f", $lv{$iem}*$lv{$iem} );
              }
              last SWITCH ;
            }

            if(($em_condition =~ /Lv \=\=/) && ($em_condition =~ /Wv \=\=/) && (($em_condition !~ /\(/) || ($em_condition !~ /\)/))) {
              $order_eval = 0 ;
              $emtype = "pwl" ;
              $em_condition =~ m/(Lv \=\=)/i ;
              $em_condition_v1 = substr  $em_condition, index($em_condition, $1);
              @em_condition_v2 = split('\s+',$em_condition_v1) ;
              $em_condition_v2 = split('\s+',$em_condition_v1) ;
              for ($j = 0; $j < $em_condition_v2; $j++) {
                if($em_condition_v2[$j] eq "Lv") { $lv{$iem} = $em_condition_v2[$j+2] ; }
                if($em_condition_v2[$j] eq "Wv") { $wv{$iem} = $em_condition_v2[$j+2] ; }
              }
#              $em_output_string_via[$iem] =  $lv{$iem}*$wv{$iem} ;
#Po-Kai's request
              if ($lv{$iem}*$wv{$iem} =~ /\./){
                $em_output_string_via[$iem] =  $lv{$iem}*$wv{$iem} ;
              }else{
                $em_output_string_via[$iem] = sprintf("%.1f", $lv{$iem}*$wv{$iem} );
              }
              last SWITCH ;
            }

            if(($em_condition !~ /Wv \=\=/) || ($em_condition !~ /Lv \=\=/)) {
              #if(($em_condition !~ /Wv \=\=/) || ($em_condition !~ /Lv \=\=/) && ($em_condition !~ /L \=\=/)) {#}
              $order_eval = 1 ;
              if($emtype ne "num") { $emtype = "equ"; }
              $em_condition =~ m/([a-z]+)/i ;
              $em_condition_1[$iem] = substr  $em_condition, index($em_condition, $1); 
              if($em_condition_1[$iem] =~ /AND/i) {$em_condition_1[$iem] =~ s/AND//; }
              if($em_condition_1[$iem] =~ /w/) {$em_condition_1[$iem] =~ s/w/W/; }
              @em_condition_2 = split('\s+',$em_condition_1[$iem]) ;
              $em_condition_2 = split('\s+',$em_condition_1[$iem]) ;
              for ($j = 0; $j < $em_condition_2; $j++) {
                if($em_condition_2[$j] eq "L") {
                  $length{$iem}[0] = $iem; 
                  $length{$iem}[1] = $em_condition_2[$j+1]; #Capture length sign
                  $length{$iem}[2] = $em_condition_2[$j+2]; #Capture length value
                }
                if($em_condition_2[$j] eq "W") {
                  $width{$iem}[0] = $iem;
                  $width{$iem}[1] = $em_condition_2[$j+1]; #Capture width sign
                  $width{$iem}[1] = $em_condition_2[$j+2]; #Capture width value
                }
              }
              last SWITCH ;
            }

            if(($em_condition =~ /Lv \=\=/) && ($em_condition =~ /Wv \=\=/) && ($em_condition =~ /\(/) && ($em_condition =~ /\)/)) {
              $current_stream = '';
              $single = '';
              $order_eval = 2 ;
              $emtype = "pwl" ;
              #print ICT "$em_condition\n";
              $em_condition_orig[$iem] = $em_condition ;
              $em_condition_1[$iem] = substr  $em_condition, index($em_condition, $1); 
              @split_em_condition = split('\s+\(\s+\(\s+\(\s+|\s+\)\s+\)\s+OR\s+\(\s+\(\s+|\s+\)\s+AND\s+\(\s+|\s+AND\s+|\s+\)\s+\)\s+\)|\(\s+|\s+\)',$em_condition) ;
              $split_em_condition = split('\s+\(\s+\(\s+\(\s+|\s+\)\s+\)\s+OR\s+\(\s+\(\s+|\s+\)\s+AND\s+\(\s+|\s+AND\s+|\s+\)\s+\)\s+\)|\(\s+|\s+\)',$em_condition) ;
              #print ICT "$split_em_condition @split_em_condition\n" ;
              for ($j = 0; $j < $split_em_condition; $j++) {
                $split_em_condition[$j] =~ s/^\s+|\s+$//g;
                @local_em = split('\s+',$split_em_condition[$j]) ;
                $local_em = split('\s+',$split_em_condition[$j]) ;
                #print ICT "$split_em_condition[$k] $local_em @local_em\n";
                #enhance to support Lu <= 4 and 4 >= Lu, 4 >= Lb > 2 and 2 < Lb <= 4
                if ($local_em == 3){
                  if ($local_em[2] =~ /Wv|Lv|Wu|Lu|Wb|Lb/){
                    $local_em_tmp = $local_em[0];
                    $local_em[0] = $local_em[2];
                    $local_em[2] = $local_em_tmp;
                    if ($local_em[1] eq "<="){
                      $local_em[1] = ">=";
                    }elsif ($local_em[1] eq ">="){
                      $local_em[1] = "<=";
                    }elsif ($local_em[1] eq "<"){
                      $local_em[1] = ">";
                    }elsif ($local_em[1] eq ">"){
                      $local_em[1] = "<";
                    }
                  }
                }elsif ($local_em == 5){
                  if ($local_em[4] > $local_em[0]){
                    $local_em_tmp = $local_em[0];
                    $local_em[0] = $local_em[4];
                    $local_em[4] = $local_em_tmp;
                    $operation_tmp = $local_em[1];
                    if ($local_em[3] eq "<="){
                      $local_em[1] = ">=";
                    }elsif ($local_em[3] eq "<"){
                      $local_em[1] = ">";
                    }
                    if ($operation_tmp eq "<="){
                      $local_em[3] = ">=";
                    }elsif ($operation_tmp eq "<"){
                      $local_em[3] = ">";
                    }
                  }
                }
                for($k = 0; $k < $local_em; $k++) {
                  #print ICT "$local_em[$k] $local_em[$k+1] $local_em[$k+2]\n" ;
                  if(($local_em[$k] eq "Wv") && ($local_em[$k+1] eq "\=\=")) { $wv{$iem} = $local_em[$k+2] ; }
                  if(($local_em[$k] eq "Lv") && ($local_em[$k+1] eq "\=\=")) { $lv{$iem} = $local_em[$k+2] ; }
                  if($local_em == 3) {
                    $temp_string = join " ", $local_em[$k+1], $local_em[$k+2] ;
                    if($local_em[$k] eq "Lu") { $lu[$iem] = join " ", "L", $temp_string; }
                    if($local_em[$k] eq "Wu") { $wu[$iem] = join " ", "W", $temp_string; }
                    if($local_em[$k] eq "Lb") { $lb[$iem] = join " ", "L", $temp_string; }
                    if($local_em[$k] eq "Wb") { $wb[$iem] = join " ", "W", $temp_string; }
                  } elsif ($local_em == 5) {
                    SWITCH: {
                      if($local_em[$k-1] eq ">=") { $local_em[$k-1] = "<=" ; last SWITCH ; }
                      if($local_em[$k-1] eq ">") { $local_em[$k-1] = "<" ; last SWITCH ; }
                      if($local_em[$k-1] eq "<=") { $local_em[$k-1] = ">=" ; last SWITCH ; }
                      if($local_em[$k-1] eq "<") { $local_em[$k-1] = ">" ; last SWITCH ; }
                    }
                    #$temp_string_1 = join " ", $local_em[$k-2], $local_em[$k-1] ;
                    $temp_string_1 = join " ", $local_em[$k-1], $local_em[$k-2] ;
                    $temp_string_2 = join " ", $local_em[$k+1], $local_em[$k+2] ;
                    #if($local_em[$k] eq "Lu") { $lu[$iem] = join " ", $temp_string_1, "L", $temp_string_2 ; }
                    #if($local_em[$k] eq "Wu") { $wu[$iem] = join " ", $temp_string_1, "W", $temp_string_2 ; }
                    #if($local_em[$k] eq "Lb") { $lb[$iem] = join " ", $temp_string_1, "L", $temp_string_2 ; }
                    #if($local_em[$k] eq "Wb") { $wb[$iem] = join " ", $temp_string_1, "W", $temp_string_2 ; }
                    if($local_em[$k] eq "Lu") { $lu[$iem] = join " ", "L", $temp_string_1, "L", $temp_string_2 ; }
                    if($local_em[$k] eq "Wu") { $wu[$iem] = join " ", "W", $temp_string_1, "W", $temp_string_2 ; }
                    if($local_em[$k] eq "Lb") { $lb[$iem] = join " ", "L", $temp_string_1, "L", $temp_string_2 ; }
                    if($local_em[$k] eq "Wb") { $wb[$iem] = join " ", "W", $temp_string_1, "W", $temp_string_2 ; }
                  }
                }
              }
              $area_wvlv =  $wv{$iem}*$lv{$iem} ;
              if ($area_wvlv !~ /\./){
                $em_output_string_via[$iem] = sprintf("%.1f", $lv{$iem}*$wv{$iem} );
              }
              $lcombo = 0; $wcombo = 0;
              if ($em_condition =~ /UPSTREAM/){
                $current_stream = ' current_direction down';
              }elsif ($em_condition =~ /DOWNSTREAM/){
                $current_stream = ' current_direction up';
              }
              if ($em_condition =~ /SINGLE/){
                $single = ' single';
              }
              if($em_condition =~ /NOT/) {
                $emc = "NOT" ;
                if ((index($em_condition, 'UPSTREAM') >= 0) && (index($em_condition, 'UPSTREAM') < index($em_condition, 'NOT'))){
                  $emc = "NOT_U" ;
                }elsif ((index($em_condition, 'DOWNSTREAM') >= 0) && (index($em_condition, 'DOWNSTREAM') < index($em_condition, 'NOT'))){
                  $emc = "NOT_D" ;
                }
              } else {
                #if($wu[$iem] && !$wb[$iem]) {
                #  $length_string[$iem] = $lu[$iem] ;
                #  $width_string[$iem] = $wu[$iem] ;
                #} elsif(!$wu[$iem] && $wb[$iem]) {
                #  $length_string[$iem] = $lb[$iem] ;
                #  $width_string[$iem] = $wb[$iem] ;
                #} else {
                if($lu[$iem] eq $lb[$iem]) {
                  $length_string[$iem] = $lu[$iem] ;
                } else { $lcombo = 1; }
                if($wu[$iem] eq $wb[$iem]) {
                  $width_string[$iem] = $wu[$iem] ;
                } else { $wcombo = 1; }
                #}
                if($lcombo || $wcombo) {
                  $lu[$iem] =~ s/L/Lu/g ; $lb[$iem] =~ s/L/Lb/g ; $wu[$iem] =~ s/W/Wu/g ; $wb[$iem] =~ s/W/Wb/g ;
                  $emc = join " ", $lu[$iem], $wu[$iem], $lb[$iem], $wb[$iem] ;
                  $emc =~ s/\s+$//;
                  $emc = $emc.$current_stream.$single;
                } else {
                  $emc = join " ", $length_string[$iem], $width_string[$iem] ;
                  $emc =~ s/\s+$//;
                  $emc = $emc.$current_stream.$single;
                }
              }
              if(!$em_condition_3{$emc}) {
                $em_condition_3{$emc}[0] = 1 ;
                if ($emc =~ /NOT/){
                  if ($emc eq "NOT"){
                    push @em_condition_5_NOT, $emc;
                  }else{
                    push @em_condition_5_NOT_UD, $emc;
                  }
                }else{
                  push @em_condition_5, $emc;
                  if ($emc =~ /single/){
                    $em_single{$emc} = 1;
                  }
                }
#Per Tze-Ting's request, add general condition for DOWNSTREAM and UPSTREAM
                if($emc eq "NOT") { 
                  $em_condition_3{$emc}[1] = "";
                }elsif($emc eq "NOT_U"){
                  $em_condition_3{$emc}[1] = " current_direction down";
                }elsif($emc eq "NOT_D"){
                  $em_condition_3{$emc}[1] = " current_direction up";
                }else {
                  $em_condition_3{$emc}[1] = $emc ;
                }
                if($em_output_string_via[$iem]) { $em_condition_3{$emc}[2] = $em_output_string_via[$iem] ; }
                $em_condition_3{$emc}[3] = $em_output_string_jmax[$iem] ;
              } else { $em_condition_3{$emc}[0] = $em_condition_3{$emc}[0] + 1 ; }
              $em_condition_3{$emc}[4]{$em_condition_3{$emc}[0]}[1] = $em_polynomial_eval{$iem} ;
              $em_condition_3{$emc}[4]{$em_condition_3{$emc}[0]}[2] = $area_wvlv ;
#Per Tze-Ting's request, if there is not SINGLE keyword in iRCX, ARRAY will be split to SINGLE.
              if ($em_condition =~ /ARRAY/){
                $emc_array = $emc.' array_single';
                $emc_array2 = $emc.' single';
                $tmp_word = 'ARRAY'.$iem;
                if(!$em_condition_3{$emc_array}) {
                  unless ($emc_array eq "NOT array_single" || $emc_array eq "NOT_U array_single" || $emc_array eq "NOT_D array_single"){
                    push @em_condition_5_array, $emc_array2;
                  }
                  $em_condition_3{$emc_array}[0] = 1 ;
                if($emc eq "NOT") {
                  $em_condition_3{$emc_array}[1] = ""; 
                } else { 
                  $em_condition_3{$emc_array}[1] = $emc_array2;
                }
                if($em_output_string_via[$iem]) {
                  $em_condition_3{$emc_array}[2] = $em_output_string_via[$iem];
                }
                $em_condition_3{$emc_array}[3] = $em_output_string_jmax[$iem];
                } else {
                  $em_condition_3{$emc_array}[0] = $em_condition_3{$emc_array}[0] + 1;
                }
                $em_condition_3{$emc_array}[4]{$em_condition_3{$emc_array}[0]}[1] = $em_array{$em_effect}{$ind_name}{$tmp_word};
                $em_condition_3{$emc_array}[4]{$em_condition_3{$emc_array}[0]}[2] = $area_wvlv ;
              }
              #print ICT "Debug: Num: $em_condition_3{$emc}[0] Con: $em_condition_3{$emc}[1] EMC: $emc Via: $em_condition_3{$emc}[2] Val: $em_condition_3{$emc}[4]{$em_condition_3{$emc}[0]}[1] Area: $em_condition_3{$emc}[4]{$em_condition_3{$emc}[0]}[2]\n" ;
              last SWITCH ;
            }
          }
          if($emtype eq "num") {
            $em_output_string{$iem} = join " ", $em_effect_word, $em_polynomial{$iem};
          } elsif($emtype eq "pwl") {
            if ($em_polynomial_eval{$iem} =~ /^\d+$/){
              $em_polynomial_eval{$iem} = sprintf("%.1f", $em_polynomial_eval{$iem});
            }
            if ($area_vcwidth !~ /\./){
              $area_vcwidth = sprintf("%.1f", $area_vcwidth);
            }
            $em_output_string{$iem} = join " ", $em_effect_word, "PWL", $em_polynomial_eval{$iem}, $area_vcwidth ;
          } else {
            $em_output_string{$iem} = join " ", $em_effect_word, "EQU", $em_polynomial{$iem} ;
          }
          #if($em_output_string_via[$iem]) { $em_output_string{$iem} = join " ", $em_output_string{$iem}, $em_output_string_via[$iem]; }
          $em_output_string{$iem} = join " ", $em_output_string{$iem}, $em_output_string_jmax[$iem] ;
        }

        SWITCH: {
          if($order_eval == 0) {
            print ICT "      $em_effect_word PWL";
            foreach $emc (sort {$em_polynomial{$a} <=> $em_polynomial{$b}} keys(%em_polynomial)) {
              print ICT " $em_polynomial{$emc} $em_output_string_via[$emc]" ;
              $jmax_tmp = $em_output_string_jmax[$emc] ;
              $cond_tmp = $em_condition_1[$emc] ;
            }
            print ICT " $jmax_tmp $cond_tmp\n" ;
            last SWITCH ;
          }

          if($order_eval == 2) {
            %em_NOT = ();
            %em_NOT_U = ();
            %em_NOT_D = ();
            %em_check = ();
#Per Tze-Ting's request, if there is not SINGLE keyword in iRCX, ARRAY will be split to SINGLE.
            foreach $array_single (@em_condition_5_array){
              unless (exists $em_single{$array_single}){
                $array_single =~ s/single/array_single/;
                push @em_condition_5, $array_single;
              }
            }
            push @em_condition_5, @em_condition_5_NOT_UD;
            push @em_condition_5, @em_condition_5_NOT;
#            for ($tmp1 = 0; $tmp1 <= $#em_condition_5; $tmp1++){
#              if ($em_condition_5[$tmp1] eq "NOT"){
#                for ($tmp2 = $tmp1; $tmp2 < $#em_condition_5; $tmp2++){
#                  $em_condition_5[$tmp2] = $em_condition_5[$tmp2 + 1];
#                }
#                $em_condition_5[-1] = "NOT";
#                last;
#              }
#            }
            foreach $t (sort {$em_condition_3{NOT}[4]{$a}[2] <=> $em_condition_3{NOT}[4]{$b}[2]} keys(%{$em_condition_3{NOT}[4]})) {
              $check_val = $em_condition_3{NOT}[4]{$t}[1];
              $check_area = $em_condition_3{NOT}[4]{$t}[2];
              $em_check{$check_area} = $check_val;
            }

            foreach $emc (@em_condition_5){
              $tc = 1 ;
              $val_area = '';
              @val_array = ();
              @area_array = ();
              foreach $t (sort {$em_condition_3{$emc}[4]{$a}[2] <=> $em_condition_3{$emc}[4]{$b}[2]} keys(%{$em_condition_3{$emc}[4]})) {
                if($tc == 1) { print ICT "      $em_effect_word PWL"; }
                if ($emc eq "NOT"){
                  $emc_tmp = "$em_condition_3{$emc}[4]{$t}[1] $em_condition_3{$emc}[4]{$t}[2]";
                  unless (exists $em_NOT{$emc_tmp}){
#                    print ICT " $em_condition_3{$emc}[4]{$t}[1] $em_condition_3{$emc}[4]{$t}[2]" ;
                    $val_area = $val_area." $em_condition_3{$emc}[4]{$t}[1] $em_condition_3{$emc}[4]{$t}[2]";
                    push @val_array, $em_condition_3{$emc}[4]{$t}[1];
                    push @area_array, $em_condition_3{$emc}[4]{$t}[2];
                    $em_NOT{$emc_tmp} = 1;
                  }
                }elsif ($emc eq "NOT_U"){
                  $emc_tmp = "$em_condition_3{$emc}[4]{$t}[1] $em_condition_3{$emc}[4]{$t}[2]";
                  unless (exists $em_NOT_U{$emc_tmp}){
#                    print ICT " $em_condition_3{$emc}[4]{$t}[1] $em_condition_3{$emc}[4]{$t}[2]" ;
                    $val_area = $val_area." $em_condition_3{$emc}[4]{$t}[1] $em_condition_3{$emc}[4]{$t}[2]";
                    push @val_array, $em_condition_3{$emc}[4]{$t}[1];
                    push @area_array, $em_condition_3{$emc}[4]{$t}[2];
                    $em_NOT_U{$emc_tmp} = 1;
                  }
                }elsif ($emc eq "NOT_D"){
                  $emc_tmp = "$em_condition_3{$emc}[4]{$t}[1] $em_condition_3{$emc}[4]{$t}[2]";
                  unless (exists $em_NOT_D{$emc_tmp}){
#                    print ICT " $em_condition_3{$emc}[4]{$t}[1] $em_condition_3{$emc}[4]{$t}[2]" ;
                    $val_area = $val_area." $em_condition_3{$emc}[4]{$t}[1] $em_condition_3{$emc}[4]{$t}[2]";
                    push @val_array, $em_condition_3{$emc}[4]{$t}[1];
                    push @area_array, $em_condition_3{$emc}[4]{$t}[2];
                    $em_NOT_D{$emc_tmp} = 1;
                  }
                }else{
#                  print ICT " $em_condition_3{$emc}[4]{$t}[1] $em_condition_3{$emc}[4]{$t}[2]" ;
                  $val_area = $val_area." $em_condition_3{$emc}[4]{$t}[1] $em_condition_3{$emc}[4]{$t}[2]";
                  push @val_array, $em_condition_3{$emc}[4]{$t}[1];
                  push @area_array, $em_condition_3{$emc}[4]{$t}[2];
                }
                if($tc == $em_condition_3{$emc}[0]) {
#Per Tze-Ting' request, due to the vstorm2 limitation where it only supports a single factor in a single EM rule. Need to check against base rule and to split the rule into 2 or more.
                  $split_flag = 0;
                  $VAL = $val_array[0]/$em_check{$area_array[0]};
                  for ($tmp1 = 0; $tmp1 <= $#val_array; $tmp1++){
                    if ($val_array[$tmp1]/$em_check{$area_array[$tmp1]} != $VAL){
                      $split_flag = 1;
                    }
                  }
                  if($em_condition_3{$emc}[2]) {
                    if ($split_flag == 1){
                      for ($tmp1 = 0; $tmp1 <= $#val_array; $tmp1++){
                        if($tmp1 != 0) {
                          print ICT "      $em_effect_word PWL";
                        }
                        print ICT " $val_array[$tmp1] $area_array[$tmp1] $em_condition_3{$emc}[2] $em_condition_3{$emc}[3] $em_condition_3{$emc}[1]\n";
                      }
                    }else{
                      print ICT "$val_area $em_condition_3{$emc}[2] $em_condition_3{$emc}[3] $em_condition_3{$emc}[1]\n";
                    }
                  } else {
                    if ($split_flag == 1){
                      for ($tmp1 = 0; $tmp1 <= $#val_array; $tmp1++){
                        if($tmp1 != 0) {
                          print ICT "      $em_effect_word PWL";
                        }
                        print ICT " $val_array[$tmp1] $area_array[$tmp1] $em_condition_3{$emc}[3] $em_condition_3{$emc}[1]\n" ;
                      }
                    }else{
                      print ICT "$val_area $em_condition_3{$emc}[3] $em_condition_3{$emc}[1]\n" ;
                    }
                  }
                  if ($em_condition_3{$emc}[1] =~ /Wb|Lb/ && $em_condition_3{$emc}[1] =~ /current_direction down/){
                    print "Warning! For $ind_name, UPSTREAM should depend on Lu/Wu.\n";
                  }
                  if ($em_condition_3{$emc}[1] =~ /Wu|Lu/ && $em_condition_3{$emc}[1] =~ /current_direction up/){
                    print "Warning! For $ind_name, DOWNSTREAM should depend on Lb/Wb.\n";
                  }
                }
                $tc++ ;
              }
            }
            last SWITCH ;
          }

          if($order_eval == 1) {
            @same_length = 0 ;
            @print_length = 0 ;
            for($ic=1;$ic<$iem;$ic++) {
              if($length{$ic}[0] && $width{$ic}[0]) {
                for($ip=1;$ip<$iem;$ip++) {
                  if($length{$ic}[1] == $length{$ip}[1] && $length{$ic}[2] == $length{$ip}[2] && $em_polynomial_eval{$ic} == $em_polynomial_eval{$ip} && $ic < $ip) {
                    $same_length[$ic] = 1 ; $same_length[$ip] = 1 ; $print_length[$ic] = 1 ; $print_length[$ip] = 0 ;
                  }
                }
              }
            }
            foreach $iem (sort keys (%em_polynomial)) {
              if($em_polynomial{$iem} =~ /L/i) { $order_mode = "length"; }
              #print ICT "Ordering mode = $order_mode $em_polynomial{$iem}\n";
            }
            if($order_mode eq "polynomial") {
              foreach $iem (sort { $em_polynomial{$a} <=> $em_polynomial{$b} } keys (%em_polynomial)) {
                SWITCH: {
                  if($same_length[$iem] && $print_length[$iem]) {
                    print ICT "      $em_output_string{$iem} L $length{$iem}[1] $length{$iem}[2]\n" ;
                    last SWITCH;
                  }
                  if(!$same_length[$iem]) {
                    print ICT "      $em_output_string{$iem} $em_condition_1[$iem]\n";
                    last SWITCH;
                  }
                }
              }
            }
            if($order_mode eq "length") {
              foreach $iem (sort keys(%length)) {
                #foreach $iem (sort { $length{$b}[2] <=> $length{$a}[2]} keys(%length)) {#}
                SWITCH: {
                  if($same_length[$iem] && $print_length[$iem]) {
                    print ICT "      $em_output_string{$iem} L $length{$iem}[1] $length{$iem}[2]\n" ;
                    last SWITCH;
                  }
                  if(!$same_length[$iem]) {
                    print ICT "      $em_output_string{$iem} $em_condition_1[$iem]\n";
                    last SWITCH;
                  }
                }
              }
            }
            last SWITCH;
          }
          for($ic=1;$ic<$iem;$ic++) {
            print ICT "      $em_output_string{$ic} $em_condition_1[$ic]\n";
            #print ICT " $em_condition_orig[$ic]\n" ;
          }
        }
      }
      if ($epf == (scalar(@em_effect_hash_array)-1)&& $em_print_flag == 1 ){ print ICT "   } \n"; }
      $epf=$epf+1 ;
    }
  }
}

sub output_em_conductor_m0_tap {
  if (!$em_write_flag) {
    $em_print_flag = 0 ;
    $epf = 0 ;
    #$peak_count = 0 ; 
    $rms_count = 0 ;
    #avoid printing empty em_model
    $em_empty_count = 0;
    my $ind_name = $_[0];
    if (exists $em_equivalent_layer{$ind_name}){
      $ind_name = $em_equivalent_layer{$ind_name};
    }
    foreach $em_effect (@em_effect_hash_array) {
      #print "@array_stack[$i] $em_effect\n" ;
      foreach (keys(%{$em_hash{$em_effect}{$ind_name}})) {
        $em_empty_count++;
      }
      if (exists $em_hash{$em_effect}{$ind_name} && $em_empty_count > 2) {
        if ($em_print_flag == 0){ print ICT "   em_model {\n" ; $em_print_flag = 1 ; }
        $order_eval = 0 ; $order_mode = "polynomial" ;
        %em_output_string = (); $em_condition_1 = "0"; %em_polynomial = () ;
        @em_condition_2 = "0"; %em_length = () ;

        for ($iem=1;$iem<= $em_hash{$em_effect}{$ind_name}{NO_OF_POLYNOMIAL_TABLE};$iem++){
          $em_condition_3 = '';
          $polynomial_word = "POLYNOMIAL".$iem ;
          $condition_word = "CONDITION".$iem ;
          $factor_word =  "FACTOR".$iem ;
          $em_polynomial{$iem} =  $em_hash{$em_effect}{$ind_name}{$polynomial_word} ;
          $em_condition = $em_hash{$em_effect}{$ind_name}{$condition_word} ;
          if ($em_polynomial{$iem} =~ /La/){
            $La_flag = 1;
          }
          if ($em_condition !~ /VERTICAL/){
            next;
          }else{
            $em_condition =~ s/\(|\)|(AND)*\s*\(*\s*VERTICAL\s*\)*//g;
          }
          @em_first_array = @{$em_hash{$em_effect}{$ind_name}{$factor_word}{first_line}} ;
          @em_second_array = @{$em_hash{$em_effect}{$ind_name}{$factor_word}{second_line}} ;

          if ($em_polynomial{$iem} =~ /^[+-]?[0-9]*\.?[0-9]+$/){
            $em_output_string{$iem} = "$em_polynomial{$iem}";
          } else {
            for ($esa=0;$esa<=scalar(@em_second_array)-1;$esa++){
              for ($efa=1;$efa<=scalar(@em_first_array)-1;$efa++){
                $first_pointer = $em_hash{$em_effect}{$ind_name}{$factor_word}{first_line}[$efa];
                $second_pointer = $em_hash{$em_effect}{$ind_name}{$factor_word}{second_line}[$esa];
                $em_polynomial{$iem} =~ s/@em_first_array[$efa]/$em_hash{$em_effect}{$ind_name}{$factor_word}{$second_pointer}{$first_pointer}/ ;
              }
            }
            $em_output_string{$iem} = "EQU $em_polynomial{$iem}";
          }
          #print ICT "Debug Poly: $em_output_string{$iem}\n" ;

          if (exists $em_hash{$em_effect}{$ind_name}{RATING_FACTOR}){
            @rating_first_array = @{$em_hash{$em_effect}{$ind_name}{RATING_FACTOR}{first_line}} ;
            @rating_second_array = @{$em_hash{$em_effect}{$ind_name}{RATING_FACTOR}{second_line}} ;

            $em_output_string{$iem} = join " ", $em_output_string{$iem}, "jmax_factor" ;
            for ($esa=0;$esa<=scalar(@rating_second_array)-1;$esa++){
              for ($efa=1;$efa<=scalar(@rating_first_array)-1;$efa++){
                $first_pointer = $em_hash{$em_effect}{$ind_name}{RATING_FACTOR}{first_line}[$efa];
                $second_pointer = $em_hash{$em_effect}{$ind_name}{RATING_FACTOR}{second_line}[$esa];
                if ( $em_hash{$em_effect}{$ind_name}{RATING_FACTOR}{$second_pointer}{$first_pointer} !~ /N\/A/i  ){
                  $em_output_string{$iem} = join " ", $em_output_string{$iem}, $first_pointer, $em_hash{$em_effect}{$ind_name}{RATING_FACTOR}{$second_pointer}{$first_pointer};
                }
              }
            }
          }

          $em_condition =~ m/([a-z]+)/i ;
          $em_condition_1 = substr  $em_condition, index($em_condition, $1); 
          if($em_condition_1 =~ /AND/i) {$em_condition_1 =~ s/AND//; }
          if($em_condition_1 =~ /w/) {$em_condition_1 =~ s/w/W/; }
          @em_condition_2 = split('\s+',$em_condition_1) ;
          $em_condition_2 = split('\s+',$em_condition_1) ;
          for ($j = 0; $j < $em_condition_2; $j++) {
            if($em_condition_2[$j] eq "L") {
              $em_length{$iem}[0] = $iem;
              $em_length{$iem}[1] = $em_condition_2[$j+1]; #Capture sign
              $em_length{$iem}[2] = $em_condition_2[$j+2]; #Capture length value
              $order_eval = 1 ;
            }
          }
          #enhance to support L <= 4 and 4 >= L, 4 >= L > 2 and 2 < L <= 4
          @split_em_condition_3 = split('AND', $em_condition);
          for ($mi = 0; $mi <= $#split_em_condition_3; $mi++){
            $split_em_condition_3[$mi] =~ s/^\s+|\s+$//g;
            @local_em_3 = split('\s+',$split_em_condition_3[$mi]);
            if ($#local_em_3 == 2){
              if ($local_em_3[2] =~ /[wl]/i || $local_em_3[2] =~ /Td/i ){
                # CCR 1207336 
                $local_em_3_tmp = $local_em_3[0];
                $local_em_3[0] = $local_em_3[2];
                $local_em_3[2] = $local_em_3_tmp;
                if($local_em_3[1] eq ">="){
                  $local_em_3[1] = "<=";
                }elsif($local_em_3[1] eq ">"){
                  $local_em_3[1] = "<";
                }elsif($local_em_3[1] eq "<="){
                  $local_em_3[1] = ">=";
                }elsif($local_em_3[1] eq "<"){
                  $local_em_3[1] = ">";
                }
                $split_em_condition_3[$mi] = "$local_em_3[0] $local_em_3[1] $local_em_3[2]";
              }
            }elsif ($#local_em_3 == 4){
              if($local_em_3[1] eq ">="){
                $local_em_3[1] = "<=";
              }elsif($local_em_3[1] eq ">"){
                $local_em_3[1] = "<";
              }elsif($local_em_3[1] eq "<="){
                $local_em_3[1] = ">=";
              }elsif($local_em_3[1] eq "<"){
                $local_em_3[1] = ">";
              }
              $split_em_condition_3[$mi] = "$local_em_3[2] $local_em_3[1] $local_em_3[0] $local_em_3[2] $local_em_3[3] $local_em_3[4]";
            }
            $em_condition_3 = $em_condition_3." $split_em_condition_3[$mi]";
          }
          $em_condition_3 =~ s/w/W/g;
          $em_condition_3 =~ s/^\s+//;
          $em_condition_3 =~ s/\s+/ /g;
          #$em_output_string{$iem} = join " ", $em_output_string{$iem}, $em_condition_1 ;
          $em_output_string{$iem} = join " ", $em_output_string{$iem}, $em_condition_3 ;
        }
        if ($em_effect =~ /DC/i && $order_eval){
          foreach $iem (sort keys (%em_polynomial)) {
            if($em_polynomial{$iem} =~ /L/i) { $order_mode = "length"; }
          }
          if($order_mode eq "polynomial") {
            foreach $iem (sort { $em_polynomial{$a} <=> $em_polynomial{$b} } keys (%em_polynomial)) {
              if (defined($em_output_string{$iem})){
                print ICT "      em_jmax_dc_avg $em_output_string{$iem}\n";
              }
            }
          }
          if($order_mode eq "length") {
            foreach $iem (sort keys(%em_length)) {
              #foreach $iem (sort { $em_length{$b}[2] <=> $em_length{$a}[2]} keys(%em_length)) {#}
              if (defined($em_output_string{$iem})){
                print ICT "      em_jmax_dc_avg $em_output_string{$iem}\n";
              }
            }
          }
        } else {
          # CCR 1207336 
          my $Ipeak_Td_threshold = $em_hash{$em_effect}{PARAMS}{Ipeak_Td_threshold};
          my $r_upperBound = 0.05; # CCR1143863 hardcode set by TSMC
          my $eps = 1E-10;
          for($ic=1;$ic<$iem;$ic++) {
            if ($em_effect =~ /DC/i) {
              if (defined($em_output_string{$ic})){
                print ICT "      em_jmax_dc_avg $em_output_string{$ic}\n";
              }
            }
            if ($em_effect =~ /PEAK/i){
              if (defined($em_output_string{$ic})){
                print ICT "      em_jmax_dc_peak $em_output_string{$ic}" ;
                 if ( defined( $Ipeak_Td_threshold ) ) {
                   my $TdVal = -1.0E0;
                   my $rVal = 1.0E10;
                   if ( $em_output_string{$ic} =~ m/Td\s*>=\s*(\S+)/ ) {
                      $TdVal = 1.0 * $1;
                   }  
                   if ( $em_output_string{$ic} =~ m/r\s*<\s*(\S+)/ ) {
                      $rVal = 1.0 * $1;
                   }
                   if ( $TdVal > ($Ipeak_Td_threshold - $eps) ) {
                      print ICT " apply r = 1.0"; 
                      # COMMENT: Because of Td>=Ipeak_Td_threshold
                   }  
                   if ( $r_upperBound > ($rVal - $eps) ) {
                      print ICT " apply r = $r_upperBound";
                      # COMMENT: Because of r < 0.05
                   }  
                 }
                print ICT "\n";
                print ICT "      em_jmax_ac_peak $em_output_string{$ic}" ;
                 if ( defined( $Ipeak_Td_threshold ) ) {
                   my $TdVal = -1.0E0;
                   my $rVal = 1.0E10;
                   if ( $em_output_string{$ic} =~ m/Td\s*>=\s*(\S+)/ ) {
                      $TdVal = 1.0 * $1;
                   }  
                   if ( $em_output_string{$ic} =~ m/r\s*<\s*(\S+)/ ) {
                      $rVal = 1.0 * $1;
                   } 
                   if ( $TdVal > ($Ipeak_Td_threshold - $eps) ) {
                      print ICT " apply r = 1.0";
                      # COMMENT: Because of Td>=Ipeak_Td_threshold
                   }  
                   if ( $r_upperBound > ($rVal - $eps) ) {
                      print ICT " apply r = $r_upperBound";
                      # COMMENT: Because of r < 0.05
                   }
                 }
                 print ICT "\n";

              }
            }
            if ($em_effect =~ /RMS/i){ 
              if (defined($em_output_string{$ic})){
                print ICT "      em_jmax_dc_rms $em_output_string{$ic}\n"; 
                print ICT "      em_jmax_ac_rms $em_output_string{$ic}\n"; 
              }
            }
          }
        }
      }
      if ($epf == (scalar(@em_effect_hash_array)-1) && $em_print_flag == 1 ){ print ICT "   } \n"; }
      $epf=$epf+1 ;
    }
  }
}

## END MAIN

###
# Synopsis    [ usage() ]
# Description [ Prints out usage message and exits ]
###
sub usage {
  # Update this output with new flags
  # By conventions, tell users to use -t=value format
  # Optional arguments should be placed in [ ] on the Usage: line
  # Ex:  die qq(Usage: $0 [-h] [-v] -f=input -o=output \n\n) .
  die qq(\nSynopsis: Converts a TSMC unified technology file \(.ircx\)\n) .
  qq(\t  into a Cadence ICT file\n) .
  qq(\nUsage: ircxtoict [-h] [-v] [-noem] [-i <output ict file>] [-em_update <input ict file>] <input ircx file>\n\n) .
  qq(\t-noem           -- turns off output of EM information into ICT file\n) .
  qq(\t-i <ICT file>   -- optionally specify the output ICT file to be written to\n\n) .
  qq(\t-em_update <ICT file>   -- optionally enable the EM only parsing flow. Input ICT file should come from dumping an existing qrcTechFile and match to IRCX\n\n) .
  qq(\t-h              -- output help (this message)\n) .
  qq(\t-v              -- version of the utility \n\n) .
  qq(\t(ircxtoict Release: $ext_release_version)\n\n);
}


sub output_release {
  die qq( ircxtoict Release : $ext_release_version \n) ;
}
###
# Synopsis    [ getOptions() ]
# Description [ Parse command-line args and set run-time parameters
#               as appropriate...
#               Returns anything that's not a flag or value of flag
#             ]
# SeeAlso     [ http://sev-cm.cadence.com/fom/internalFAQ.cgi?file=89
#               perldoc Getopt::Long
#             ]
#        
###
sub getOptions {
  my $errorout = 0;

  # Set any defaults here
  $options{help} = undef;
  $options{ext_version} = undef;
  # Add additional defaults here
  # $options{inputfile} = undef;
  # $options{outputfile} = undef;

  # Set known options here
  # Use the following hash key styles to define known parameters:
  #    'x'    - set/unset the variable
  #    'x+'   - allows multiple -x, incrementing the var with each
  #    'x=s'  - takes a required string argument (-x="foo")
  #    'x=i'  - takes an integer argument
  #    'x:s'  - takes an optional string argument
  #    'x:i'  - takes an optional integer argument
  #    'x|ex  - same pameter, different names (-x and -ex do the same thing)
  #
  # The value of each hash element is a reference to a variable, a list,
  # or a hash.  It does not have to be an element of the %options hash.
  # %options is provided as a suggested implementation.
  # (see 'perldoc Getopt::Long' for more options and details)
  my %known_options = ( 'h|?'     => \$options{help},
  'v+'      => \$options{ext_version},
  'noem+'     => \$em_write_flag,
  'i=s'     => \$ict_file,
  'em_update=s'     => \$native_ict,
  # Additional example flags.  Uncomment as necessary. 
  #                      'g=s'     => \$options{group},
  'r=s'     => \$ext_release_version,
  #                      'p=s'     => \$options{platform},
  #                      'q+'      => \$options{quiet},
  #                      'debug+'  => \$options{debug},
  #                      'id=s'    => \$options{dbindex},
  #                      'd=s'     => \$options{inputdir},
  #                      'f=s'     => \$options{inputfile},
  #                      't=s'     => \$options{cvstag},
  #                      'o=s'     => \$options{outputfile},
  #                      'e=s'     => \@{$options{emails}},
  );

  # Process any terminal conditions, including required flags
  if (!GetOptions(%known_options) or $options{help}) {
    usage();
  } 
  if ( $options{ext_version}) {
    output_release();
  }

  if (@ARGV == 0) {
    print "ERROR: No arguments given!\n" ;
    usage(); die:
  }
  # Examples of processing required flags
  #
  # if (!defined $options{inputfile}) {
  #   warn "-f inputfile is required.\n";
  #   $errorout = 1;
  # }
  # if (!defined $options{outputfile}) {
  #   warn "-o outputfile is required.\n";
  #   $errorout = 1;
  # }
  # die "Missing required flag[s].  Aborting\n" if $errorout;


  # Example of processing parameter into a list.  In this case, the -e
  # parameter can take space separated list in quotes.  ex: -e "joe bob tom",
  # or -e joe -e bob -e tom, or mix of the two styles, # and the array
  # @{$options{emails}} will contain the list ("joe", "bob", "tom")
  #
  # @{$options{emails}} = split(/\s+/,join(' ',@{$options{emails}}));

  # Return remainder of command line argument
  return @ARGV;
} 

sub print_rho{
  my $process_node = $_[0];
  my $indie_name = $_[1]; 

  if (exists $manuf_table{$indie_name}{"RHO"}  ) {
    print ICT "   rho\n" ;
    print ICT "      rho_widths " ;
    $indie_effect = "RHO";

    for ($wef=1; $wef<=scalar @{ $manuf_table{$indie_name}{$indie_effect}{second_line}}-1;$wef++) {
      $rho_width_value = $manuf_table{$indie_name}{$indie_effect}{second_line}[$wef] ;
      print ICT "$rho_width_value " ;
    }
    print ICT "  \n";

    print ICT "      rho_spacings " ;
    for ($wef=1; $wef<=scalar @{ $manuf_table{$indie_name}{$indie_effect}{first_line}}-1;$wef++) {
      $rho_space_value = $manuf_table{$indie_name}{$indie_effect}{first_line}[$wef];
      print ICT "$rho_space_value " ;
    }
    print ICT "\n";

    print ICT "      rho_values " ;
    for ($wef=1; $wef<=scalar @{ $manuf_table{$indie_name}{$indie_effect}{first_line}}-1;$wef++) {

      for ($sef=1; $sef<=scalar @{ $manuf_table{$indie_name}{$indie_effect}{second_line}}-1;$sef++) {

        $space_index_value =  $manuf_table{$indie_name}{$indie_effect}{first_line}[$wef] ;
        $width_index_value =  $manuf_table{$indie_name}{$indie_effect}{second_line}[$sef] ;

        $rho_adjust_value = $manuf_table{$indie_name}{$indie_effect}{$width_index_value}{$space_index_value} ;
        $rho_adjust_value_final = sprintf("%.4f", $rho_adjust_value) ;

        if (abs($rho_adjust_value_final) == 0.0000) {
          $rho_adjust_value_final = 0 ;

        }
        print ICT "$rho_adjust_value_final " ;
      }
      print ICT "\n                 ";
    }
    print ICT "\n";
  }

}

sub print_RHO_T{
  my $process_node = $_[0];
  my $indie_table = $_[1]; 

  if (exists $manuf_table{$indie_table}{"RHO_T"}  ) {
    print ICT "   rho\n" ;
    print ICT "      rho_silicon_widths " ;
    for (my $wef=1; $wef<=scalar @{ $manuf_table{$indie_table}{"RHO_T"}{first_line}}-1;$wef++) {
      my $rho_width_value = $manuf_table{$indie_table}{"RHO_T"}{first_line}[$wef] ;
      print ICT "$rho_width_value " ;
    }
    print ICT "  \n";

    print ICT "      rho_silicon_thicknesses " ;
    for (my $wef=1; $wef<=scalar @{ $manuf_table{$indie_table}{"RHO_T"}{second_line}}-1;$wef++) {
      my $rho_thick_value = $manuf_table{$indie_table}{"RHO_T"}{second_line}[$wef];
      print ICT "$rho_thick_value " ;
    }
    print ICT "\n";

    print ICT "      rho_values " ;
    my $wef ;
    my $sef ; 
    for ($wef=1; $wef<=scalar @{ $manuf_table{$indie_table}{"RHO_T"}{second_line}}-1;$wef++) {

      for ($sef=1; $sef<=scalar @{ $manuf_table{$indie_table}{"RHO_T"}{first_line}}-1;$sef++) {

        my $width_index_value =  $manuf_table{$indie_table}{"RHO_T"}{first_line}[$sef] ;
        my $thick_index_value =  $manuf_table{$indie_table}{"RHO_T"}{second_line}[$wef] ;

        my $rho_adjust_value = $manuf_table{$indie_table}{"RHO_T"}{$thick_index_value}{$width_index_value} ;

        my $rho_adjust_value_final = sprintf("%.4f", $rho_adjust_value) ;

        if (abs($rho_adjust_value_final) == 0.0000) {
          $rho_adjust_value_final = 0 ;

        }
        print ICT "$rho_adjust_value_final " ;
      }
      print ICT "\n                 ";
    }
    print ICT "\n";

  } 
}

sub print_resistivity {

  my $process_node = $_[0];
  my $indie_table = $_[1];
  my $indie_n ;
  $indie_n = $indie_table;	
  $indie_n =~ s/INDIE\_TABLE\[//g ;	
  $indie_n =~ s/\]//g ;	

  print ICT "   resistivity " ;
  if(exists ($manuf_table{$indie_table}{"RSH"})){ 

    my @poly_resist_widths=@{$manuf_table{$indie_table}{"RSH"}{second_line}} ;

    my $prw_scalar = scalar(@poly_resist_widths);
    #print ICT " The poly widhts are @poly_resist_widths \n";
    for  (my $prws=1;$prws<=$prw_scalar-1;$prws++)  {

      my $space_index_value =  $manuf_table{$indie_table}{"RSH"}{first_line}[1] ;
      my $width_index_value =  $manuf_table{$indie_table}{"RSH"}{second_line}[$prws] ;
      my $rsh_adjust_value = sprintf("%.1f",$manuf_table{$indie_table}{"RSH"}{$width_index_value}{$space_index_value}) ;
      my $poly_width_si = $manuf_table{$indie_table}{"WIDTH"}{$width_index_value}{$space_index_value} ;
      my $poly_resist_values = $rsh_adjust_value*($poly_width_si/$width_index_value) ;

      $poly_resist_values =sprintf("%.5f",$poly_resist_values) ;
      print ICT "$poly_resist_values $poly_width_si " ;
    }
  }else{
    if ($stack_hash{$indie_n}{INDIE_TABLE} !~ /N\/A/){
      my $space_index_value =  $manuf_table{$indie_table}{"WIDTH"}{first_line}[1] ;
      my $width_index_value =  $manuf_table{$indie_table}{"WIDTH"}{second_line}[1] ;
      my $poly_width_si = $manuf_table{$indie_table}{"WIDTH"}{$width_index_value}{$space_index_value} ;
    }else{
      my $width_index_value =  $stack_hash{$indie_n}{WIDTH} ;
      my $poly_width_si = $stack_hash{$indie_n}{WIDTH} + $stack_hash{$indie_n}{BIAS} ;
    }
    my $rsh_adjust_value = sprintf("%.1f",$stack_hash{$indie_n}{RESIST});

    my $poly_resist_values = $rsh_adjust_value*($poly_width_si/$width_index_value) ;

    $poly_resist_values =sprintf("%.5f",$poly_resist_values) ;
    print ICT "$poly_resist_values $poly_width_si " ;
  }

  print ICT "\n";
  #my $tc1_value_final = sprintf("%.10f", $stack_hash{$polyname}{TC1} ) ;
  #print ICT "   temp_tc1 $tc1_value_final \n";

  #my $tc2_value_final = sprintf("%.20f", $stack_hash{$polyname}{TC2} ) ;
  #print ICT "   temp_tc2 $tc2_value_final \n";

  #print ICT " } \n" ;
}


#wee_table
sub print_wee_info{
  my $process_node = $_[0];
  my $indie_name = $_[1];
  my $stack_name = $indie_name;
  $stack_name =~ s/INDIE_TABLE\[//g;
  $stack_name =~ s/\]//g;
  if ($find_process_node <= 28 ) {
    if ($stack_name eq "poly") {
      $stack_name = "fpoly"; 
    }
  }

  if (exists $manuf_table{$indie_name}{WIDTH}  ) {
    my $indie_effect = "WIDTH";
    my $wee_flag = 0 ;
    for ( my $wef=1; $wef<=scalar @{ $manuf_table{$indie_name}{$indie_effect}{first_line}}-1;$wef++) {

      for ( my $sef=1; $sef<=scalar @{ $manuf_table{$indie_name}{$indie_effect}{second_line}}-1;$sef++) {

        my $width_index_value =  $manuf_table{$indie_name}{$indie_effect}{second_line}[$sef] ;
        my $space_index_value =  $manuf_table{$indie_name}{$indie_effect}{first_line}[$wef] ;

        my $wee_adjust_value = $manuf_table{$indie_name}{$indie_effect}{$width_index_value}{$space_index_value}-$manuf_table{$indie_name}{$indie_effect}{second_line}[$sef]- $stack_hash{$stack_name}{BIAS} ;

        $wee_adjust_value = sprintf("%.5f",$wee_adjust_value);
        if ($wee_adjust_value != 0 ){
          #print "TEST : $wee_adjust_value \n";
          $wee_flag = 1;
          last;
        }
      }
    }
    if ( $wee_flag == 1 ){

      print ICT "   wire_edge_enlargement\n" ;
      print ICT "      wee_widths " ;

      for (my $wef=1; $wef<=scalar @{ $manuf_table{$indie_name}{$indie_effect}{second_line}}-1;$wef++) {

        $wee_width_value = $manuf_table{$indie_name}{$indie_effect}{second_line}[$wef]+ $stack_hash{$stack_name}{BIAS} ;
        $wee_width_value = sprintf("%.5f", $wee_width_value);
        print ICT "$wee_width_value " ;
        #if ( $indie_name =~ /metal0/){
        #	print "$manuf_table{$indie_name}{$indie_effect}{second_line}[$wef]\n";
        #	print " $stack_hash{$stack_name}{BIAS}\n";
        #	print "$indie_name\n";
        #        print "$wee_width_value \n";
        #}
      }
      print ICT "\n";
      print ICT "      wee_spacings " ;
      for (my $wef=1; $wef<=scalar @{ $manuf_table{$indie_name}{$indie_effect}{first_line}}-1;$wef++) {
        $wee_space_value = $manuf_table{$indie_name}{$indie_effect}{first_line}[$wef]- $stack_hash{$stack_name}{BIAS} ;
        $wee_space_value = sprintf("%.5f", $wee_space_value);
        print ICT "$wee_space_value " ;
      }
      print ICT "\n";

      print ICT "      wee_adjustments " ;
      for ( my $wef=1; $wef<=scalar @{ $manuf_table{$indie_name}{$indie_effect}{first_line}}-1;$wef++) {

        for ( my $sef=1; $sef<=scalar @{ $manuf_table{$indie_name}{$indie_effect}{second_line}}-1;$sef++) {

          my $width_index_value =  $manuf_table{$indie_name}{$indie_effect}{second_line}[$sef] ;
          my $space_index_value =  $manuf_table{$indie_name}{$indie_effect}{first_line}[$wef] ;

          my $wee_adjust_value = $manuf_table{$indie_name}{$indie_effect}{$width_index_value}{$space_index_value}-$manuf_table{$indie_name}{$indie_effect}{second_line}[$sef]- $stack_hash{$stack_name}{BIAS} ;
          #if ($find_process_node <=45) {
          $wee_adjust_value_final = sprintf("%.5f", ($wee_adjust_value/2)) ;
          #	$wee_adjust_value_final = sprintf("%.5f", $wee_adjust_value_final) ;
          #} else {
          #	$wee_adjust_value_final = sprintf("%.3f", ($wee_adjust_value/2)) ;
          #	$wee_adjust_value_final = sprintf("%.3g", $wee_adjust_value_final) ;
          #}

          if (abs($wee_adjust_value_final) == 0.00000) {
            #$wee_adjust_value_final = "0.0000E+00" ;
            $wee_adjust_value_final = "0.00000" ;
          }
          print ICT "$wee_adjust_value_final " ;
        }
        print ICT "\n                      ";
      }
      print ICT "\n";
    }
  }
}

sub print_wee_m0_info{
  my $process_node = $_[0];
  my $indie_name = $_[1];
  my $stack_name = $indie_name;
  $stack_name =~ s/INDIE_TABLE\[//g;
  $stack_name =~ s/\]//g;
  if ($find_process_node <= 28 ) {
    if ($stack_name eq "poly") {
      $stack_name = "fpoly"; 
    }
  }

  if (exists $manuf_table{$indie_name}{WIDTH}  ) {
    my $indie_effect = "WIDTH";
    my $wee_flag = 0 ;
    for ( my $wef=1; $wef<=1;$wef++) {

      for ( my $sef=1; $sef<=scalar @{ $manuf_table{$indie_name}{$indie_effect}{second_line}}-1;$sef++) {

        my $width_index_value =  $manuf_table{$indie_name}{$indie_effect}{second_line}[$sef] ;
        my $space_index_value =  $manuf_table{$indie_name}{$indie_effect}{first_line}[$wef] ;

        my $wee_adjust_value = $manuf_table{$indie_name}{$indie_effect}{$width_index_value}{$space_index_value}-$manuf_table{$indie_name}{$indie_effect}{second_line}[$sef]- $stack_hash{$stack_name}{BIAS} ;

        $wee_adjust_value = sprintf("%.5f",$wee_adjust_value);
        if ($wee_adjust_value != 0 ){
          #print "TEST : $wee_adjust_value \n";
          $wee_flag = 1;
          last;
        }
      }
    }
    if ( $wee_flag == 1 ){

      print ICT "   wire_edge_enlargement\n" ;
      print ICT "      wee_widths " ;

      for (my $wef=1; $wef<=scalar @{ $manuf_table{$indie_name}{$indie_effect}{second_line}}-1;$wef++) {

        $wee_width_value = $manuf_table{$indie_name}{$indie_effect}{second_line}[$wef]+ $stack_hash{$stack_name}{BIAS} ;
        $wee_width_value = sprintf("%.5f", $wee_width_value);
        print ICT "$wee_width_value " ;
      }
      print ICT "\n";
      print ICT "      wee_spacings " ;
      for (my $wef=1; $wef<=1;$wef++) {
        $wee_space_value = $manuf_table{$indie_name}{$indie_effect}{first_line}[$wef]- $stack_hash{$stack_name}{BIAS} ;
        $wee_space_value = sprintf("%.5f", $wee_space_value);
        print ICT "$wee_space_value " ;
      }
      print ICT "\n";

      print ICT "      wee_adjustments " ;
      for ( my $wef=1; $wef<=1;$wef++) {

        for ( my $sef=1; $sef<=scalar @{ $manuf_table{$indie_name}{$indie_effect}{second_line}}-1;$sef++) {

          my $width_index_value =  $manuf_table{$indie_name}{$indie_effect}{second_line}[$sef] ;
          my $space_index_value =  $manuf_table{$indie_name}{$indie_effect}{first_line}[$wef] ;

          my $wee_adjust_value = $manuf_table{$indie_name}{$indie_effect}{$width_index_value}{$space_index_value}-$manuf_table{$indie_name}{$indie_effect}{second_line}[$sef]- $stack_hash{$stack_name}{BIAS} ;
          $wee_adjust_value_final = sprintf("%.5f", ($wee_adjust_value/2)) ;

          if (abs($wee_adjust_value_final) == 0.00000) {
            $wee_adjust_value_final = "0.00000" ;
          }
          print ICT "$wee_adjust_value_final " ;
        }
        print ICT "\n                      ";
      }
      print ICT "\n";
    }
  }
}

sub print_factor{
  my $find_process_node = $_[0];
  my $indie_name= $_[1];

  #Polynomial factor1
  if ( exists  $manuf_table{$indie_name}{FACTOR_POLYNOMIAL1} ){
    if ( $manuf_table{$indie_name}{FACTOR_POLYNOMIAL1}{zero_flag} > 0) {
      $indie_effect = "FACTOR_POLYNOMIAL1";

      $wtr_density_number = $manuf_table{$indie_name}{$indie_effect}{manuf_row}-1 ;
      $wtr_width_number =   $manuf_table{$indie_name}{$indie_effect}{manuf_col}-2 ;
      print ICT "   wire_thickness_ratio \n" ;
      if ($find_process_node < 40) {
        print ICT "       wtr_tile_width 50\n " ;
      } else {
        print ICT "       wtr_tile_width 100\n " ;
      }
      print ICT "      wtr_max_spacing  @{$manuf_table{$indie_name}{WIDTH}{first_line}}[-1]\n " ;
      if ( @{$manuf_table{$indie_name}{WIDTH}{second_line}}[1] == $manuf_table{$indie_name}{CONDITION} ){
        $X_RANGE = 0;
      }else{
        $X_RANGE = @{$manuf_table{$indie_name}{WIDTH}{second_line}}[1] ;
      }
      if ( @{$manuf_table{$indie_name}{WIDTH}{second_line}}[-1] == $manuf_table{$indie_name}{CONDITION} ){
        $Y_RANGE = 10 * $manuf_table{$indie_name}{CONDITION} ;
      }else{
        $Y_RANGE = @{$manuf_table{$indie_name}{WIDTH}{second_line}}[-1] ;
      }
      print ICT "      wtr_width_ranges  $X_RANGE $manuf_table{$indie_name}{CONDITION}  $Y_RANGE\n " ;
      print ICT "      wtr_density_polynomial_order  $wtr_density_number\n " ;
      print ICT "      wtr_width_polynomial_order $wtr_width_number\n " ;
      print ICT "      wtr_polynomial_coefficients {\n                "  ;
      for ($wef=1; $wef<=scalar @{ $manuf_table{$indie_name}{$indie_effect}{second_line}}-1;$wef++) {
        for ($sef=1; $sef<=scalar @{ $manuf_table{$indie_name}{$indie_effect}{first_line}}-1;$sef++) {

          $factor_index_value =  $manuf_table{$indie_name}{$indie_effect}{first_line}[$sef] ;
          $coeff_index_value =  $manuf_table{$indie_name}{$indie_effect}{second_line}[$wef] ;

          $wtr_adjust_value = $manuf_table{$indie_name}{$indie_effect}{$coeff_index_value}{$factor_index_value} ;

          $wtr_adjust_value = sprintf("%.5e" ,$wtr_adjust_value) ;
          if (abs($wtr_adjust_value) == 0) {
#            $wtr_adjust_value = "0.00000E+00" ;
            $wtr_adjust_value = "0" ;
          }


          print ICT "$wtr_adjust_value\t" ;
        }
        print ICT "\n                ";
      }
      print ICT "}" ;
      print ICT "\n";
    }
  }

  #Polynomial2
  if ( exists  $manuf_table{$indie_name}{FACTOR_POLYNOMIAL2} ){
    if ( $manuf_table{$indie_name}{FACTOR_POLYNOMIAL2}{zero_flag} > 0) {

      $indie_effect = "FACTOR_POLYNOMIAL2";



      print ICT "                {\n                "  ;



      for ($wef=1; $wef<=scalar @{ $manuf_table{$indie_name}{$indie_effect}{second_line}}-1;$wef++) {


        for ($sef=1; $sef<=scalar @{ $manuf_table{$indie_name}{$indie_effect}{first_line}}-1;$sef++) {

          $factor_index_value =  $manuf_table{$indie_name}{$indie_effect}{first_line}[$sef] ;
          $coeff_index_value =  $manuf_table{$indie_name}{$indie_effect}{second_line}[$wef] ;

          $wtr_adjust_value = $manuf_table{$indie_name}{$indie_effect}{$coeff_index_value}{$factor_index_value} ;

          $wtr_adjust_value = sprintf("%.5e" ,$wtr_adjust_value) ;
          if (abs($wtr_adjust_value) == 0) {
#            $wtr_adjust_value = "0.00000E+00";
            $wtr_adjust_value = "0" ;
          }
          print ICT "$wtr_adjust_value " ;
        }
        print ICT "\n                ";
      }
      print ICT "}" ;
      print ICT "\n";
    }
  }
}
sub print_raise_diff{
  my $n20_indie_name = $_[0];
  my $t_type = $_[1];
  print ICT  "     raised_diffusion {\n";
  foreach $ts (@{$manuf_table{$n20_indie_name}{$t_type}{second_line}}){
    if ($ts =~ /OD_THICKNESS/){
      print ICT "       thickness $manuf_table{$n20_indie_name}{$t_type}{$ts}{VALUE}\n";
    }
    if ($ts =~ /OD_TO_GATE/){
      my $tmp_value = $manuf_table{$n20_indie_name}{$t_type}{$ts}{VALUE} * (-1);
      print ICT "       gate_facing_edge_enlargement $tmp_value\n" ;
    }
    if ($ts =~ /OD_EDGE_BIASING/){
      my $tmp_value = $manuf_table{$n20_indie_name}{$t_type}{$ts}{VALUE} * (-1);
      print ICT "       other_edge_enlargement $tmp_value\n";
    }
  }
  print ICT  "     }\n";
}

sub print_opc{
}

sub print_sub_poly{
  my $find_process_node = $_[0];
  my $sub_name = $_[1];
  my $stack_name = $_[2];
  my $indie_table = $_[3];

  print ICT " sub_conductor \"$sub_name\" { \n" ;
  if ($find_process_node  > 20){
    $wire_height_npoly =  $stack_hash{$stack_name}{HEIGHT} + 0.001 ;
  }else{

    $wire_height_npoly =  $stack_hash{$stack_name}{HEIGHT} ;
  }
  $wire_height_npoly = sprintf("%.5f" , $wire_height_npoly) ;
  print ICT "   height $wire_height_npoly\n";
#  if ($find_process_node == 20){
#    $wire_thickness_npoly =  $stack_hash{$stack_name}{THICKNESS} - $stack_hash{GOX}{THICKNESS} ;
#  }else{
#    $wire_thickness_npoly =  $stack_hash{$stack_name}{THICKNESS} ;
#  }
  $wire_thickness_npoly =  $stack_hash{$stack_name}{THICKNESS} ;
  $wire_thickness_npoly = sprintf("%.5f" , $wire_thickness_npoly) ;
  print ICT "   thickness $wire_thickness_npoly\n";

  if (exists $manuf_table{$indie_table}{"RHO_T"}  ) {
#Joe's suggestion, use resistivity for poly in N20
    if ($find_process_node == 20){
      print_resistivity($find_process_node ,$indie_table);
    }else{
      print_RHO_T($find_process_node , $indie_table);
    }
  } else {
    print_resistivity($find_process_node ,$indie_table);

  }

  print_wee_info($find_process_node , $indie_table);
  print_factor($find_process_node , $indie_table);


  $tc1_value_final = sprintf("%.10f", $stack_hash{$stack_name}{TC1} ) ;
  print ICT "   temp_tc1 $tc1_value_final \n";

  $tc2_value_final = sprintf("%.20f", $stack_hash{$stack_name}{TC2} ) ;
  print ICT "   temp_tc2 $tc2_value_final \n";


  #			print ICT " } \n" ;
}
sub print_cfi{
  my $process_node = $_[0];
  my $indie_table = $_[1]; 
  my $cfi_table= $_[2]; 

  print ICT "   gate_diffusion_fringing_inverse_cap\n" ;
  print ICT "      cfi_widths " ;
  for (my $wef=1; $wef<=scalar @{ $manuf_table{$indie_table}{$cfi_table}{second_line}}-1;$wef++) {
    my $width_value = $manuf_table{$indie_table}{$cfi_table}{second_line}[$wef] ;
    print ICT "$width_value " ;
  }
  print ICT "  \n";

  print ICT "      cfi_lengths " ;
  for (my $wef=1; $wef<=scalar @{ $manuf_table{$indie_table}{$cfi_table}{first_line}}-1;$wef++) {
    my $length_value = $manuf_table{$indie_table}{$cfi_table}{first_line}[$wef];
    print ICT "$length_value " ;
  }
  print ICT "\n";

  print ICT "      cfi_values " ;
  my $wef ;
  my $sef ; 
  for ($wef=1; $wef<=scalar @{ $manuf_table{$indie_table}{$cfi_table}{first_line}}-1;$wef++) {

    for ($sef=1; $sef<=scalar @{ $manuf_table{$indie_table}{$cfi_table}{second_line}}-1;$sef++) {

      my $width_index_value =  $manuf_table{$indie_table}{$cfi_table}{second_line}[$sef] ;
      my $length_index_value =  $manuf_table{$indie_table}{$cfi_table}{first_line}[$wef] ;

      my $cfi_adjust_value = ($manuf_table{$indie_table}{$cfi_table}{$width_index_value}{$length_index_value})  ;
      #print "width : $width_index_value\n length : $length_index_value\ncfi : $cfi_adjust_value : $cfi_adjust_value *E15\n";
      if ( $cfi_adjust_value =~ /x/){
        $cfi_adjust_value_final = "0.00000"  ;
      }else{
        $cfi_adjust_value_final = sprintf("%.5f", $cfi_adjust_value*1E15) ;

      }


      print ICT "$cfi_adjust_value_final " ;
    }
    print ICT "\n                 ";
  }
  print ICT "\n";

} 

sub print_sub_expandedFrom{
  my $find_process_node = $_[0];
  my $name = $_[1];
  my $bottomExpand = $_[2];
  my $dielectric_constant= $_[3];
  my $under = $_[4];
  my $n20_indie_name = "INDIE_TABLE[$name]" ;
  my $t_type;
  $dielectric_constant = sprintf("%.3f" , $dielectric_constant);
  foreach $t_type (@{$manuf_table{$n20_indie_name}{manuf_type_arr}}){
    if ($t_type =~ /COV/ ){
      my $mos_name =$t_type;
      my $mos_name_tmp;
      $mos_name =~ s/COV\_EFFECTIVE\_FACTOR\_TABLE\_//g;	
      if ($N20_flag ne 'G'){
        $mos_name_tmp = $mos_name;
      }else{
        if ($mos_name =~ /IO/){
          $mos_name_tmp = "G_1D5V$mos_name";
        }else{
          $mos_name_tmp = "G_$mos_name";
        }
      }
      print ICT "   expandedFromSubConductor \"$mos_name_tmp\" \{ \n";
      if ( $under !~ /poly/){
        print ICT "     bottomExpand $bottomExpand\n";
      }
      print ICT "   	dielectric_constant $dielectric_constant\n";
      print ICT "   }\n";
    }
  }
  if ( $under =~ /poly/){
    if ($name =~ /(\S+)_g(\S+)/ && $name !~ /srm/){
      $name  = "$1_$2";
      print ICT "   expandedFromSubConductor \"$name\" \{ \n";
      if ( $under !~ /poly/){
        print ICT "   	bottomExpand $bottomExpand\n";
      }
      print ICT "   	dielectric_constant $dielectric_constant\n";
      print ICT "   }\n";
    }
  }
  if ( $under =~ /srm/){
    if ($name =~ /(\S+)_f(\S+)/){
      $name  = "$1_$2";
      print ICT "   expandedFromSubConductor \"$name\" \{ \n";
      print ICT "   	dielectric_constant $dielectric_constant\n";
      print ICT "   }\n";
    }
  }
  foreach $t_type (@{$manuf_table{$n20_indie_name}{manuf_type_arr}}){
    if ($t_type =~ /RAISED\_DIFF/){
      my $mos_name =$t_type;
      my $mos_name_tmp;
      $mos_name =~ s/RAISED\_DIFF\_//g;	
      $mos_name = $mos_name."_active";
      if ($N20_flag ne 'G'){
        $mos_name_tmp = $mos_name;
      }else{
        if ($mos_name =~ /IO/){
          $mos_name_tmp = "G_1D5V$mos_name";
        }else{
          $mos_name_tmp = "G_$mos_name";
        }
      }
      print ICT "   expandedFromSubConductor \"$mos_name_tmp\" \{ \n";
      if ( $under !~ /poly/){
        print ICT "   	bottomExpand $bottomExpand\n";
      }
      print ICT "   	dielectric_constant $dielectric_constant\n";
      print ICT "   }\n";
    }
  }
  if ( $under =~ /OD/){
    $name = lc $name;
    print ICT "   expandedFromSubConductor \"$name\" \{ \n";
    if ( $under !~ /poly/){
      print ICT "   	bottomExpand $bottomExpand\n";
    }
    print ICT "   	dielectric_constant $dielectric_constant\n";
    print ICT "   }\n";
  }
}


sub print_vee_table{
  my $find_process_node = $_[0];
  my $indie_table = $_[1];
  my $indie_name = $_[2];
  my $indie_effect = "WIDTH";
  my $wee_adjust_value_final ;
  for ( my $wef=1; $wef<=scalar @{ $manuf_table{$indie_table}{$indie_effect}{first_line}}-1;$wef++) {

    for ( my $sef=1; $sef<=scalar @{ $manuf_table{$indie_table}{$indie_effect}{second_line}}-1;$sef++) {

      my $width_index_value =  $manuf_table{$indie_table}{$indie_effect}{second_line}[$sef] ;
      my $space_index_value =  $manuf_table{$indie_table}{$indie_effect}{first_line}[$wef] ;

      my $wee_adjust_value = $manuf_table{$indie_table}{$indie_effect}{$width_index_value}{$space_index_value}-$manuf_table{$indie_table}{$indie_effect}{second_line}[$sef]- $stack_hash{$indie_name}{BIAS} ;
      #Base on current N20 process, set VEE as 0
      $wee_adjust_value_final = sprintf("%.5f", 0) ;
      #$wee_adjust_value_final = sprintf("%.5f", ($wee_adjust_value/2)) ;
      #$wee_adjust_value_final = sprintf("%.4g", $wee_adjust_value_final) ;
    }
  }
#N20 V0.1 Not real dual poly
#
#  print ICT "   sub_conductor \"SRM_M0_OD1\" \{ \n";
#  print ICT "        via_edge_enlargement \n";
#  print ICT "        vee_poco_spacings "; 
#  for(my $i = 2 ; $i < 21 ; $i++ ){
#    my $temp = $i/100 ;
#    print ICT "$temp ";       
#  }
#  print ICT "\n        vee_adjustments ";
#  for(my $j =2 ; $j < 21 ; $j++){
#    print ICT "0.0000 ";       
#  }
#  print ICT "\n";
#  &print_rho($find_process_node , $indie_table);
#  printf ICT "        temp_tc1 %.10f \n", $stack_hash{$indie_name}{TC1}  ;
#  printf ICT "        temp_tc2 %.20f \n",$stack_hash{$indie_name}{TC2}   ;
#  print ICT "   }\n";
#
  my $n20_indie_name = "INDIE_TABLE[n_gpoly]" ;
  my @temp;
  if ($indie_name =~ /srm/){
    $temp[0] = "INDIE_TABLE[n_gpoly_srm]";
    $temp[1] = "INDIE_TABLE[p_gpoly_srm]";
  }else{
    $temp[0] = "INDIE_TABLE[n_gpoly]";
    $temp[1] = "INDIE_TABLE[p_gpoly]";
  }
  foreach $n20_indie_name (@temp){
    foreach $t_type (@{$manuf_table{$n20_indie_name}{manuf_type_arr}}){
      if ($t_type =~ /COV_EFFECTIVE_FACTOR_TABLE_/){
        my $mos_name =$t_type;
        $mos_name =~ s/COV_EFFECTIVE_FACTOR_TABLE_//g;	
        if ($indie_name =~ /srm/){
          $mos_name = $mos_name."_M0_OD1_SRM";
        }else{
          $mos_name = $mos_name."_M0_OD1";
        }
        if ($N20_flag ne 'G'){
          $mos_name_tmp = $mos_name;
        }else{
          if ($mos_name =~ /IO/){
            $mos_name_tmp = "G_1D5V$mos_name";
          }else{
            $mos_name_tmp = "G_$mos_name";
          }
        }
        print ICT "   sub_conductor \"$mos_name_tmp\" \{ \n";
        print ICT "        via_edge_enlargement \n";
        print ICT "        vee_poco_spacings "; 
        for(my $i = 2 ; $i < 21 ; $i++ ){
          $temp = $i/100 ;
          print ICT "$temp ";       
        }
        print ICT "\n        vee_adjustments ";
        for(my $j =2 ; $j < 21 ; $j++){
          print ICT "$wee_adjust_value_final ";       
        }
        print ICT "\n";
        &print_rho($find_process_node , $indie_table);
        printf ICT "        temp_tc1 %.10f \n", $stack_hash{$indie_name}{TC1}  ;
        printf ICT "        temp_tc2 %.20f \n",$stack_hash{$indie_name}{TC2}   ;
        print ICT "   }\n";
      }
    }
  }

}

sub print_via0_info{
  my $find_process_node = $_[0];
  my $contact_name = $_[1];
  my $cont_upper_name = $_[2];
  my $cont_lower_name = $_[3];
  my $cont_width;
  my $cont_space;

  if ( $contact_name =~ /tap/){
    $contact_n = $contact_name;
  }else{
    if ($contact_name =~ /po/ && $contact_name !~ /tin/){
      $contact_n = "VIA0_$cont_lower_name";
    }else{
      $contact_n = uc($contact_name);
      $contact_n =~ s/VIA0/VIA0_M0/g;
      $contact_n =~ s/2//g;
      $contact_n =~ s/TIN/TiN/g;
      $contact_n =~ s/FOX_SRM/SRM_fox/g;
      $contact_n =~ s/FOX/fox/g;
    }
  }


  $cont_upper_name =~ s/metal/M/i ;
  $cont_lower_name =~ s/metal/M/i ;
  $cont_upper_name =  uc($cont_upper_name );
  $cont_lower_name = uc($cont_lower_name);
  $cont_upper_name =~ s/TIN/TiN/g;
  $cont_lower_name =~ s/TIN/TiN/g;
  $cont_upper_name =~ s/FOX_SRM/SRM_fox/g;
  $cont_lower_name =~ s/FOX_SRM/SRM_fox/g;
  $cont_upper_name =~ s/FOX/fox/g;
  $cont_lower_name =~ s/FOX/fox/g;
  if ($contact_n =~ /odtap/){
    $cont_lower_name = "active" ;
    $contact_name = 'n_odtap';
  }
  if ($contact_n  eq "n_fptap"){
    $cont_upper_name = "M0_PO_N" ;
    $cont_lower_name = "poly" ;
  } 
  if ($contact_n  eq "p_fptap"){
    $cont_upper_name = "M0_PO_P" ;
    $cont_lower_name = "poly" ;
  } 
  if ($contact_n  eq "n_fptap_srm"){
    $cont_upper_name = "M0_PO_N_SRM" ;
    $cont_lower_name = "poly_srm" ;
  } 
  if ($contact_n  eq "p_fptap_srm"){
    $cont_upper_name = "M0_PO_P_SRM" ;
    $cont_lower_name = "poly_srm" ;
  } 
  if ($contact_n eq "n_odtap_srm"){
    $contact_n = "odtap_srm";
    $contact_name = 'n_odtap_srm';
    $cont_upper_name = "M0_OD1_SRM";
    $cont_lower_name = "active" ;
  }
  print ICT "via \"$contact_n\" {\n" ;
  print ICT "   top_layer     \"$cont_upper_name\"\n" ;
  print ICT "   bottom_layer  \"$cont_lower_name\"\n" ;
  if ($contact_name =~ /via0_po/i) {
    print ICT "   min_top_encl -0.001 \n" ;
    print ICT "   min_bot_encl 0.012 \n" ;
  }
  if ($contact_name =~ /via0_sti2/i || $contact_name =~ /via0_od2/i) {
    print ICT "   min_top_encl -0.001 \n" ;
    print ICT "   min_bot_encl -0.003 \n" ;
  }
  if (exists $stack_hash{$contact_name}{WIDTH_ARRAY}){
    my @sort_value = sort (@{$stack_hash{$contact_name}{WIDTH_ARRAY}});
    $cont_width = @sort_value[0];
  }else{
    $cont_width = $stack_hash{$contact_name}{WIDTH};
  }
  if (exists $stack_hash{$contact_name}{LENGTH_ARRAY}){
    my @sort_value = sort (@{$stack_hash{$contact_name}{LENGTH_ARRAY}});
    if ($cont_width > $sort_value[0]){
      $cont_width = $sort_value[0];
    }
  }else{
    if ($cont_width > $stack_hash{$contact_name}{LENGTH}){
      $cont_width = $stack_hash{$contact_name}{LENGTH};
    }
  }
  if (exists $stack_hash{$contact_name}{SPACE_ARRAY}){
    my @sort_value = sort (@{$stack_hash{$contact_name}{SPACE_ARRAY}});
    $cont_space = @sort_value[0];
  }else{
    $cont_space = $stack_hash{$contact_name}{SPACE};
  }
  print ICT "   min_width $cont_width \n" ;
  print ICT "   min_spacing $cont_space \n" ;

  if (exists $stack_hash{$contact_name}{AREA} ) {
    if ($contact_name !~ /odtap|m[ds]tap/){
      print ICT "   area_resistance ";
      foreach $area_via_value ( sort keys(%{$stack_hash{$contact_name}{AREA}}))  {

        $via_resist_value = $stack_hash{$contact_name}{AREA}{$area_via_value}{RESIST} ;

        if ($ircx_process_node =~/cbest/i && $ircx_process_node !~ /typical/){

          $via_resist_value = $via_resist_value + $stack_hash{$contact_name}{AREA}{$area_via_value}{VARIATION_CBEST} ;
        }
        if ($ircx_process_node =~/cworst/i && $ircx_process_node !~ /typical/){
          $via_resist_value = $via_resist_value + $stack_hash{$contact_name}{AREA}{$area_via_value}{VARIATION_CWORST} ;

        }

        print ICT " $via_resist_value  $area_via_value" ;


      }
      print ICT "\n";
    }
    $via_not_match_tc1 = 0 ; 
    $via_not_match_tc2 = 0 ;
    @via_area_array_tc1 =  keys(%{$stack_hash{$contact_name}{AREA}});
    @via_area_array_tc2 =  keys(%{$stack_hash{$contact_name}{AREA}});
    for ($av=0;$av<=scalar(@via_area_array_tc1)-1;$av++){

      #print " The area avv is $av \n" ; 
      $area_via_value = @via_area_array_tc1[$av] ;

      #print " The area via value is $area_via_value \n" ; 

      if ($av == 0) {
        $via_tc1_prev = $stack_hash{$contact_name}{AREA}{$area_via_value}{TC1} ;
      } else {

        if ( $stack_hash{$contact_name}{AREA}{$area_via_value}{TC1} != $via_tc1_prev) {
          $via_not_match_tc1 = 1 ;
          $via_tc1_prev = $stack_hash{$contact_name}{AREA}{$area_via_value}{TC1} ;
        }
        $via_tc1_prev = $stack_hash{$contact_name}{AREA}{$area_via_value}{TC1} ;
      }
    }

    for ($av=0;$av<=scalar(@via_area_array_tc2)-1;$av++){

      #print " The area avv is $av \n" ; 
      $area_via_value = @via_area_array_tc2[$av] ;

      #print " The area via value is $area_via_value \n" ; 

      if ($av == 0) {
        $via_tc2_prev = $stack_hash{$contact_name}{AREA}{$area_via_value}{TC2} ;
      } else {

        if ( $stack_hash{$contact_name}{AREA}{$area_via_value}{TC2} != $via_tc2_prev) {

          $via_not_match_tc2 = 1 ;
          $via_tc2_prev = $stack_hash{$contact_name}{AREA}{$area_via_value}{TC2} ;
        }
        $via_tc2_prev = $stack_hash{$contact_name}{AREA}{$area_via_value}{TC2} ;
      }
    }




    if ($via_not_match_tc1 == 1 && $via_not_match_tc2 == 1 ) {
      print ICT "   area_dependent_tc \n" ;
      print ICT "     temp_areas " ;
      foreach $area_via_value ( sort keys(%{$stack_hash{$contact_name}{AREA}}))  {

        print ICT " $area_via_value ";  
      }
      print ICT " \n     temp_tc1 ";

      foreach $area_via_value ( sort keys(%{$stack_hash{$contact_name}{AREA}}))  {

        $via_tc1 =  sprintf("%.10f", $stack_hash{$contact_name}{AREA}{$area_via_value}{TC1}) ;
        print ICT " $via_tc1 ";  
      }
      print ICT " \n     temp_tc2 ";
      foreach $area_via_value ( sort keys(%{$stack_hash{$contact_name}{AREA}}))  {

        $via_tc2 =  sprintf("%.10f", $stack_hash{$contact_name}{AREA}{$area_via_value}{TC2}) ;
        print ICT "$via_tc2  ";  
      }
      print ICT " \n" ; 
    }else{
      $via_tc1 = sprintf("%.10f", $stack_hash{$contact_name}{TC1});
      $via_tc2 = sprintf("%.20f", $stack_hash{$contact_name}{TC2});
      print ICT "   temp_tc1 $via_tc1  \n" ;
      print ICT "   temp_tc2 $via_tc2  \n" ;
    }
    if ($stack_hash{$contact_name}{EFFECTIVE_WIDTH} !~ /N\/A/i ) {

      print ICT "   slot_via_long_edge ";
      foreach $area_via_value ( sort keys(%{$stack_hash{$contact_name}{AREA}}))  {

        $via_long =  sprintf("%.5f", $stack_hash{$contact_name}{AREA}{$area_via_value}{LENGTH}) ;
        print ICT " $via_long ";

      }
      print ICT "  \n";
      print ICT "   slot_via_short_edge ";
      foreach $area_via_value ( sort keys(%{$stack_hash{$contact_name}{AREA}}))  {

        $via_short =  sprintf("%.5f", $stack_hash{$contact_name}{AREA}{$area_via_value}{WIDTH}) ;
        print ICT " $via_short ";

      }
      print ICT "  \n";
      print ICT "   slot_via_long_edge_enlargement ";
      foreach $area_via_value ( sort keys(%{$stack_hash{$contact_name}{AREA}}))  {

        $via_l_enlarge =  sprintf("%.5f", ($stack_hash{$contact_name}{AREA}{$area_via_value}{EFFECTIVE_LENGTH}-$stack_hash{$contact_name}{AREA}{$area_via_value}{LENGTH})/2) ;
        print ICT " $via_l_enlarge ";

      }
      print ICT "  \n";
      print ICT "   slot_via_short_edge_enlargement ";
      foreach $area_via_value ( sort keys(%{$stack_hash{$contact_name}{AREA}}))  {

        $via_s_enlarge =  sprintf("%.5f", ($stack_hash{$contact_name}{AREA}{$area_via_value}{EFFECTIVE_WIDTH}-$stack_hash{$contact_name}{AREA}{$area_via_value}{WIDTH})/2) ;
        print ICT " $via_s_enlarge ";

      }
      print ICT "  \n";
    }
  } else {

    $via_resist = $stack_hash{$contact_name}{RESIST} ; 
    if ($ircx_process_node =~/cbest/i && $ircx_process_node !~ /typical/){ 
      @via_variation_info = split /\//,  $stack_hash{$contact_name}{VARIATION} ;
      $via_resist = $via_resist + @via_variation_info[-1] ;
    }

    if ($ircx_process_node =~/cworst/i && $ircx_process_node !~ /typical/){
      @via_variation_info = split /\//,  $stack_hash{$contact_name}{VARIATION} ;
      $via_resist = $via_resist + @via_variation_info[-2] ;
    }
    if ($contact_name !~ /odtap|m[ds]tap/){
      print ICT "   area_resistance  $via_resist ", $stack_hash{$contact_name}{WIDTH}*$stack_hash{$contact_name}{LENGTH}," \n" ;
    }
    $via_tc1 = sprintf("%.10f", $stack_hash{$contact_name}{TC1});
    $via_tc2 = sprintf("%.20f", $stack_hash{$contact_name}{TC2});
    print ICT "   temp_tc1 $via_tc1  \n" ;
    print ICT "   temp_tc2 $via_tc2  \n" ;
  }


  #$em_layer = @array_stack_via[$i] ;
  #print "Processing $em_layer\n" ;
  if ($contact_name =~ /tap/){
    print ICT "   fracture_vias true \n" ;
  }
  if ($contact_name =~ /odtap/){
    &print_gate_facing_via_res($find_process_node, $contact_name);
    if ($contact_name !~ /srm/){
      $contact_name = "n_odtap";
      print ICT "   sub_via \"n_odtap\" \{\n";
      $via_resist = $stack_hash{$contact_name}{RESIST} ; 
      if ($ircx_process_node =~/cbest/i && $ircx_process_node !~ /typical/){ 
        @via_variation_info = split /\//,  $stack_hash{$contact_name}{VARIATION} ;
        $via_resist = $via_resist + @via_variation_info[-1] ;
      }

      if ($ircx_process_node =~/cworst/i && $ircx_process_node !~ /typical/){
        @via_variation_info = split /\//,  $stack_hash{$contact_name}{VARIATION} ;
        $via_resist = $via_resist + @via_variation_info[-2] ;
      }
#    print ICT "   area_resistance  $via_resist ", $stack_hash{$contact_name}{WIDTH}*$stack_hash{$contact_name}{LENGTH}," \n" ;
      $via_tc1 = sprintf("%.10f", $stack_hash{$contact_name}{TC1});
      $via_tc2 = sprintf("%.20f", $stack_hash{$contact_name}{TC2});
      print ICT "   temp_tc1 $via_tc1  \n" ;
      print ICT "   temp_tc2 $via_tc2  \n" ;
      &print_gate_facing_via_res($find_process_node, $contact_name);
      print ICT "   }\n";
      $contact_name = "p_odtap";
      print ICT "   sub_via \"p_odtap\" \{\n";
      $via_resist = $stack_hash{$contact_name}{RESIST} ; 
      if ($ircx_process_node =~/cbest/i && $ircx_process_node !~ /typical/){ 
        @via_variation_info = split /\//,  $stack_hash{$contact_name}{VARIATION} ;
        $via_resist = $via_resist + @via_variation_info[-1] ;
      }

      if ($ircx_process_node =~/cworst/i && $ircx_process_node !~ /typical/){
        @via_variation_info = split /\//,  $stack_hash{$contact_name}{VARIATION} ;
        $via_resist = $via_resist + @via_variation_info[-2] ;
      }
#    print ICT "   area_resistance  $via_resist ", $stack_hash{$contact_name}{WIDTH}*$stack_hash{$contact_name}{LENGTH}," \n" ;
      $via_tc1 = sprintf("%.10f", $stack_hash{$contact_name}{TC1});
      $via_tc2 = sprintf("%.20f", $stack_hash{$contact_name}{TC2});
      print ICT "   temp_tc1 $via_tc1  \n" ;
      print ICT "   temp_tc2 $via_tc2  \n" ;
      &print_gate_facing_via_res($find_process_node, $contact_name);
      print ICT "   }\n";
    }else{
      $contact_name = "n_odtap_srm";
      print ICT "   sub_via \"n_odtap_srm\" \{\n";
      $via_resist = $stack_hash{$contact_name}{RESIST} ; 
      if ($ircx_process_node =~/cbest/i && $ircx_process_node !~ /typical/){ 
        @via_variation_info = split /\//,  $stack_hash{$contact_name}{VARIATION} ;
        $via_resist = $via_resist + @via_variation_info[-1] ;
      }

      if ($ircx_process_node =~/cworst/i && $ircx_process_node !~ /typical/){
        @via_variation_info = split /\//,  $stack_hash{$contact_name}{VARIATION} ;
        $via_resist = $via_resist + @via_variation_info[-2] ;
      }
#    print ICT "   area_resistance  $via_resist ", $stack_hash{$contact_name}{WIDTH}*$stack_hash{$contact_name}{LENGTH}," \n" ;
      $via_tc1 = sprintf("%.10f", $stack_hash{$contact_name}{TC1});
      $via_tc2 = sprintf("%.20f", $stack_hash{$contact_name}{TC2});
      print ICT "   temp_tc1 $via_tc1  \n" ;
      print ICT "   temp_tc2 $via_tc2  \n" ;
      &print_gate_facing_via_res($find_process_node, $contact_name);
      print ICT "   }\n";
      $contact_name = "p_odtap_srm";
      print ICT "   sub_via \"p_odtap_srm\" \{\n";
      $via_resist = $stack_hash{$contact_name}{RESIST} ; 
      if ($ircx_process_node =~/cbest/i && $ircx_process_node !~ /typical/){ 
        @via_variation_info = split /\//,  $stack_hash{$contact_name}{VARIATION} ;
        $via_resist = $via_resist + @via_variation_info[-1] ;
      }

      if ($ircx_process_node =~/cworst/i && $ircx_process_node !~ /typical/){
        @via_variation_info = split /\//,  $stack_hash{$contact_name}{VARIATION} ;
        $via_resist = $via_resist + @via_variation_info[-2] ;
      }
#    print ICT "   area_resistance  $via_resist ", $stack_hash{$contact_name}{WIDTH}*$stack_hash{$contact_name}{LENGTH}," \n" ;
      $via_tc1 = sprintf("%.10f", $stack_hash{$contact_name}{TC1});
      $via_tc2 = sprintf("%.20f", $stack_hash{$contact_name}{TC2});
      print ICT "   temp_tc1 $via_tc1  \n" ;
      print ICT "   temp_tc2 $via_tc2  \n" ;
      &print_gate_facing_via_res($find_process_node, $contact_name);
      print ICT "   }\n";
    }

  }elsif ($contact_name =~ /m[ds]tap/){
    &print_gate_facing_via_res($find_process_node, $contact_name);
  }
  &output_em_via_m0($contact_name) ;
  if ($contact_n =~ /tap/){
    my $indie_tap = "metal0_po";
    if ($cont_upper_name =~ /SRM/){
      $indie_name = "metal0_po_srm";
      if ($cont_upper_name =~ /M0_STI(\d+)_SRM/){
        $indie_tap = "metal0_sti$1_srm";
      }
      if ($cont_upper_name =~ /M0_OD(\d+)_SRM/){
        $indie_tap = "metal0_od$1_srm";
      }
    }else{
      if ($cont_upper_name =~ /M0_STI(\S+)/){
        $indie_tap = "metal0_sti$1";
      }
      if ($cont_upper_name =~ /M0_OD(\S+)/){
        $indie_tap = "metal0_od$1";
      }
    }
    &output_em_conductor_m0_tap($indie_tap);
  }
  print ICT "}\n";
}



sub print_gate_facing_via_res{
  my $find_process_node = $_[0];
  my $tap_name = $_[1];
  my $mos_name;
  if ($tap_name =~ /p_odtap/){
    $indie_name = "INDIE_TABLE[POD]";
    if ($N20_flag ne 'G'){
      if ($tap_name =~ /srm/){
        $mos_name = "$N20_flag\_SRM_PMOS";
      }else{
        $mos_name = "$N20_flag\_CORE_PMOS";
      }
    }else{
      $mos_name = "IO_PMOS";
    }
  }else{
    $indie_name = "INDIE_TABLE[NOD]";
    if ($N20_flag ne 'G'){
      if ($tap_name =~ /srm/){
        $mos_name = "$N20_flag\_SRM_NMOS";
      }else{
        $mos_name = "$N20_flag\_CORE_NMOS";
      }
    }else{
      $mos_name = "IO_NMOS";
    }
  }
  if ($tap_name =~ /m[ds]tap/){
    $indie_effect = "RCSD_Rc_MD2_TABLE_$mos_name";
  }else{
    $indie_effect = "RCSD_Rc_MD1_TABLE_$mos_name";
  }

  print ICT "     gate_facing_via_resistance {\n" ;
  print ICT "      via_width " ;

  for (my $wef=1; $wef<=scalar @{ $manuf_table{$indie_name}{$indie_effect}{second_line}}-1;$wef++) {
    $via_width = $manuf_table{$indie_name}{$indie_effect}{second_line}[$wef] ;
    print ICT "$via_width " ;
  }
  print ICT "\n";
  print ICT "      via_length " ;
  for (my $wef=1; $wef<=scalar @{ $manuf_table{$indie_name}{$indie_effect}{first_line}}-1;$wef++) {
    $via_length_value = $manuf_table{$indie_name}{$indie_effect}{first_line}[$wef] ;
    print ICT "$via_length_value " ;
  }
  print ICT "\n";

  print ICT "      via_resistance " ;
  for ( my $wef=1; $wef<=scalar @{ $manuf_table{$indie_name}{$indie_effect}{first_line}}-1;$wef++) {

    for ( my $sef=1; $sef<=scalar @{ $manuf_table{$indie_name}{$indie_effect}{second_line}}-1;$sef++) {

      my $width_index_value =  $manuf_table{$indie_name}{$indie_effect}{second_line}[$sef] ;
      my $length_index_value =  $manuf_table{$indie_name}{$indie_effect}{first_line}[$wef] ;

      my $via_res_value = $manuf_table{$indie_name}{$indie_effect}{$width_index_value}{$length_index_value} ;
      $via_res_value = sprintf("%.8f",$via_res_value);

      print ICT "$via_res_value " ;
    }
    print ICT "\n                      ";
  }
  #		print ICT "\n     }\n";
  print ICT "}\n";
}



# Required for Emacs
# Local variables:
# mode: perl
# end:

